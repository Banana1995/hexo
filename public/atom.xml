<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小蚂蚁爱吃香蕉</title>
  
  <subtitle>It&#39;s what you do in the dark puts you in the light</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-05-07T13:30:24.527Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小蚂蚁爱吃香蕉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2021/04/17/%E5%85%B3%E4%BA%8E%E8%A3%B8%E8%BE%9E%E7%9A%84%E7%A6%BB%E8%81%8C%E7%BB%8F%E9%AA%8C/"/>
    <id>http://yoursite.com/2021/04/17/关于裸辞的离职经验/</id>
    <published>2021-04-17T09:06:26.514Z</published>
    <updated>2021-05-07T13:30:24.527Z</updated>
    
    <content type="html"><![CDATA[<p>关于辞职这件事情，在不同的行业不同的岗位肯定也有着不同的方式，而每个人肯定都会对此有不同的看法。我也不知道什么样的方式是合理的，合适的，收益最大的。写下这篇文章只是为了记录下个人的经验和思考，以便日后回味与借鉴。</p><h1 id="慎重决定是否辞职"><a href="#慎重决定是否辞职" class="headerlink" title="慎重决定是否辞职"></a>慎重决定是否辞职</h1><p>在谈裸辞之前，首先我觉得需要谈论的是辞职这件事情本身。</p><p>听说马云说过这么一句话：</p><blockquote><p>员工离职的缘由只有两个，要么受委屈了，要么钱没给够。</p></blockquote><p>原话是不是这样我不太清楚，是不是马云说的我也不太清楚，懒得查证了。只是这句话被很多人流传，大家都觉得很有道理。既然大家都觉得有道理，那么它也一定是概括了很大一部分人的离职理由。但是对于我来说，我的离职理由却不在其中。得益于受领导赏识，在上家公司工作的时候并没有受过什么天大的委屈，并且公司给我的工资虽说比不上一些同学们在互联网大厂的水平，但也算得上是跟得上平均线。相对于公司的工作强度和压力来说，价格偏低但是不至于到需要离职的地步。并且在部门里，我的工作非常核心，以后职业上升空间也很大，长期在公司做下去的话，手里的期权价值伴随着公司成长，日后若能兑现也能获得一番不错的收益。</p><p>对我来说，真正离职的原因应该是超出我身体所能承受的工作强度与压力，还有与个人价值观相悖的公司文化。</p><p>在决定要离职之前，我思考了很久，大概持续了几个月。我也一直在离职的边缘犹豫，徘徊。一方面是工作的压力与强度太大。我每次在出差之后便要去一趟医院，身体这个机器总有些毛病需要去医院里修理一下，我开始意识到出差时的压力和强度已经超出了我身体的负荷了，长期这样下去必然不可持续。另一方面，我喜欢自己的工作内容，忙碌使得我每天过的充实，过一段时间回头看自己走过的路发现那些都是成长。同时工作创造的价值得到了同事和领导的认可，也让自己很有成就感。这两方面的力一起作用在我身上，使得我有一种痛并快乐着的感觉。</p><p>压倒我的最后一根稻草是最后一次出差，那一次也是我在公司三年经历的压力最大，强度最高，时间最长的一次任务。在那次出差任务中，最长一次熬了三天两夜，中间只睡了四五个小时。整个出差周期长达一个月，基本是除了七八个小时的睡觉吃饭时间，其他全在工作的状态，更别谈什么周末休息了。在整个出差周期结束后，公司体恤我们辛苦，给我们放了一天的假期。那天是周五，连着周末可以放三天。而我在出差返回深圳的路上得知会放一天假的时候，心理已经做好了离职的决定。</p><p>彼时已经接近年尾，我决定得到年后拿了年终奖再提离职流程，同时也开始进行辞职准备工作。刚好等到了年后，我也在公司工作了两年，到时候出去简历也会好看些。</p><p>至此，促使我辞职的理由变成了：</p><ul><li>超出身体承受能力的压力和强度，不可持续。</li><li>公司以狼性文化要求和对待员工，却不提供可观的回报。</li><li>作为程序猿，在公司工作了两年，即使不离职也应该去面试了解下市场的行情与技术，避免与市场脱节。</li><li>工作时间太久，没有私人生活，导致工作生活无法平衡。长远来看（三到五年），没有时间阅读和思考，技术和非技术上都不会有太大的提升，最后会被困在眼前这份工作里，思维跳脱不出来，也无法尝试更多可能，生活一团糟。这些对自己的发展极为不利。</li></ul><p>而让我留下的理由变成了：</p><ul><li>工作内容核心，自己非常熟悉，领导赏识，职业向上晋级空间大，难度低。</li><li>公司的期权伴随着公司上市会带来可观的回报</li><li>稳定的工作状态和生活环境也是我所追求的，伴随公司长期成长才能获得较大的利益，同时我也很热爱深圳这座城市，那里的气候真是太让我喜欢了。（这里与程序猿过两年就该去面试不冲突，面试并不全是为了换工作。对我而言更多的是对自己查缺补漏，看看市场的价格，看看市场上的人才要求。再对比自己的不足，促进自己成长）</li></ul><p>于是，针对以上两方面，我反问自己以下几个问题：</p><ul><li>工作强度和压力在身体承受范围内，但是依旧会长期加班，没有私人时间，我会不会留下来？答案是不会，为了长期发展，这样的生活我不想接受。</li><li>公司给足了钱，达到与互联网大厂同级的水平，我会不会留下来？答案是不会，而且我心里也并不想为了钱去那些互联网大厂。</li><li>公司不再要求狼性文化，团队氛围不再996，我会不会留下来？答案是依旧会去找机会面试，但很大的可能会留下来。</li><li>公司期权的兑现预期如何？能获得大概多少的回报？按照我离职时听到的消息，大概我可以获得五百万以内的回报，公司上市至少需要三年，中间包含的变量太多，上市后还不清楚公司会不会出台一些对期权变现的限制政策。</li></ul><p>对上面这几个问题有了答案之后，再结合现实中，公司极大概率会是长期996，工作强度和压力在我身体接受范围的边缘状态，但是我没有时间阅读，试错，提升。而这些是我非常看重的东西，在我看来人的成长是自己对这个世界认知的过程，没有时间阅读和试错的话就无法获取更多的认知，也就无法成长。</p><blockquote><p>试想一下，如果每天的时间都花在了工作的一亩三分地中，所接触的环境，遇到和解决的问题都是在一个范围内的，你每天没有时间和精力去干别的什么事情。当有一天，你遇到了这个范围以外的问题，你会发现自己是个新手，什么都不会，会有很强的无力感。这也是我前面说的会被困在工作里的意思。</p><p>整个世界是非常庞大的，更多的问题来自于这个范围以外，我需要更多的时间来认知这个范围之外的事情，这些事情包括亲情关系，社会关系，社会运转体系等等。我相信只有对这些事情有更好的认知，才能在以后的生活中遇到困难与挫折时更加从容的面对它们，不至于感到无能为力而陷入焦虑。而只有阅读和试错才能让我更好的认知它们，我把这称为扩大自己的能力圈。</p></blockquote><p>在另一方面，获得期权回报的不确定性太高，而且这些回报与我所看重的扩大能力圈相比，至少在我现在这个阶段后者应该更重要。</p><p>以上是我整个离职的思考过程，在要不要离职的这个决定的背后，占比最多的是我在扩大能力圈和坚持陪伴公司成长获得回报之间做出的选择。而做出这个选择的背后，是我对自己的认知。这个选择最终的结果，可能得多年后才能知道，如果我选错了，我想更可能的原因是由于对自己的认知不足，导致扩大能力圈失败。但是我想我不会后悔，因为这也是个试错的过程。</p><h1 id="更加慎重的决定是否裸辞"><a href="#更加慎重的决定是否裸辞" class="headerlink" title="更加慎重的决定是否裸辞"></a>更加慎重的决定是否裸辞</h1><p>在决定了要辞职之后，下一个问题是该怎么辞职？是骑驴找马，还是直接裸辞。由于客观条件限制，我基本无法做到骑驴找马，所以选择了裸辞。但是在裸辞之前，需要先考虑一些实际的问题：</p><ul><li>生活压力（钱）的问题</li></ul><p>对于大部分人来说，裸辞最大的影响应该是没有了收入来源。所以在裸辞的时候，需要考虑到将来的一段时间完全没有收入，手里的钱够自己生活多久。有很多人不知道自己一个月会花多少钱，拍脑袋算出来的数目很可能并不客观。建议拉出自己过去一年的账单，计算下每个月的支出项目平均值。一年内有贷款的话，注意需要将自己的日常消费与贷款还款的钱分开计算，否则平均值有可能不能够代表未来一段时间的支出。</p><p>除了日常消费和贷款偿还的钱以外，还建议考虑下意外情况的支出，给自己做足压力测试。</p><p>以我为例，预期是自己半年的时间没有收入，没有需要偿还的贷款，在加上之前已经为生活的意外情况准备过一些预案，因此我需要准备好一笔勾自己半年花的钱才能裸辞。</p><ul><li>心理压力的问题</li></ul><p>裸辞所遇到的钱的问题，相对容易解决，更难以解决的是心理压力问题。如果你把裸辞的事情告诉了家里人，家里人可能隔三差五就要来问问你，替你担心。</p><p>以我为例，初期我没告诉家里人我裸辞了，想着自己gap一段时间，好好沉淀下，夯实基础再去面试。于是开始做一些学习计划，然而后面由于计划执行进度落后自己预期，会时常感到焦虑。同时偶尔的身体状态不好，也更拖累学习进度，心理状态更加不好，容易陷入恶性循环。</p><p>我爷爷在后期得知了我裸辞之后，特别着急，隔三差五就来电话询问我找工作的情况。本来我的心态还行，但是在他那样的状态下，我反而要去安慰他。很影响我自己的心态。</p><h1 id="辞职准备"><a href="#辞职准备" class="headerlink" title="辞职准备"></a>辞职准备</h1><p>在做好了辞职决定，并且接受裸辞后，就需要开始做一些辞职准备了。</p><ul><li>如果可以的话，想清楚自己要什么</li></ul><p>在做完了辞职决定的时候，你心理一定清楚的是自己不要什么。但是你也可能会跟我一样，不知道自己要什么。这个问题对我来说很难。只是很清楚那样的工作和生活我不想要，但是完全看不清未来，不知道自己想要什么，没有方向感。如果能够想清楚的话，那也会目标很清晰，不会觉得未来迷茫，对后续的规划很有帮助。</p><p>我其实直到离职之后很长一段时间都没有想清楚这个问题。但是有了一个模糊的方向后，朝着那个方向努力，踏出离职这第一步也是比较重要的。</p><ul><li>一份规划</li></ul><p>首先是需要做个规划，每个人裸辞后做的事情不太一样，但是大体上你都需要一个规划。这个规划建议以更长的视角来看。</p><p>还是以我为例，我计划裸辞后，下一份工作尽量摆脱无休止的加班，即使在薪资上有所妥协也愿意。那么观察了一圈，发现最合适的是外企，其次是甲方单位。但是甲方大多是国企，风格上我不太喜欢。所以就很想去外企。接着在深圳这座城市，合适的外企并不多，更多的是在上海。去往上海的话，离我家更近，对我来说也是个不错的选择。尽管我很喜欢深圳，但是为了长久考虑，去上海更适合我。</p><p>确定了去上海的外企这个方向后，就需要围绕这个目标来做规划。外企一般对英语要求较高，所以加强英语方面的能力势在必行。同时，自己的几个目标公司都对算法要求较高，那系统的练习算法也是必须的。同时，还有关于系统设计和基础知识方面的内容。建议这个时候可以开始写简历了，在一家公司干了一段时间，能够写在简历上带走的才是你的能力。写简历有助于梳理自己的技能树，更好的做规划。</p><p>做规划需要尽可能的详细和考虑更多的因素，并且在离职前就开始按照规划进行。比如规划每一件事情，要尽量包含目标，达到目标的时间，每天的节奏等。然后离职前开始按照规划执行，这样可以让自己明白自己的速度，能否顺利完成规划的事情，是否需要调整预期，或者作出取舍。有时候并不是自己不够自律的按计划执行，而是低估了完成目标需要花费的时间，或者是高估了自己所拥有的时间。这些在离职前就开始着手进行的话，会有较多的试错和调整空间。</p><p>还有一点比较重要的是，在规划完之后，将截止日期往后延期一两个月。这是因为我一般做计划都喜欢给自己预留缓冲量。倒不是给自己拖延找时间。而是为了避免中途发生的意外情况。就像我一般赶车，正常提前一个小时到机场基本就够了，但是我会提前一个半小时到机场，这样我走到一半发现身份证没带回去拿还有机会赶得上。</p><blockquote><p>这一点是我在离职前没有做好的事情。我只是有了个大概的目标，但是毫无规划。后来离职后的规划做的太离谱，给自己排的时间不够。高估了自己完成任务的速度，这导致我完成一件事情会延期，离职后一旦规划的事情出现了延期，就会很影响心态。</p></blockquote><ul><li>攒够钱</li></ul><p>在完成规划后，你知道自己大概需要多久能获得下一份工作。在开始下一份工作后，再过一个月才能拿到收入。因此，你需要攒够这一段时间要花的钱。这里我也是喜欢给自己留足缓冲量，除了家里的应急钱和gap期间的生活开支以外，再多留两三个月的支出。这是为了预防我没能在预期时间内找到工作。</p><p>个人觉得，做好了上面的事情就可以开始提出走离职流程了。</p><h1 id="辞职后"><a href="#辞职后" class="headerlink" title="辞职后"></a>辞职后</h1><p>在离开了公司后，由于会有一段空档期。所以这段时间最需要注意的是自己的社保情况。可以自己找淘宝代缴，也可以自己去人社局缴，各地政策不太一样，但是最好能够保证不会断档。因为断档会影响购房等资格。淘宝代缴的话需要提前跟卖家沟通好，要与新公司开始缴纳的接续上，不然淘宝退的晚可能也会有问题。这点需要注意。</p><p>当然政策会时有更新，这只是目前的情况。</p><h1 id="找工作准备"><a href="#找工作准备" class="headerlink" title="找工作准备"></a>找工作准备</h1><p>离职前已经做的那些准备都是为了在gap期可以不要有那么大的压力。对我来说，储蓄了足够的现金使得我在gap期遇到各种意外情况时都觉得不至于压力很大。更多的压力来源于该怎样找到一份合适的好工作。</p><p>原本计划就是在gap期做些沉淀，然后再出去尝试。我列举了一系列的目标公司，针对公司的招聘jd进行准备。有些公司偏重算法，有些偏重基础，有些偏重系统架构设计。这些都需要做一些准备，否则贸然去面可能不会有好结果，并且被吊打了的话还蛮影响心态的。</p><p>也可以去各个网站，论坛，脉脉，知乎，牛客了解下公司的面经和公司整体情况。不符合目标的公司就不要浪费时间了。每一场面试都应该是有目的和意义的。有得为了锻炼自己，有得为了提升信心，有得为了练手。但是不要用那些垃圾公司来做试金石，因为你可能碰到一个垃圾的面试官，那样就纯粹是浪费时间浪费精力。</p><h1 id="学习经验"><a href="#学习经验" class="headerlink" title="学习经验"></a>学习经验</h1><p>我在gap期做了很多算法，系统设计还有java训练营的学习。但是对市面上的一些流行技术了解不够多，这方面还是比较被动。只有在我实际开始学习，开始做准备的时候，我才意识到原来差距真的挺大的。很多应届生的面试题我都不会。后来开始学习的时候，又各种原因耽误，始终难以进入最佳状态。一天能够做的事情真的很少，当时我一天既要学习架构又要学习算法，结果后来就导致架构没学好，算法进展也很慢。一个月下来，发现与自己的预期相差甚远。</p><p>另一方面，自己也低估了期望公司的面试难度。事前没有做好调查，我以为难度是70分，然而实际上的难度是90分。我本以为做到70分需要一个月，实际上快的也需要三个月，做到90分需要五个月。这还是在全心投入一件事情上的结果，而我想要同时学习多个方向，效果更差。这些都是我先前没有调查清楚，没有提前行动，导致我的规划基本上不可实现。</p><p>后来我放弃学习架构和训练营，主攻算法，同时复习基础内容。最后也放弃了列表里的一部分公司。其实这些学习积累更多的应该是平时做，而不是离职后才做。但是之前的工作太忙，根本没时间做这么多积累输出。甚至对于系统的架构设计都没太多时间查阅资料，做详细的研究和验证。导致离开了工作后，真正能带走的属于自己的东西不多。这也是我讨厌无休止加班的原因。</p><h1 id="心态调整"><a href="#心态调整" class="headerlink" title="心态调整"></a>心态调整</h1><p>在gap期间，我生过几次小病，还晕倒过一次。每次一生病就会让自己变得很低落。同时由于学习进度落后太多，自己又会陷入焦虑。看着目标公司的门槛比自己预期的高出一大截，心理的焦虑又增加几分。生病期间，整个人都是很不好的状态。所幸我没有面临太多来自家里人的压力，因为他们不知道我裸辞了。直到现在我已经入职新公司了，依旧觉得这个决定做的很对。我父母还好，基本不会太过问。但是爷爷奶奶就非常担心。感觉他们比我还要焦虑。</p><p>所以，离职后虽然自由，但是依旧要小心的保护好自己身体健康。一定要饮食规律！锻炼身体我就不说了，作息规律，饮食规律非常重要。离职后每天就睡到中午，然后开始打游戏，追剧。这种日子偶尔过两天还行。但是裸辞的话，最好一天也不要过这样的日子。首先是因为这种日子真的很有吸引力，一旦过上了就不想离开了。我生病的时候就会让自己变成一个毫不努力的废物的状态。废物真的太舒服了，所以即使后来身体恢复了也不想朝九晚五的去学习。但是不学习，不努力又会使我变得焦虑。所以我整个gap期间，这样的日子过得也不多。大多数日子，只要有空我就会去图书馆或者咖啡馆，进步会极大的缓解我的焦虑，甚至会让我有开心的感觉。</p><p>因此我在gap期间，焦虑状态有过好几次，但是得益于坚持学习和足够的储蓄，最终算是平安度过，最后也拿到个自己觉得合适的offer。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于辞职这件事情，在不同的行业不同的岗位肯定也有着不同的方式，而每个人肯定都会对此有不同的看法。我也不知道什么样的方式是合理的，合适的，收益最大的。写下这篇文章只是为了记录下个人的经验和思考，以便日后回味与借鉴。&lt;/p&gt;
&lt;h1 id=&quot;慎重决定是否辞职&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2021/04/17/%E5%85%B3%E4%BA%8E%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8D%A2%E5%B7%A5%E4%BD%9C%E7%9A%84%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    <id>http://yoursite.com/2021/04/17/关于第二次换工作的面试经验/</id>
    <published>2021-04-17T08:24:19.844Z</published>
    <updated>2021-04-21T13:28:18.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试记录与经验感受"><a href="#面试记录与经验感受" class="headerlink" title="面试记录与经验感受"></a>面试记录与经验感受</h1><h2 id="花旗"><a href="#花旗" class="headerlink" title="花旗"></a>花旗</h2><h3 id="面试记录"><a href="#面试记录" class="headerlink" title="面试记录"></a>面试记录</h3><p>花旗的面试过程比较坎坷，显示2020年底被人力找到简历直接电话过来问我有没兴趣。当时抱着试试水的态度面了一下，也是我离职后第一次安排面试。后来一面人力反馈说是因为面试官觉得支付类的业务更适合我，与当时的职位不太匹配而挂掉。</p><p>过完年后，2021年初，开始正式找工作的时候，又被人力把简历捞起来，推荐到另外个组的岗位上去。最终有了第二次面试花旗的机会。</p><p><img src="/2021/04/17/关于第二次换工作的面试经验/微信图片_20210417170321.jpg" alt="img"></p><h3 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h3><p>花旗是外企，从事金融类业务。我面试的岗位做的是风控业务。跟我上一段工作经历有些类似的地方，所以在业务背景上，也算是有些相关。然后就技术上来说，整体上初面侧重于基础，问的技术问题都非常简单，唯一让我觉得有些为难的是英语对话。不管是第一次一面的英文，还是第二次一面的英文我都觉得表现发挥的不太好。难以表达出自己的意思，其实词汇量问题不大，主要是没有过锻炼的机会。之前有约教练联系过一些，但是效果不太好，也没坚持。英文方面表现最好的其实算是第二次的二面，与面试官交流的比较多。主要是因为第二次面试的时候，面试官打开了我跟他讨论的话匣子，我可以用英语说得比较多，然后说得多也就愈发的接近我想要表达的意思了。</p><p>二面的技术难度比一面相对更高，就几家公司的面试情况来看也基本都是这个特征。一面主要是摸底，二面会提高技术难度，问的更深更细节，当然不同公司的侧重点还是不一样。花旗的二面在我介绍完自己熟悉多线程后，直接开始从多线程相关的开始追问细节。<strong>整体上面试官会问的多的是，简历上写着自己熟悉的技能，且面试官自己比较了解的。</strong>无法得知面试官熟悉了解哪些，只能从招聘的jd结合他们的业务技术栈上猜测。所以最核心的还是把简历上自己写的熟悉的技能了解清楚。其次，针对一些基础性问题需要尽量确保不能犯错，这点需要平时积累。</p><p>最后三面的时候，Manager没有面试，直接让人力来谈薪水，说是他把控下薪资范围就行。后来人力电话过来开了28k的水平，我觉得符合预期便没有再多要。其实最后人力申请的时候，是申请下来了28.5k。这让我意识到在谈薪的时候，其实是可以在对方开价的基础上多要一些的。我没有敢多要的原因是担心对方会因为觉得薪资差距太大而不发这个offer。在这点上，我做的非常差，有机会还是需要多加尝试。</p><p>谈薪后，花旗会开始走背调流程，一轮背调完成后便正式发放offer。需要提交的资料很多，漏了就会影响流程，我由于各种原因耽搁，整个流程走了一个月左右才收到offer。</p><p>花旗面试过程中最大的硬伤就是自己的<strong>英语水平不足</strong>，这一点在面试外企的时候还是比较被动的。会限制自己的发挥，让自己显得自信不足。</p><h2 id="茄子快传"><a href="#茄子快传" class="headerlink" title="茄子快传"></a>茄子快传</h2><p>面试茄子的时候，只是想着练手，并没有真的想要去入职。初面的时候，聊的内容基本都是我在Java训练营里学到的一些东西，详细的面试问题没有整理，可以去百度云上听下录音。面试问的问题质量还可以，初面也问的不深，基本上答到点上就可以了。后续的二面因为需要约上海现场面试，我年后一直没有安排去上海的现场，所以就没有后续了。</p><h2 id="神策数据"><a href="#神策数据" class="headerlink" title="神策数据"></a>神策数据</h2><h3 id="面试记录-1"><a href="#面试记录-1" class="headerlink" title="面试记录"></a>面试记录</h3><p><img src="/2021/04/17/关于第二次换工作的面试经验/神策.jpg" alt=""></p><h3 id="经验总结-1"><a href="#经验总结-1" class="headerlink" title="经验总结"></a>经验总结</h3><p>通过面试和查阅资料发现这个公司在大数据处理领域还是做得很好的，近几年发展的很快。我是偶然在一个群里得到了群友的内推，才面试的这家公司。刚好这个公司又在合肥，于是便想尝试一下，看看老家那边的薪资情况是什么样的。</p><p>整体来看，其实神策的面试自我感觉发挥并不是很好，但是面试风格我很喜欢。一面开始考察代码，需要手写死锁问题。二面考察算法和经典的url过程问题，但是回答的不好。算法给出了思路，但是写的过程中，ide崩溃导致代码没有写完。其实是道简单题，不用dp也可以做出来（面试官也提示了可以用暴力解法），只是我陷入了之前看题解的思维惯式，一味着想要写出dp解法，导致时间耗费的很久。后来的三面需要到现场面试，与合肥研发中心负责人面对面沟通，这一点我也挺喜欢。三面给我的感觉是神策在快速发展，进去之后肯定会有压力，有点华锐的感觉，但是与华锐的企业文化又是完全不同的。总之感觉上会比华锐好很多，公司加班也不会特别严重。</p><p>感觉是因为我面试的时候没有发挥很好，最后的职级定的我不是很满意，公司人力给我谈薪水的时候也是明确的表明，开出的薪资是上限，没有argue的空间。给出的薪资虽说是这个职级的上限，但并没有达到我的预期，最后还是决定拒了这个offer。不过，拿到神策offer的过程让我觉得对自己这段时间的付出有些欣慰，在一个群里看到有朋友说能拿到神策offer的水平差不多可以跟阿里差不多。其实神策的团队是百度出来的，能看出来确实比较注重技术，所以拿到offer也算是对我自己的认可。</p><p>这次面试所暴露出的主要问题是我<strong>对算法不够熟练</strong>，<strong>对技术的广度了解不够</strong>，像url的过程这种问题了解的较浅。</p><h2 id="万得"><a href="#万得" class="headerlink" title="万得"></a>万得</h2><h3 id="面试记录-2"><a href="#面试记录-2" class="headerlink" title="面试记录"></a>面试记录</h3><p><img src="/2021/04/17/关于第二次换工作的面试经验/万得.jpg" alt=""></p><h3 id="经验总结-2"><a href="#经验总结-2" class="headerlink" title="经验总结"></a>经验总结</h3><p>由于竟业限制，万得从一开始就是我想用来练手，找找感觉的。一面主要是业务背景，技术上聊得比较少。二面就完全是技术上的问题了。万得面试中一个非常加分的项是，二面考察实际代码能力，真正的编写实现了一个小需求。这样可以很好的考察出候选人的代码水平，还有整个思路，设计与实现。二面整个过程中与面试官聊得都非常好，面试官也表示的很欣赏。所以二面很快就过了，后续三面约的是高管的视频面。虽然他笑的和蔼但是可以感受的到有些虚伪，最后的表示面试肯定会给过，但薪资水平只能给到跟上家差不多的样子。最终人力让我等offer，等了一周多后，发现被挂了。很莫名其妙。联系人力说是大老板给挂了，他们也没办法。</p><p>后续在等offer的过程中，我也查看了很多关于万得的资料。整体上可以看出来，员工对公司的评价都是不太好，这点让我很不喜欢。负面太多，公司大概或多或少存在一些问题。</p><h2 id="招银"><a href="#招银" class="headerlink" title="招银"></a>招银</h2><h3 id="面试记录-3"><a href="#面试记录-3" class="headerlink" title="面试记录"></a>面试记录</h3><p>招银是找的朋友内推，事先打听了很多内部消息。确定是目标公司后，才开始投的简历。不过此时已经拿到花旗的口头offer，背调在流程中，所以担心会有幺蛾子，于是在给自己创造一些可选项。</p><p>社招笔试，具体的笔试题目已经不记得了。是在牛客上直接做的，前面的选择题还比较简单，后面有两道算法题，我没有AC。用例没有完全跑通过。值拿到了一半多的分数。</p><p>笔试后几天，收到了面试邀约。面试当天的效率很高，一天面完三轮，都是视频面。连续进行的。一面和二面表现的都不太好，java基础的一些问题都能回答的上来。但是涉及到一些数据库表的设计，与业务相关的设计时我答得很不好。二面的时候，我甚至没有完全理解面试官题目的意思。没想到最后也是过了。二面面试官问我了不了解DDD，然而对于这方面我丝毫没有涉足过。</p><p>即使整体上面的面试自我感觉很差，面试过了一周后，本以为已经没戏了。但是最后居然还是告诉我面试通过了。最后给的offer整体价格也不错。但是仔细对比后，也咨询了朋友的意见，最后还是决定去了花旗</p><h3 id="经验总结-3"><a href="#经验总结-3" class="headerlink" title="经验总结"></a>经验总结</h3><p>招银的面试整体上来说，我也算是尽力。但是有些地方的表现，自我还是不太满意。比如算法方面，没能够AC还是没达到我的期望。<strong>算法还需要多加练习。</strong></p><h2 id="菜鸟"><a href="#菜鸟" class="headerlink" title="菜鸟"></a>菜鸟</h2><h3 id="面试记录-4"><a href="#面试记录-4" class="headerlink" title="面试记录"></a>面试记录</h3><p><img src="/2021/04/17/关于第二次换工作的面试经验/菜鸟.jpg" alt=""></p><h3 id="经验总结-4"><a href="#经验总结-4" class="headerlink" title="经验总结"></a>经验总结</h3><p>面试菜鸟比较意外，我并没有投递简历。面试官说是可能从某个猎头那收到的。整场面试中，可以感觉的出来，面试官比较侧重于我对项目架构选型的认知。项目为什么要这么做技术选型？对比市面上其他技术的优缺点有哪些？而这些问题我确实准备的不足。风控引擎这方面我对市面上其他技术了解的不多，流式计算，脚本引擎这些技术选型的对比也都不了解。所以最后利索当然的没有通过。</p><p>这场面试其实对我来说是比较有价值的，在不长的面试过程中暴露出了我的一个比较严重的问题。<strong>对于自己做的项目技术架构要有思考，需要知道为什么这么做技术选型</strong>。如果以后要走技术方向的话，了解清楚这些是必须的。不然以后就只能混日子，没有自己的思考在职业生涯上很难走得远。同样在面试其他企业的时候，我认为一些资深一点的岗位也必然会问到这些问题，所以以后还是需要在这方面有所加强才行。</p><p>以后在技术细节上，可以不用了解清楚每一个框架，但是需要知道每个框架的大致工作原理以及优缺点。这样才好结合实际的业务场景做tradeoff，更有甚者还需要做技术验证来确定那种选型效果好。</p><h2 id="我问的问题"><a href="#我问的问题" class="headerlink" title="我问的问题"></a>我问的问题</h2><p>在面对不同轮次面试官的时候，需要问的问题肯定也有不同的侧重点。一般来说，一面的面试官级别更接近一线，所以可以问他关于岗位具体业务，技术架构，加班强度方面的问题。二面的面试官一般会在公司侧重的技术路线或者业务上问的比较深一点，职级一般也会更高一些。可以问他团队规模，期望什么样的人加入他的团队。针对人力面可以问他关于公司组织架构，职级构成，企业文化等方面的问题。如果是高管的面试，可以问他关于他对于公司业务未来发展方向的看法等。下面也列举了一些我记录的问题：</p><p><img src="/2021/04/17/关于第二次换工作的面试经验/问题.jpg" alt=""></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后，面试时一方面靠的是运气，另一方面靠的是硬实力。所以在找工作的时候，很多时候没拿到offer并不是实力问题，很有可能就是运气差了点。你看万得最后鸽了我的offer，总不能是因为我的实力不够。有可能就是他们刚好找到个性价比更高的人，也有可能是刚好收紧预算，hc不够了。实际原因我永远也不会知道，但是抱怨吐槽后，继续相信自己才是最重要的。我们能做的就只有靠提升自己的实力来尽量抓住机会。</p><p>罗翔老师说某一位哲学家说过，我们每个人都拿着并非自己所选择的剧本，登上并非自己所选择的舞台。而我们所能做的也就只有演好自己手中的剧本。我们需要认识到，人的局限性。人生中太多的事情并非我们所能掌控，我们自己能决定的可能只有5%都不到。</p><p>在找工作的时候也是一样，认识到自己的局限性，同时演好自己手中的剧本。认识到拿到offer需要靠很多运气，同时努力提升硬实力来抓住每一次机会。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面试记录与经验感受&quot;&gt;&lt;a href=&quot;#面试记录与经验感受&quot; class=&quot;headerlink&quot; title=&quot;面试记录与经验感受&quot;&gt;&lt;/a&gt;面试记录与经验感受&lt;/h1&gt;&lt;h2 id=&quot;花旗&quot;&gt;&lt;a href=&quot;#花旗&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2021/04/11/Notion%20OKR%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2021/04/11/Notion OKR手册/</id>
    <published>2021-04-11T04:09:22.245Z</published>
    <updated>2021-04-11T04:34:33.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Notion-OKR制作教程"><a href="#Notion-OKR制作教程" class="headerlink" title="Notion OKR制作教程"></a>Notion OKR制作教程</h1><h1 id="Notion-OKR的效果图"><a href="#Notion-OKR的效果图" class="headerlink" title="Notion OKR的效果图"></a>Notion OKR的效果图</h1><h1 id="创建主库"><a href="#创建主库" class="headerlink" title="创建主库"></a>创建主库</h1><h2 id="创建Quarters库"><a href="#创建Quarters库" class="headerlink" title="创建Quarters库"></a>创建Quarters库</h2><h2 id="创建Objectives库"><a href="#创建Objectives库" class="headerlink" title="创建Objectives库"></a>创建Objectives库</h2><h2 id="创建Key-Result库"><a href="#创建Key-Result库" class="headerlink" title="创建Key Result库"></a>创建Key Result库</h2><h1 id="创建OKRs"><a href="#创建OKRs" class="headerlink" title="创建OKRs"></a>创建OKRs</h1><h1 id="关联数据库"><a href="#关联数据库" class="headerlink" title="关联数据库"></a>关联数据库</h1><h2 id="将Quarters关联到Objectives上"><a href="#将Quarters关联到Objectives上" class="headerlink" title="将Quarters关联到Objectives上"></a>将Quarters关联到Objectives上</h2><h2 id="将Objectives关联到Key-Result上"><a href="#将Objectives关联到Key-Result上" class="headerlink" title="将Objectives关联到Key Result上"></a>将Objectives关联到Key Result上</h2><h1 id="初始化汇总"><a href="#初始化汇总" class="headerlink" title="初始化汇总"></a>初始化汇总</h1><h2 id="通过Objective来计算进程"><a href="#通过Objective来计算进程" class="headerlink" title="通过Objective来计算进程"></a>通过Objective来计算进程</h2><h2 id="通过Quater来计算进程"><a href="#通过Quater来计算进程" class="headerlink" title="通过Quater来计算进程"></a>通过Quater来计算进程</h2><h2 id="创建可视化进度条"><a href="#创建可视化进度条" class="headerlink" title="创建可视化进度条"></a>创建可视化进度条</h2><h2 id="汇总你激活的指标"><a href="#汇总你激活的指标" class="headerlink" title="汇总你激活的指标"></a>汇总你激活的指标</h2><h2 id="通过可选择的汇总日期排序"><a href="#通过可选择的汇总日期排序" class="headerlink" title="通过可选择的汇总日期排序"></a>通过可选择的汇总日期排序</h2><h1 id="为常用内置页设置模板"><a href="#为常用内置页设置模板" class="headerlink" title="为常用内置页设置模板"></a>为常用内置页设置模板</h1><h2 id="通过Quater来过滤Objective"><a href="#通过Quater来过滤Objective" class="headerlink" title="通过Quater来过滤Objective"></a>通过Quater来过滤Objective</h2><h2 id="通过Objectives来过滤Key-Results"><a href="#通过Objectives来过滤Key-Results" class="headerlink" title="通过Objectives来过滤Key Results"></a>通过Objectives来过滤Key Results</h2><h1 id="为OKR创建网关"><a href="#为OKR创建网关" class="headerlink" title="为OKR创建网关"></a>为OKR创建网关</h1><h1 id="撰写季度反馈"><a href="#撰写季度反馈" class="headerlink" title="撰写季度反馈"></a>撰写季度反馈</h1><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://www.notion.vip/achieve-your-goals-okrs-in-notion/" target="_blank" rel="noopener">翻译原文出处</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Notion-OKR制作教程&quot;&gt;&lt;a href=&quot;#Notion-OKR制作教程&quot; class=&quot;headerlink&quot; title=&quot;Notion OKR制作教程&quot;&gt;&lt;/a&gt;Notion OKR制作教程&lt;/h1&gt;&lt;h1 id=&quot;Notion-OKR的效果图&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常见算法模板</title>
    <link href="http://yoursite.com/2021/03/19/LeetCode/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    <id>http://yoursite.com/2021/03/19/LeetCode/算法模板/</id>
    <published>2021-03-19T14:28:39.000Z</published>
    <updated>2021-03-19T09:04:35.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见算法模板"><a href="#常见算法模板" class="headerlink" title="常见算法模板"></a>常见算法模板</h1><p>本文记录常用的算法模板</p><a id="more"></a><h2 id="⼆分法-Binary-Search"><a href="#⼆分法-Binary-Search" class="headerlink" title="⼆分法 Binary Search"></a>⼆分法 Binary Search</h2><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul><li><p>排序数组 (30-40%是⼆分) </p></li><li><p>当⾯试官要求你找⼀个⽐ O(n) 更⼩的时间复杂度算法的时候(99%) </p></li><li><p>找到数组中的⼀个分割位置，使得左半部分满⾜某个条件，右半部分不满⾜(100%) </p></li><li><p>找到⼀个最⼤/最⼩的值使得某个条件被满⾜(90%) </p></li></ul><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ol><li>时间复杂度：O(logn) </li><li>空间复杂度：O(1) </li></ol><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// corner case 处理</span></span><br><span class="line">       <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 要点1: start + 1 &lt; end</span></span><br><span class="line">       <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 要点2：start + (end - start) / 2</span></span><br><span class="line">           <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">           <span class="comment">// 要点3：=, &lt;, &gt; 分开讨论，mid 不 +1 也不 -1</span></span><br><span class="line">           <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">               <span class="keyword">return</span> mid;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">               start = mid;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               end = mid;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 要点4: 循环结束后，单独处理start和end</span></span><br><span class="line">       <span class="keyword">if</span> (nums[start] == target) &#123;</span><br><span class="line">           <span class="keyword">return</span> start;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (nums[end] == target) &#123;</span><br><span class="line">           <span class="keyword">return</span> end;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="双指针-Two-Pointer"><a href="#双指针-Two-Pointer" class="headerlink" title="双指针 Two Pointer"></a>双指针 Two Pointer</h2><h3 id="使用条件-1"><a href="#使用条件-1" class="headerlink" title="使用条件"></a>使用条件</h3><ul><li>通常会针对一个数组，或者字符串（回文字符串等）进行操作；</li><li>快排也会使用到；</li><li>利用快慢指针找中位数等；</li></ul><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ol><li>时间复杂度<ul><li>时间复杂度与最内层循环主体执行的次数有关</li><li>与有多少重循环有关</li></ul></li><li>空间复杂度 O(1)<ul><li>只需要分配两个指针的额外内存</li></ul></li></ol><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><ul><li><a href="https://www.lintcode.com/problem/two-sum-vii/description" target="_blank" rel="noopener">LintCode 1879. 两数之和VII(同向双指针)</a></li><li>LintCode1712.和相同的⼆元⼦数组(相向双指针)</li><li>LintCode627. 最⻓回⽂串 (背向双指针)</li><li>LintCode 64: 合并有序数组 </li></ul><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><h4 id="相向双指针-patition-in-quicksort"><a href="#相向双指针-patition-in-quicksort" class="headerlink" title="相向双指针(patition in quicksort)"></a>相向双指针(patition in quicksort)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">patition</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = start, right = end;</span><br><span class="line">        <span class="comment">// key point 1: pivot is the value, not the index</span></span><br><span class="line">        <span class="keyword">int</span> pivot = A[(start + end) / <span class="number">2</span>];</span><br><span class="line">        <span class="comment">// key point 2: every time you compare left &amp; right, it should be</span></span><br><span class="line">        <span class="comment">// left &lt;= right not left &lt; right</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; A[left] &lt; pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; A[right] &gt; pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = A[left];</span><br><span class="line">                A[left] = A[right];</span><br><span class="line">                A[right] = temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="背向双指针"><a href="#背向双指针" class="headerlink" title="背向双指针"></a>背向双指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">left = position;</span><br><span class="line">right = position +<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(left &gt;=<span class="number">0</span> &amp;&amp; right &lt; length)&#123;</span><br><span class="line">    <span class="keyword">if</span> (可以停下来了) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    left--;</span><br><span class="line">    right++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="同向双指针"><a href="#同向双指针" class="headerlink" title="同向双指针"></a>同向双指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="comment">// 不满⾜则循环到满⾜搭配为⽌</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n &amp;&amp; i 到 j之间不满⾜条件)&#123;</span><br><span class="line">        j += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i 到 j之间满⾜条件)&#123;</span><br><span class="line">    处理i，j这次搭配</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="合并双指针"><a href="#合并双指针" class="headerlink" title="合并双指针"></a>合并双指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ArrayList&lt;Integer&gt; <span class="title">merge</span><span class="params">(ArrayList&lt;Integer&gt; list1, ArrayList&lt;Integer&gt; list2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要 new ⼀个新的 list，⽽不是在 list1 或者 list2 上直接改动</span></span><br><span class="line">    ArrayList&lt;Integer&gt; newList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; list1.size() &amp;&amp; j &lt; list2.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1.get(i) &lt; list2.get(j)) &#123;</span><br><span class="line">            newList.add(list1.get(i));</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newList.add(list2.get(j));</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并上下的数到 newList ⾥</span></span><br><span class="line">    <span class="comment">// ⽆需⽤ if (i &lt; list1.size())，直接 while 即可</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; list1.size()) &#123;</span><br><span class="line">        newList.add(list1.get(i));</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; list2.size()) &#123;</span><br><span class="line">        newList.add(list2.get(j);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快排与合并排序"><a href="#快排与合并排序" class="headerlink" title="快排与合并排序"></a>快排与合并排序</h2><p>快排的平均时间复杂度是O(nlogn)，在最坏的情况下会达到O(n^2)的复杂度，用O(n)的时间降范围降了1个数。空间复杂度是O(1)。不稳定排序，相同元素会被交换位置。先整体有序，再局部有序。</p><p>归并排序时间复杂度则是一直都O(nlogn)的复杂度，空间复杂度是O(n)。稳定排序，相同元素不会被交换位置。先局部有序，再整体有序。</p><p>实际中，由于merge sort需要额外申请空间会耗费时间，而quick sort其实中心点选的好的话，很难构造出O(n^2)复杂度的数据，因此quick sort 会比 merge sort在实际应用中更受欢迎。</p><h2 id="幂次操作的取余写法和递归写法"><a href="#幂次操作的取余写法和递归写法" class="headerlink" title="幂次操作的取余写法和递归写法"></a>幂次操作的取余写法和递归写法</h2><p>做幂次操作时需要注意数据类型溢出的情况，因此传参时可转为long或double类型，如果题目涉及取余操作，则应在每次乘法运算后及时做取余操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//题目求的是a的n次方对b取余的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fastPower</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    ans = pow(a,n,b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) ans % b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归写法</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pow</span> <span class="params">(<span class="keyword">long</span> a, <span class="keyword">int</span> n,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            res = (res * a) % b;<span class="comment">//及时取余避免溢出</span></span><br><span class="line">        &#125;</span><br><span class="line">        a = (a * a) % b;<span class="comment">//a的数据类型改为long避免溢出</span></span><br><span class="line">        n /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归写法</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pow2</span> <span class="params">(<span class="keyword">long</span> a, <span class="keyword">int</span> n,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> halfpow = pow2(a, n/<span class="number">2</span>, b);</span><br><span class="line">    res = (halfpow * halfpow) % b;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        res = (res * a)%b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⼆叉树分治-Binary-Tree-Divide-amp-Conquer"><a href="#⼆叉树分治-Binary-Tree-Divide-amp-Conquer" class="headerlink" title="⼆叉树分治 Binary Tree Divide &amp; Conquer"></a>⼆叉树分治 Binary Tree Divide &amp; Conquer</h2><h3 id="使用条件-2"><a href="#使用条件-2" class="headerlink" title="使用条件"></a>使用条件</h3><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><h3 id="代码模板-2"><a href="#代码模板-2" class="headerlink" title="代码模板"></a>代码模板</h3><h2 id="⼆叉搜索树非递归-BST-Iterator"><a href="#⼆叉搜索树非递归-BST-Iterator" class="headerlink" title="⼆叉搜索树非递归 BST Iterator"></a>⼆叉搜索树非递归 BST Iterator</h2><h3 id="使用条件-3"><a href="#使用条件-3" class="headerlink" title="使用条件"></a>使用条件</h3><h3 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h3><h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><h3 id="代码模板-3"><a href="#代码模板-3" class="headerlink" title="代码模板"></a>代码模板</h3><h2 id="宽度优先搜索"><a href="#宽度优先搜索" class="headerlink" title="宽度优先搜索"></a>宽度优先搜索</h2><h3 id="使用条件-4"><a href="#使用条件-4" class="headerlink" title="使用条件"></a>使用条件</h3><h3 id="复杂度-4"><a href="#复杂度-4" class="headerlink" title="复杂度"></a>复杂度</h3><h3 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h3><h3 id="代码模板-4"><a href="#代码模板-4" class="headerlink" title="代码模板"></a>代码模板</h3><h2 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h2><h3 id="使用条件-5"><a href="#使用条件-5" class="headerlink" title="使用条件"></a>使用条件</h3><h3 id="复杂度-5"><a href="#复杂度-5" class="headerlink" title="复杂度"></a>复杂度</h3><h3 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h3><h3 id="代码模板-5"><a href="#代码模板-5" class="headerlink" title="代码模板"></a>代码模板</h3><h2 id="动态规划-Dynamic-Programming"><a href="#动态规划-Dynamic-Programming" class="headerlink" title="动态规划 Dynamic Programming"></a>动态规划 Dynamic Programming</h2><h3 id="使用条件-6"><a href="#使用条件-6" class="headerlink" title="使用条件"></a>使用条件</h3><h3 id="复杂度-6"><a href="#复杂度-6" class="headerlink" title="复杂度"></a>复杂度</h3><h3 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h3><h3 id="代码模板-6"><a href="#代码模板-6" class="headerlink" title="代码模板"></a>代码模板</h3><h2 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆 Heap"></a>堆 Heap</h2><h3 id="使用条件-7"><a href="#使用条件-7" class="headerlink" title="使用条件"></a>使用条件</h3><h3 id="复杂度-7"><a href="#复杂度-7" class="headerlink" title="复杂度"></a>复杂度</h3><h3 id="例题-7"><a href="#例题-7" class="headerlink" title="例题"></a>例题</h3><h3 id="代码模板-7"><a href="#代码模板-7" class="headerlink" title="代码模板"></a>代码模板</h3><h2 id="并查集-Union-Find"><a href="#并查集-Union-Find" class="headerlink" title="并查集 Union Find"></a>并查集 Union Find</h2><h3 id="使用条件-8"><a href="#使用条件-8" class="headerlink" title="使用条件"></a>使用条件</h3><h3 id="复杂度-8"><a href="#复杂度-8" class="headerlink" title="复杂度"></a>复杂度</h3><h3 id="例题-8"><a href="#例题-8" class="headerlink" title="例题"></a>例题</h3><h3 id="代码模板-8"><a href="#代码模板-8" class="headerlink" title="代码模板"></a>代码模板</h3><h2 id="字典树-Trie"><a href="#字典树-Trie" class="headerlink" title="字典树 Trie"></a>字典树 Trie</h2><h3 id="使用条件-9"><a href="#使用条件-9" class="headerlink" title="使用条件"></a>使用条件</h3><h3 id="复杂度-9"><a href="#复杂度-9" class="headerlink" title="复杂度"></a>复杂度</h3><h3 id="例题-9"><a href="#例题-9" class="headerlink" title="例题"></a>例题</h3><h3 id="代码模板-9"><a href="#代码模板-9" class="headerlink" title="代码模板"></a>代码模板</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常见算法模板&quot;&gt;&lt;a href=&quot;#常见算法模板&quot; class=&quot;headerlink&quot; title=&quot;常见算法模板&quot;&gt;&lt;/a&gt;常见算法模板&lt;/h1&gt;&lt;p&gt;本文记录常用的算法模板&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LEETCODE" scheme="http://yoursite.com/tags/LEETCODE/"/>
    
  </entry>
  
  <entry>
    <title>JDB debug操作</title>
    <link href="http://yoursite.com/2020/11/21/JDB%20debug/"/>
    <id>http://yoursite.com/2020/11/21/JDB debug/</id>
    <published>2020-11-21T12:02:12.000Z</published>
    <updated>2020-11-21T03:24:15.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDB-debug"><a href="#JDB-debug" class="headerlink" title="JDB debug"></a>JDB debug</h1><a id="more"></a><ul><li><p>使用如下命令启动进程，开启jvm的debug模式，端口可自定义，默认为5005</p><blockquote><p><code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</code></p></blockquote></li><li><p>使用如下命令，将jdb debugger附到已经运行的jvm上</p><blockquote><p> <code>jdb -attach 5005</code></p></blockquote></li><li><p>使用如下命令可设置断点</p><blockquote><ul><li><code>stop at com.gmy.MyClass:22</code> <em>(在MyClass的第22行设置断点)</em></li><li><code>stop in java.lang.String.length</code> <em>(在java.land.String.length()方法的起始处设置断点)</em></li><li><code>stop in com.gmy.MyClass.&lt;init&gt;</code> <em>(<init> 是 MyClass constructor)</init></em></li><li><code>stop in com.gmy.MyClass.&lt;clinit&gt;</code> <em>(<clinit>MyClass的静态代码块)</clinit></em></li></ul></blockquote><p>在设置一个断点时，需要显式指定类的包路径，需要用类的全名称来设定。</p></li><li><p>常见的调试命令如下：</p><blockquote><ul><li><p>next : 运行到下一步</p></li><li><p>cont : 往后运行到下一个断点</p></li><li><p>print ：</p><ul><li><p><code>print MyClass.myStaticField</code></p></li><li><p><code>print myObj.myInstanceField</code></p></li><li><code>print i + j + k</code> <em>(i, j, k are primities and either fields or local variables)</em></li><li><code>print myObj.myMethod()</code> <em>(if myMethod returns a non-null)</em></li><li><code>print new java.lang.String(&quot;Hello&quot;).length()</code></li></ul><p><strong>当print指定运行的java表达式未被jvm类加载时，它会报错无法运行。</strong></p><p>例如，当我试图在某个方法的入口执行将某个实例json格式化后print处理时，我使用了如下命令：</p><p><code>print com.alibaba.fastjson.JSON.toJSONString(myEntity)</code>。此时产生了个找不到该class的错误。当我将方法继续往下一断点执行，在执行过程中，代码有用到该JSON序列化的类，jvm将该类加载了。之后我再通过如上命令尝试打印出实例的json格式化字符串便成功了。</p></li><li><p>wherei : 此命令会打印出当前的堆栈信息，告诉你目前断点的位置是在哪</p></li><li><p>dump ：此命令会告诉你当前线程的dump信息</p></li></ul></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDB-debug&quot;&gt;&lt;a href=&quot;#JDB-debug&quot; class=&quot;headerlink&quot; title=&quot;JDB debug&quot;&gt;&lt;/a&gt;JDB debug&lt;/h1&gt;
    
    </summary>
    
      <category term="JDB" scheme="http://yoursite.com/categories/JDB/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode记录总结</title>
    <link href="http://yoursite.com/2020/04/21/LeetCode/LeetCode/"/>
    <id>http://yoursite.com/2020/04/21/LeetCode/LeetCode/</id>
    <published>2020-04-21T14:28:39.000Z</published>
    <updated>2020-12-09T07:56:31.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode记录总结"><a href="#LeetCode记录总结" class="headerlink" title="LeetCode记录总结"></a>LeetCode记录总结</h1><p>本文章主要记录LeetCode刷题学到的知识</p><a id="more"></a><h2 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242.Valid Anagram"></a>242.Valid Anagram</h2><p>题目：</p><blockquote><p>Given two strings s and t , write a function to determine if t is an anagram of s.</p></blockquote><p>我的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> ((s.isEmpty() &amp;&amp; !t.isEmpty())||s.length()!=t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] tchars = t.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] schars = s.toCharArray();</span><br><span class="line">       Arrays.sort(tchars);</span><br><span class="line">        Arrays.sort(schars);</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tchars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tchars[i] != schars[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路是想通过将字符串排序，然后逐一对比字符。看到官方有种解法是通过哈希映射，先准备一个26长度的int数组，将每个字符与<code>a</code>相减得出对应的ASCII码，将其作为数组的下标，s的字符对下标上的值++，t的字符对下标上的值–。最后，判断这个数组有没有不为0的，若不为0，则说明字符不一样。<strong>以后遇到字符串比较的问题，可以往数组映射上进行考虑</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        counter[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        counter[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : counter) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题的follow up是，如果字符串是unicode编码的，那么怎么实现。那样的话我的这种解法依然有效，但是使用定长数组的解法则不行，需要使用hashmap来代替数组。</p><p>Unicode相关：<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p><h2 id="LCCI-01-01-Is-Unique"><a href="#LCCI-01-01-Is-Unique" class="headerlink" title="LCCI.01.01 Is Unique"></a>LCCI.01.01 Is Unique</h2><p>题目：</p><blockquote><p>Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?</p></blockquote><p>我的思路是直接采用整形数组，将每个字符与<code>A</code>相减得出的数字作为数组下标，将数组的值+1，当发现某个字符对应的数组值大于1时，则说明该字符重复了，返回false。</p><p>题目说的是不采用其他数据结构，而我用了数组来解，其实也是一种数据结构。看了题解，发现可以用整形的bit位代替数组，将每个字符与<code>A</code>的差作为数字1的左移位数，这样每次和mark的值相与，若字符没重复着则会为0，不为0则说明重复了。在不重复的时候，用或运算来将mark的bit位置位。贴出我修改后的解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String astr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (astr.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chars = astr.toCharArray();</span><br><span class="line">        <span class="keyword">long</span> flag =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">            <span class="keyword">long</span> i = aChar - <span class="string">'A'</span>;</span><br><span class="line">            <span class="keyword">if</span> ((flag &amp; (<span class="number">1L</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                flag =flag|(<span class="number">1L</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-01-02-Check-Permutation"><a href="#LCCI-01-02-Check-Permutation" class="headerlink" title="LCCI.01.02 Check Permutation"></a>LCCI.01.02 Check Permutation</h2><p>题目：</p><blockquote><p>Given two strings,write a method to decide if one is a permutation of the other.</p></blockquote><p>此题类似与#242 valid anagram 那道题。可以采用相同的解法。但是看到题解里有采用异或的方式来解的，异或本身的原理是：<code>0^a=a;1^a=a取反</code>。因此当用0跟字符串每个字符异或后，得到的值是字符串每个字符相异或的。这样对两个字符串进行异或后再对两个值进行比较，若相等则说明是同个字符串，否则为不同字符串。</p><p>解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">CheckPermutation</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (s1 == <span class="keyword">null</span> || s2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> s1 == <span class="keyword">null</span> &amp;&amp; s2 == <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">char</span>[] s1Chars = s1.toCharArray();</span><br><span class="line">       <span class="keyword">char</span>[] s2Chars = s2.toCharArray();</span><br><span class="line">       <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">char</span> s1Char : s1Chars) &#123;</span><br><span class="line">           a = a ^ s1Char;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">char</span> s2Char : s2Chars) &#123;</span><br><span class="line">           b = b ^ s2Char;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> a == b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-01-03-String-toURL"><a href="#LCCI-01-03-String-toURL" class="headerlink" title="LCCI.01.03 String toURL"></a>LCCI.01.03 String toURL</h2><p>题目：</p><blockquote><p>Write a method to replace all spaces in a string with ‘%20’. You may assume that the string has sufficient space at the end to hold the additional characters,and that you are given the “true” length of the string. (Note: If implementing in Java,please use a character array so that you can perform this operation in place.)</p></blockquote><p>刚开始理解错了题目的意思，以为要将字符串中的空格全部替换为<code>%20</code>，后来测试才发现，需要转换的字符串其实是给定的长度，所以只需要遍历字符串，将给定长度内的空格字符替换为<code>%20</code>即可。</p><p>解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpaces</span><span class="params">(String S, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">char</span>[] charArray = S.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = charArray[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</span><br><span class="line">                res.append(<span class="string">"%20"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-01-04-Palindrome-Permutation"><a href="#LCCI-01-04-Palindrome-Permutation" class="headerlink" title="LCCI.01.04 Palindrome Permutation"></a>LCCI.01.04 Palindrome Permutation</h2><p>题目：</p><blockquote><p>Given a string, write a function to check if it is a permutation of a palin­ drome. A palindrome is a word or phrase that is the same forwards and backwards. A permutation is a rearrangement of letters. The palindrome does not need to be limited to just dictionary words.</p></blockquote><p>可以把题目中的回文字符串理解为一个字符串中字母出现次数为奇数的不超过1个。理解了这个之后，就可以使用哈希映射的方式来解决这个问题了，先将每个字母对应的数字放到数组中，然后将数组的值奇数，作为出现此处。最后判断次数是否为奇数即可。此处判断是否为奇数可以使用<code>(a&amp;1)==1</code>来判断，若位与后结果为1，则说明是奇数。</p><p>关于位运算总结可以参考这篇博客：<a href="http://blog.tomtung.com/2007/05/bitwise-operation/" target="_blank" rel="noopener">位运算总结</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPermutePalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>|| s.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    HashMap&lt;Character, Integer&gt; letters = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">        letters.merge(aChar, <span class="number">1</span>, (a, b) -&gt; a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> letter : letters.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((letter&amp;<span class="number">1</span>)==<span class="number">1</span>)&amp;&amp; (++flag)&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-01-05-One-Away"><a href="#LCCI-01-05-One-Away" class="headerlink" title="LCCI.01.05 One Away"></a>LCCI.01.05 One Away</h2><p>题目：</p><blockquote><p>There are three types of edits that can be performed on strings: insert a character, remove a character, or replace a character. Given two strings, write a function to check if they are one edit (or zero edits) away.</p></blockquote><p>此题并不是单词的判断字符串少了几个字符的问题，而是两个字符串除了不一样的那个字符外，其他字符的顺序也需要一直。没有想到更好的办法，于是我采用的是双指针暴力法。双指针类的题目需要分清不同情况下两个指针的处理，在这题中，两个字符串长度相差大于1肯定返回false，其他的分为长度相同和长度相差为1来分别处理。长度相同时，最多有一个字符可以不一样。长度相差为1时，短字符串的顺序必须与长字符串一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">oneEditAway</span><span class="params">(String first, String second)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (first == <span class="keyword">null</span> || second == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     String longer = first.length() &gt;= second.length() ? first : second;</span><br><span class="line">     String shorter = first.length() &lt; second.length() ? first : second;</span><br><span class="line">     <span class="keyword">if</span> (longer.length() - shorter.length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (longer.isEmpty() || shorter.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">return</span> longer.length() - shorter.length() &lt;= <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> (longer.length() == shorter.length()) &#123;</span><br><span class="line">                 </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; longer.length(); k++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (longer.charAt(k) != shorter.charAt(k)) &#123;</span><br><span class="line">                 flag++;</span><br><span class="line">                 <span class="keyword">if</span> (flag &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (; j &lt; shorter.length(); ) &#123;</span><br><span class="line">             <span class="keyword">if</span> (longer.charAt(i) != shorter.charAt(j)) &#123;</span><br><span class="line">                 i++;</span><br><span class="line">                 flag++;</span><br><span class="line">                 <span class="keyword">if</span> (flag &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             i++;</span><br><span class="line">             j++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-01-06-Compress-String"><a href="#LCCI-01-06-Compress-String" class="headerlink" title="LCCI.01.06 Compress String"></a>LCCI.01.06 Compress String</h2><p>题目：</p><blockquote><p>Implement a method to perform basic string compression using the counts of repeated characters. For example, the string aabcccccaaa would become a2blc5a3. If the “compressed” string would not become smaller than the original string, your method should return the original string. You can assume the string has only uppercase and lowercase letters (a - z).</p></blockquote><p>这题我采用普通的遍历法做出来了，需要注意的是不能使用哈希映射的方法。因为相同字母在不连续位置出现是不能统计到一起去的。看题解中，有同学<strong>在字符的最后补了一位来规避遍历时处理最后一个字符的特殊情况</strong>，这种思路值得学习。还有的同学采用了双指针的思路，一个指针遍历字符，另个指针统计相同的字符个数。</p><p>我的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.isEmpty()||S.length()&lt;<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chars = S.toCharArray();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> repeat = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == chars[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                repeat++;</span><br><span class="line">                <span class="keyword">if</span> (i == chars.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    sb.append(chars[i]).append(repeat);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(chars[i - <span class="number">1</span>]).append(repeat);</span><br><span class="line">                repeat = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == chars.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    sb.append(chars[i]).append(repeat);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S.length() &lt;= sb.length() ? S : sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-01-07-Rotate-Matrix"><a href="#LCCI-01-07-Rotate-Matrix" class="headerlink" title="LCCI.01.07 Rotate Matrix"></a>LCCI.01.07 Rotate Matrix</h2><p>题目：</p><blockquote><p>Given an image represented by an N x N matrix, where each pixel in the image is 4 bytes, write a method to rotate the image by 90 degrees. Can you do this in place?</p></blockquote><p>一开始我的解题思路是通过新建一个二维数组，然后，将矩阵进行转换，按照<code>a=j,b=N-i-j</code>的逻辑转换，最后再将转换后的数组复制到原数组中。这样会导致空间复杂度为O(N)。看了书本上的解法是原地旋转，由外层向内层每一层都是将上边移到右边，右边移到下边，下边移到左边，左边移到上边。通过这种方式完成整个矩阵的旋转。这种方式的实现逻辑交易较为清晰，时间复杂度为O(N2)。修改我的解法后，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = matrix.length;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> layer = <span class="number">0</span>; layer &lt; N / <span class="number">2</span>; layer++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = layer; j &lt; N - layer - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> top = matrix[layer][j];</span><br><span class="line">            matrix[layer][j] = matrix[N - j - <span class="number">1</span>][layer];<span class="comment">//left-&gt;top</span></span><br><span class="line">            matrix[N - j - <span class="number">1</span>][layer] = matrix[N - layer - <span class="number">1</span>][N - j - <span class="number">1</span>];<span class="comment">//bottom-&gt;left</span></span><br><span class="line">            matrix[N - layer - <span class="number">1</span>][N - j - <span class="number">1</span>] = matrix[j][N - layer - <span class="number">1</span>];<span class="comment">//right-&gt;bottom</span></span><br><span class="line">            matrix[j][N - layer - <span class="number">1</span>] = top;<span class="comment">//top-&gt;right</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>矩阵旋转时，可以将矩阵的数组下标写出来，然后找出每一步转换的<code>i，j</code>的规律。一般无非就是<code>x=j,y=length-i-1</code>这种情况。</p><h2 id="LCCI-01-08-Zero-Matrix"><a href="#LCCI-01-08-Zero-Matrix" class="headerlink" title="LCCI.01.08 Zero Matrix"></a>LCCI.01.08 Zero Matrix</h2><p>题目：</p><blockquote><p>Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column are set to 0.</p></blockquote><p>我的思路是将矩阵中应该被清0的行和列分别用数组记录下来。然后再拿行数组和列数组处理矩阵中对应的行和列。但是这样占用的空间复杂度为O(N)。参考书本上给出的优化方案是，将矩阵的第一行和第一列作为行数组和列数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">       <span class="keyword">int</span> cloumns = matrix[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span>[] rowsToZero = <span class="keyword">new</span> <span class="keyword">int</span>[rows];</span><br><span class="line">       <span class="keyword">int</span>[] cloums = <span class="keyword">new</span> <span class="keyword">int</span>[cloumns];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                   rowsToZero[i]=<span class="number">1</span>;</span><br><span class="line">                   cloums[j]=<span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowsToZero.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (rowsToZero[i] == <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="comment">//set i row to 0</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">                   matrix[i][j]=<span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cloums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (cloums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix.length; j++) &#123;</span><br><span class="line">                   matrix[j][i]=<span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-01-09-String-Rotation"><a href="#LCCI-01-09-String-Rotation" class="headerlink" title="LCCI.01.09 String Rotation"></a>LCCI.01.09 String Rotation</h2><p>题目：</p><blockquote><p>Given two strings, s1 and s2, write code to check if s2 is a rotation of s1 (e.g.,”waterbottle” is a rotation of”erbottlewat”). Can you use only one call to the method that checks if one word is a substring of another?</p></blockquote><p>这一题我给它想的复杂了，第一反应是通过双指针来做，结果没有做出来。考虑的情况漏了。看了书本才想起用包含子串的方法应该是最简单的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlipedString</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.isEmpty() || s2.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.isEmpty() &amp;&amp; s2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() != s2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       String s1s1 = s1+s1;</span><br><span class="line">    <span class="keyword">return</span> s1s1.contains(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-02-01-Remove-Duplicate-Node"><a href="#LCCI-02-01-Remove-Duplicate-Node" class="headerlink" title="LCCI.02.01 Remove Duplicate Node"></a>LCCI.02.01 Remove Duplicate Node</h2><p>题目：</p><blockquote><p>Write code to remove duplicates from an unsorted linked list.</p></blockquote><p>此题的follow up是想让不用额外的空间来实现，于是我直接采用双指针法。一个指针指向尾部，另个之前在前面做判重。这样会增加时间复杂度，为O(N2)；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeDuplicateNodes</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode tail = head;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    <span class="keyword">while</span> (tail.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = tail.next;</span><br><span class="line">        <span class="keyword">boolean</span> nextIsDup = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 != tail.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.val == next.val) &#123;</span><br><span class="line">                nextIsDup = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1= head;</span><br><span class="line">        <span class="keyword">if</span> (nextIsDup) &#123;</span><br><span class="line">            <span class="comment">//delete current node</span></span><br><span class="line">            tail.next= next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            tail = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-02-02-Kth-Node-From-End-of-List"><a href="#LCCI-02-02-Kth-Node-From-End-of-List" class="headerlink" title="LCCI.02.02 Kth Node From End of List"></a>LCCI.02.02 Kth Node From End of List</h2><p>题目：</p><blockquote><p>Implement an algorithm to find the kth to last element of a singly linked list. Return the value of the element.</p></blockquote><p>这题的第一想法觉得很简单，用遍历就可以实现。看了follow up 说可以用递归和双指针。递归没有什么想法，于是便实现了一个双指针版本的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode b = head;</span><br><span class="line">    ListNode a = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">        b=b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (b.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        b=b.next;</span><br><span class="line">        a=a.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贴上题解里的递归解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开始全局变量 K 保持不变</span></span><br><span class="line">    <span class="keyword">int</span> K = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当节点在最末尾时触发返回</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head.val;</span><br><span class="line">        <span class="comment">// 返回的值</span></span><br><span class="line">        <span class="keyword">int</span> val = kthToLast(head.next, k);</span><br><span class="line">        <span class="comment">// 一旦触发返回，从第一个产生返回的位置用 K 计数</span></span><br><span class="line">        <span class="keyword">if</span> (K++ &gt;= k) &#123;</span><br><span class="line">            <span class="comment">// 当到达或超过倒数第 k 时，即 K &gt;= k 时保持返回值不变</span></span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没到达则更新需要返回的值</span></span><br><span class="line">            <span class="keyword">return</span> head.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-02-03-Delete-Middle-Node"><a href="#LCCI-02-03-Delete-Middle-Node" class="headerlink" title="LCCI.02.03 Delete Middle Node"></a>LCCI.02.03 Delete Middle Node</h2><p>题目：</p><blockquote><p>Implement an algorithm to delete a node in the middle (i.e., any node but the first and last node, not necessarily the exact middle) of a singly linked list, given only access to that node.</p></blockquote><p>这题我并没有想到解法，其实链表的操作不应该被固定思维给限制住。这题可以通过将当前节点替换为下一节点，并将下一节点删除的方式来实现。代码也非常简单。主要考察的是这种思维。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    node.val=node.next.val;</span><br><span class="line">    node.next=node.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-02-04-Partition-List"><a href="#LCCI-02-04-Partition-List" class="headerlink" title="LCCI.02.04 Partition List"></a>LCCI.02.04 Partition List</h2><p>题目：</p><blockquote><p>Write code to partition a linked list around a value x, such that all nodes less than x come before all nodes greater than or equal to x. If x is contained within the list, the values of x only need to be after the elements less than x (see below). The partition element x can appear anywhere in the “right partition”; it does not need to appear between the left and right partitions.</p></blockquote><p>这一题我的思路是通过使用双指针来做，一个指针做遍历，另个指针指向小于x的数据的next。若遍历遇到小于x的值，则将其与小于x的next交换即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    ListNode p2 = head;</span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p2.val &lt; x) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = p1.val;</span><br><span class="line">            p1.val = p2.val;</span><br><span class="line">            p2.val = temp;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处需要注意的是，当我尝试使用如下异或来做交换操作时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1.val = p1.val^p2.val;</span><br><span class="line">p2.val = p1.val^p2.val;</span><br><span class="line">p1.val = p1.val^p2.val;</span><br></pre></td></tr></table></figure><p>发现在刚开始头指针指向同个对象时，对<code>p1.val</code>和<code>p2.val</code>做异或操作得出的值为0，再将0复制给<code>p1.val</code>，这样使得<code>p2.val</code>同时变为了0，因为<code>p1.val</code>和<code>p2.val</code>指向的是相同的值。</p><h2 id="LCCI-02-05-Sum-Lists"><a href="#LCCI-02-05-Sum-Lists" class="headerlink" title="LCCI.02.05 Sum Lists"></a>LCCI.02.05 Sum Lists</h2><p>题目：</p><blockquote><p>You have two numbers represented by a linked list, where each node contains a single digit. The digits are stored in reverse order, such that the 1’s digit is at the head of the list. Write a function that adds the two numbers and returns the sum as a linked list.</p></blockquote><p>这题一开始我的思路是将链表给合并成整数，再相加，然后再拆成链表。后来看了提示里说尝试用递归，才想到可以用递归来解决这个问题。刚开始的时候，递归写出来了，但是有几个用例总是执行不过，原因是我用的整型变量结果相加之后溢出了，改为了long之后发现还是会溢出。然后想到了不应该用中累加再拆成链表的方式。应该每一个节点算出对应的结果里的节点。递归时直接将节点拼接在一起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum(l1,l2,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode <span class="title">sum</span><span class="params">(ListNode s1, ListNode s2, <span class="keyword">int</span> buy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> currentLevelSum = s1.val + s2.val + buy;</span><br><span class="line">    ListNode currentNode = <span class="keyword">new</span> ListNode(currentLevelSum % <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (s1.next == <span class="keyword">null</span> &amp;&amp; s2.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentLevelSum / <span class="number">10</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            currentLevelSum = currentLevelSum/<span class="number">10</span>;</span><br><span class="line">            currentNode.next = <span class="keyword">new</span> ListNode(currentLevelSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line">    s1 = s1.next != <span class="keyword">null</span> ? s1.next : <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    s2 = s2.next != <span class="keyword">null</span> ? s2.next : <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    currentNode.next = sum(s1, s2, currentLevelSum / <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看题解中也有没有用递归的，不过也是类似的思想，不能将链表所有的数据都加起来再拆成链表， 那样会导致数据溢出。对于递归的题目我还是不太熟悉，做出来有点难度。</p><h2 id="LCCI-02-06-Palindrome-Linked-List"><a href="#LCCI-02-06-Palindrome-Linked-List" class="headerlink" title="LCCI.02.06  Palindrome Linked List"></a>LCCI.02.06  Palindrome Linked List</h2><p>题目：</p><blockquote><p>Implement a function to check if a linked list is a palindrome.</p></blockquote><p>这题我的思路是采用双指针或者反转整个链表再对比的方式。双指针我没有想到采用快慢指针这种方式，所以用了反转链表，但是没能实现follow up中的O(n)时间和O(1)空间的复杂度。贴上我的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     ListNode p1 = head;</span><br><span class="line">     ListNode a = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">while</span> (p1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ListNode b = <span class="keyword">new</span> ListNode(p1.val);</span><br><span class="line">         p1 = p1.next;</span><br><span class="line">         b.next = a;</span><br><span class="line">         a = b;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (a.val != head.val) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         head = head.next;</span><br><span class="line">         a = a.next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-02-07-Intersection-of-Two-Linked-Lists"><a href="#LCCI-02-07-Intersection-of-Two-Linked-Lists" class="headerlink" title="LCCI.02.07 Intersection of Two Linked Lists"></a>LCCI.02.07 Intersection of Two Linked Lists</h2><p>题目:</p><blockquote><p>Given two (singly) linked lists, determine if the two lists intersect. Return the inter­ secting node. Note that the intersection is defined based on reference, not value. That is, if the kth node of the first linked list is the exact same node (by reference) as the jth node of the second linked list, then they are intersecting.</p></blockquote><p>这题我刚开始没什么好的思路，只有个暴力的算法思想，找不到能在O(n)时间和O(1)空间内解决的办法。看到了提示才想起来先将长度对齐再用双指针同时往后遍历找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p1 = headA;</span><br><span class="line">    ListNode p2 = headB;</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        len1++;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        len2++;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode fast = len1 &gt; len2 ? headA : headB;</span><br><span class="line">    ListNode lag = len1 &gt; len2 ? headB : headA;</span><br><span class="line">    <span class="keyword">int</span> dis = len1 &gt; len2 ? len1 - len2 : len2 - len1;</span><br><span class="line">    <span class="keyword">while</span> (dis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">        dis--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast != lag) &#123;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">        lag=lag.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-02-08-Linked-List-Cycle"><a href="#LCCI-02-08-Linked-List-Cycle" class="headerlink" title="LCCI.02.08 Linked List Cycle"></a>LCCI.02.08 Linked List Cycle</h2><p>题目：</p><blockquote><p>Given a circular linked list, implement an algorithm that returns the node at the beginning of the loop.</p><p>Circular linked list: A (corrupt) linked list in which a node’s next pointer points to an earlier node, so as to make a loop in the linked list.</p></blockquote><p>这题我一开始没什么好的思路，后来只好用额外的空间将这题解出来了。使用set存储已经遍历过的节点，然后不停的往后将next 节点添加进set中，当发现添加失败时，即为循环的开始点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!set.add(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我看题解和书本上有种解法用的是快慢指针，先用快慢指针判断是否会碰撞，若不会碰撞则不会有循环。再判断快慢指针碰撞的位置。当慢指针到达loop点时，快指针为距离loop点的loopsize-k的位置，k为head距离loop点的距离。因此，当碰撞后，碰撞点距离loop点的距离为k。此时只需将慢指针指向head，快指针从碰撞点开始，二者以不断的next，当再次相等时，即为loop点。</p><h2 id="LCCI-03-01-Three-in-One"><a href="#LCCI-03-01-Three-in-One" class="headerlink" title="LCCI.03.01 Three in One"></a>LCCI.03.01 Three in One</h2><p>题目：</p><blockquote><p>Describe how you could use a single array to implement three stacks.</p><p>Yout should implement push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum) methods. stackNum is the index of the stack. value is the value that pushed to the stack.</p><p>The constructor requires a stackSize parameter, which represents the size of each stack.</p></blockquote><p>该题我一开始理解错了题意，并没有找出很好的解决办法。第一反应是将数组拆分为三份。但是我没有理解到构造器传进来的会是每个栈的长度。看了提示里有说使用环形数组来动态构建栈。这个我没有实现出来，感觉难度有点高，劝退了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TripleInOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] stackArray;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> eachStackSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] points = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TripleInOne</span><span class="params">(<span class="keyword">int</span> stackSize)</span> </span>&#123;</span><br><span class="line">            stackArray = <span class="keyword">new</span> <span class="keyword">int</span>[stackSize*<span class="number">3</span>];</span><br><span class="line">            eachStackSize = stackSize ;</span><br><span class="line">            points[<span class="number">0</span>] = eachStackSize;</span><br><span class="line">            points[<span class="number">1</span>] = eachStackSize * <span class="number">2</span>;</span><br><span class="line">            points[<span class="number">2</span>] = eachStackSize * <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isfull</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (points[stackNum] == eachStackSize * stackNum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> stackNum, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isfull(stackNum)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            points[stackNum] = points[stackNum] - <span class="number">1</span>;</span><br><span class="line">            stackArray[points[stackNum]] = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(stackNum)) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            points[stackNum] = points[stackNum] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> stackArray[points[stackNum] - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(stackNum)) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stackArray[points[stackNum]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (points[stackNum] == eachStackSize * (stackNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-03-02-Min-Stack"><a href="#LCCI-03-02-Min-Stack" class="headerlink" title="LCCI.03.02 Min Stack"></a>LCCI.03.02 Min Stack</h2><p>题目：</p><blockquote><p>How would you design a stack which, in addition to push and pop, has a function min which returns the minimum element? Push, pop and min should all operate in 0(1) time.</p></blockquote><p>这题我的思路是通过数组实现一个堆栈，要求在O(1)时间内返回pop和min，那么就只有用一个指针来记录栈顶和栈中最小值得位置。这么实现的后果是导致这个指针的维护比较复杂，从而在提交的时候报了好几次错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> topPoint = array.length;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> minPoint = array.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * initialize your data structure here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (topPoint == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length * <span class="number">2</span>];</span><br><span class="line">                System.arraycopy(array, <span class="number">0</span>, temp, temp.length - array.length, array.length);</span><br><span class="line">                topPoint = temp.length - array.length;</span><br><span class="line">                minPoint = minPoint + temp.length - array.length;</span><br><span class="line">                array = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            topPoint = topPoint - <span class="number">1</span>;</span><br><span class="line">            array[topPoint] = x;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; array[minPoint]) &#123;</span><br><span class="line">                minPoint = topPoint;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (minPoint == topPoint &amp;&amp; minPoint &lt; array.length - <span class="number">1</span>) &#123;</span><br><span class="line">                minPoint = minPoint + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = minPoint ; i &lt; array.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (array[i] &lt; array[minPoint]) &#123;</span><br><span class="line">                        minPoint=i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            topPoint = topPoint + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> array[topPoint];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> array[minPoint];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我看书本上这题用的是java本身的Stack类来实现的。再用额外的栈来保存最小值。这样实现起来会简单很多。</p><h2 id="LCCI-03-03-Stack-of-Plates"><a href="#LCCI-03-03-Stack-of-Plates" class="headerlink" title="LCCI.03.03 Stack of Plates"></a>LCCI.03.03 Stack of Plates</h2><p>题目：</p><blockquote><p>Imagine a (literal) stack of plates. If the stack gets too high, it might topple. Therefore, in real life, we would likely start a new stack when the previous stack exceeds some threshold. Implement a data structure SetOfStacks that mimics this. SetOfStacks should be composed of several stacks and should create a new stack once the previous one exceeds capacity. SetOfStacks.push() and SetOfStacks.pop() should behave identically to a single stack (that is, pop() should return the same values as it would if there were just a single stack). Follow Up: Implement a function popAt(int index) which performs a pop operation on a specific sub-stack.</p><p>You should delete the sub-stack when it becomes empty. pop, popAt should return -1 when there’s no element to pop.</p></blockquote><p>这题的思想比较简单，但是代码实现较为复杂。我写了很久没能够通过所有的测试用例。最后参考题解里的答案才写了出来。基本思路跟我的是类似的，但是我在代码实现的时候没能够处理好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackOfPlates</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line">        <span class="keyword">private</span> List&lt;Stack&gt; stack = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StackOfPlates</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">            stack.add(<span class="keyword">new</span> Stack&lt;&gt;());</span><br><span class="line">            <span class="keyword">this</span>.cap = cap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (cap &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()||stack.get(stack.size()-<span class="number">1</span>).size() == cap) &#123;</span><br><span class="line">                stack.add(<span class="keyword">new</span> Stack&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            stack.get(stack.size()-<span class="number">1</span>).push(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> popAt(stack.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">popAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (index&lt;<span class="number">0</span> || index &gt;= stack.size()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Stack&lt;Integer&gt; indexStack = stack.get(index);</span><br><span class="line">            <span class="keyword">if</span> (indexStack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> val = indexStack.pop();</span><br><span class="line">            <span class="keyword">if</span> (indexStack.isEmpty()) &#123;</span><br><span class="line">                stack.remove(indexStack);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-03-04-Implement-Queue-using-Stacks"><a href="#LCCI-03-04-Implement-Queue-using-Stacks" class="headerlink" title="LCCI.03.04 Implement Queue using Stacks"></a>LCCI.03.04 Implement Queue using Stacks</h2><p>题目：</p><blockquote><p>Implement a MyQueue class which implements a queue using two stacks.</p></blockquote><p>这题的关键在于队列是先入先出的顺序，而堆栈是后入先出的顺序。因此使用两个堆栈，一个堆栈用于队列的pop和peek，另个队列用于队列的push。这样在需要出队时，只需要将用于push的堆栈出栈再入栈到另个堆栈中。最后使用另个堆栈完成pop和peek即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> Stack&lt;Integer&gt; oldStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">private</span> Stack&lt;Integer&gt; newStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Initialize your data structure here.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Push element x to the back of queue.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">           newStack.push(x);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (oldStack.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">while</span> (!newStack.isEmpty()) &#123;</span><br><span class="line">                   oldStack.push(newStack.pop());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> oldStack.pop();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Get the front element.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (oldStack.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">while</span> (!newStack.isEmpty()) &#123;</span><br><span class="line">                   oldStack.push(newStack.pop());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> oldStack.peek();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Returns whether the queue is empty.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> oldStack.isEmpty() &amp;&amp; newStack.isEmpty();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-03-05-Sort-of-Stacks"><a href="#LCCI-03-05-Sort-of-Stacks" class="headerlink" title="LCCI.03.05 Sort of Stacks"></a>LCCI.03.05 Sort of Stacks</h2><p>题目：</p><blockquote><p>Write a program to sort a stack such that the smallest items are on the top. You can use an additional temporary stack, but you may not copy the elements into any other data structure (such as an array). The stack supports the following operations: push, pop, peek, and isEmpty. When the stack is empty, peek should return -1.</p></blockquote><p>这题跟上面题目类似，采用额外的一个堆栈来存储一部分数据。因为排序的堆栈栈顶是最小的，因此可以用另外个堆栈存小于push的值得数据。然后再把小于的那部分值pop出来，加入到排序堆栈中。一开始我在每次push完后都会将小于当前push值得数据都放回到排序堆栈中，后来看了题解，可以采用懒加载的方式。只在需要pop和peek的时候才做这些工作。这样使得我的运行时间得到了很大的优化，从205ms降到了27ms。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedStack</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Stack&lt;Integer&gt; sortedStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> Stack&lt;Integer&gt; tempStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SortedStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (sortedStack.isEmpty() &amp;&amp; tempStack.isEmpty()) &#123;</span><br><span class="line">                sortedStack.push(val);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (sortedStack.peek() &lt; val) &#123;</span><br><span class="line">                tempStack.push(sortedStack.pop());</span><br><span class="line">                <span class="keyword">if</span> (sortedStack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!sortedStack.isEmpty() &amp;&amp; !tempStack.isEmpty() &amp;&amp; sortedStack.peek() &gt; val &amp;&amp;</span><br><span class="line">                    tempStack.peek() &gt; val) &#123;</span><br><span class="line">                sortedStack.push(tempStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            sortedStack.push(val);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!tempStack.isEmpty()) &#123;</span><br><span class="line">                sortedStack.push(tempStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sortedStack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sortedStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!tempStack.isEmpty()) &#123;</span><br><span class="line">                sortedStack.push(tempStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sortedStack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sortedStack.peek();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sortedStack.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-03-06-Animal-Shelter"><a href="#LCCI-03-06-Animal-Shelter" class="headerlink" title="LCCI.03.06 Animal Shelter"></a>LCCI.03.06 Animal Shelter</h2><p>题目：</p><blockquote><p>An animal shelter, which holds only dogs and cats, operates on a strictly”first in, first out” basis. People must adopt either the”oldest” (based on arrival time) of all animals at the shelter, or they can select whether they would prefer a dog or a cat (and will receive the oldest animal of that type). They cannot select which specific animal they would like. Create the data structures to maintain this system and implement operations such as enqueue, dequeueAny, dequeueDog, and dequeueCat. You may use the built-in Linked list data structure.</p><p>enqueue method has a animal parameter, animal[0] represents the number of the animal, animal[1] represents the type of the animal, 0 for cat and 1 for dog.</p><p>dequeue* method returns [animal number, animal type], if there’s no animal that can be adopted, return [-1, -1].</p></blockquote><p>这题比较简单，思路就是使用LinkedList来将保存数组。然后在取出的时候，遍历链表判断是猫是狗，再将取出的节点删除即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalShelf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> LinkedList&lt;<span class="keyword">int</span>[]&gt; shelter = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] negative = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AnimalShelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span>[] animal)</span> </span>&#123;</span><br><span class="line">            shelter.add(animal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] dequeueAny() &#123;</span><br><span class="line">            <span class="keyword">if</span> (shelter.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> negative;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> shelter.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] dequeueDog() &#123;</span><br><span class="line">            <span class="keyword">if</span> (shelter.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> negative;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shelter.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shelter.get(i)[<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> shelter.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> negative;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] dequeueCat() &#123;</span><br><span class="line">            <span class="keyword">if</span> (shelter.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> negative;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shelter.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shelter.get(i)[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> shelter.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> negative;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个需要注意的点就是，LinkedList是可以用来保存数组的，而且不需要是包装类型<code>Integer</code>，直接是原始类型数组即可<code>int[]</code>。</p><h2 id="LCCI-04-01-Route-Between-Nodes"><a href="#LCCI-04-01-Route-Between-Nodes" class="headerlink" title="LCCI.04.01 Route Between Nodes"></a>LCCI.04.01 Route Between Nodes</h2><p>题目：</p><blockquote><p>Given a directed graph, design an algorithm to find out whether there is a route between two nodes.</p></blockquote><p>这题是典型的图的搜索应用场景，可以使用BFS和DFS。使用BFS可以尽快的搜索到需要的目标，因此这题我采用的是BFS。BFS有着典型的实现方式模板，这题我就是套用了模板。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findWhetherExistsPath</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] graph, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; breathList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        HashMap&lt;Integer, Set&lt;Integer&gt;&gt; temp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : graph) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = ints[<span class="number">0</span>];</span><br><span class="line">            Set&lt;Integer&gt; valueList = temp.computeIfAbsent(key,r-&gt;<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            valueList.add(ints[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; nodeSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        nodeSet.add(start);</span><br><span class="line">        breathList.add(start);</span><br><span class="line">        <span class="keyword">while</span> (!breathList.isEmpty()) &#123;</span><br><span class="line">            Integer first = breathList.removeFirst();</span><br><span class="line">            <span class="keyword">if</span> (first == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从图中获取该节点的所有相关点</span></span><br><span class="line">            Set&lt;Integer&gt; adjacent = temp.get(first);</span><br><span class="line">            <span class="keyword">if</span> (adjacent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Integer i : adjacent) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!nodeSet.contains(i)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == target) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        nodeSet.add(i);</span><br><span class="line">                        breathList.add(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nodeSet.add(first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-04-02-Minimum-Height-Tree"><a href="#LCCI-04-02-Minimum-Height-Tree" class="headerlink" title="LCCI.04.02 Minimum Height Tree"></a>LCCI.04.02 Minimum Height Tree</h2><p>题目：</p><blockquote><p>Given a sorted (increasing order) array with unique integer elements, write an algo­rithm to create a binary search tree with minimal height.</p></blockquote><p>这题我参考了书本上的解答，才发现可以这么用递归来解决。有点类似与二分法的解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createTreeNode(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">createTreeNode</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> midIndex = (start + end) / <span class="number">2</span>;</span><br><span class="line">        TreeNode mid = <span class="keyword">new</span> TreeNode(nums[midIndex]);</span><br><span class="line">        mid.left = createTreeNode(nums, start, midIndex - <span class="number">1</span>);</span><br><span class="line">        mid.right = createTreeNode(nums, midIndex + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-04-03-List-of-Depth"><a href="#LCCI-04-03-List-of-Depth" class="headerlink" title="LCCI.04.03 List of Depth"></a>LCCI.04.03 List of Depth</h2><p>题目：</p><blockquote><p>Given a binary tree, design an algorithm which creates a linked list of all the nodes at each depth (e.g., if you have a tree with depth D, you’ll have D linked lists). Return a array containing all the linked lists.</p></blockquote><p>我的思路是按照广度优先的算法进行遍历，然后将每一层的数据放入到list中。实现起来比我想象的要难一些：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode[] listOfDepth(TreeNode tree) &#123;</span><br><span class="line">        List&lt;ListNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode depthPoint = <span class="keyword">new</span> ListNode(tree.val);</span><br><span class="line">        TreeNode head = tree;</span><br><span class="line">        Queue&lt;TreeNode&gt; nextDepList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; tempnextDepList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        nextDepList.add(head);</span><br><span class="line">        <span class="keyword">while</span> (!nextDepList.isEmpty()) &#123;</span><br><span class="line">            tempnextDepList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            TreeNode poll = nextDepList.poll();</span><br><span class="line">            <span class="keyword">if</span> (poll.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                tempnextDepList.add(poll.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (poll.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                tempnextDepList.add(poll.right);</span><br><span class="line">            &#125;</span><br><span class="line">            depthPoint = <span class="keyword">new</span> ListNode(poll.val);</span><br><span class="line">            ListNode a = depthPoint;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode treeNode : nextDepList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (treeNode.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    tempnextDepList.add(treeNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (treeNode.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    tempnextDepList.add(treeNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">                a.next = <span class="keyword">new</span> ListNode(treeNode.val);</span><br><span class="line">                a = a.next;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(depthPoint);</span><br><span class="line">            nextDepList = tempnextDepList;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode[] resArray = <span class="keyword">new</span> ListNode[res.size()];</span><br><span class="line">        res.toArray(resArray);</span><br><span class="line">        <span class="keyword">return</span> resArray ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-04-04-Check-Balance"><a href="#LCCI-04-04-Check-Balance" class="headerlink" title="LCCI.04.04 Check Balance"></a>LCCI.04.04 Check Balance</h2><p>题目：</p><blockquote><p>Implement a function to check if a binary tree is balanced. For the purposes of this question, a balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one.</p></blockquote><p>一开始想的是用DFS做，看了提示后觉得可以用递归来实现。但是一直没有完成将结果返回出来的处理。参考书本后写出了传递结果的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = checkHeight(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> i != Integer.MIN_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkHeight</span><span class="params">(TreeNode node, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    k++;</span><br><span class="line">    <span class="keyword">int</span> left = checkHeight(node.left, k);</span><br><span class="line">    <span class="keyword">if</span> (left == Integer.MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> right = checkHeight(node.right, k);</span><br><span class="line">    <span class="keyword">if</span> (right == Integer.MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> highAbs = Math.abs(left - right);</span><br><span class="line">    <span class="keyword">if</span> (highAbs &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left &gt; right ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-04-05-Legal-Binary-Search-Tree"><a href="#LCCI-04-05-Legal-Binary-Search-Tree" class="headerlink" title="LCCI.04.05 Legal Binary Search Tree"></a>LCCI.04.05 Legal Binary Search Tree</h2><p>题目：</p><blockquote><p>Implement a function to check if a binary tree is a binary search tree.</p></blockquote><p>这题有两个关键点，第一点是要理解清楚二叉搜索树的定义。二叉搜索树要求：<strong>所有</strong>左边的节点小于或等于当前节点，而当前节点必须小于<strong>所有</strong>右边的节点。</p><p>有了这个条件，我们就可以写出满足二叉搜索树的条件：<code>currentNode.left.max&lt;=currentNode&lt;currentNode.right.min</code></p><p>我先参考了书本上的题解，是一种自顶而下的方法。我自己写了个自底向上的解法，需要将返回数据都封装在一个类里，进行结果返回给上一层处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//测试用例中根节点为null时返回true</span></span><br><span class="line">       &#125;</span><br><span class="line">       PacValue res = isBST(root, <span class="keyword">null</span>, root.val);</span><br><span class="line">       <span class="keyword">return</span> res.isRes();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于封装返回结果数据的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">PacValue</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> min;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> max;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMax</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.max = max;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> min;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMin</span><span class="params">(<span class="keyword">int</span> min)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.min = min;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRes</span><span class="params">(<span class="keyword">boolean</span> res)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.res = res;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">PacValue <span class="title">isBST</span><span class="params">(TreeNode node, Boolean isMax, Integer preNodeVal)</span> </span>&#123;</span><br><span class="line">       PacValue value = <span class="keyword">new</span> PacValue();</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//递归返回条件</span></span><br><span class="line">       &#125;</span><br><span class="line">       PacValue left = isBST(node.left, <span class="keyword">true</span>, node.val);</span><br><span class="line">       <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; !left.isRes()) &#123;</span><br><span class="line">           value.setRes(<span class="keyword">false</span>);<span class="comment">//左子树已不满足二叉搜索树时，直接向上传递结果</span></span><br><span class="line">           <span class="keyword">return</span> value;</span><br><span class="line">       &#125;</span><br><span class="line">       PacValue right = isBST(node.right, <span class="keyword">false</span>, node.val);</span><br><span class="line">       <span class="keyword">if</span> (right != <span class="keyword">null</span> &amp;&amp; !right.isRes()) &#123;</span><br><span class="line">           value.setRes(<span class="keyword">false</span>);<span class="comment">//右子树已不满足二叉搜索树时，直接向上传递结果</span></span><br><span class="line">           <span class="keyword">return</span> value;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//&lt;editor-fold desc="对于基线条件的处理"&gt;</span></span><br><span class="line">       <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">           value.setMax(node.val);<span class="comment">//左右子树都为空，则最大最小值为当前节点的值</span></span><br><span class="line">           value.setMin(node.val);</span><br><span class="line">           value.setRes(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 左子树为空，右子树不为空，若满足当前node小于右子树的最小值，则仍满足二叉搜索树的属性</span></span><br><span class="line"><span class="comment">            * 此时则最大值为右子树的最大值，最小值为当前节点值</span></span><br><span class="line"><span class="comment">            * 注意：此时若不满足属性，则最大值填了右子树最大值是错的，</span></span><br><span class="line"><span class="comment">            * 但是这样没有关系，因为一旦不满足属性递归不会再做处理直接层层向上传递false的结果</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           value.setMax(right.getMax());</span><br><span class="line">           value.setMin(node.val);</span><br><span class="line">           value.setRes(node.val &lt; right.getMin());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;<span class="comment">//类似上一种情况</span></span><br><span class="line">           value.setMax(node.val);</span><br><span class="line">           value.setMin(left.getMin());</span><br><span class="line">           value.setRes(node.val &gt; left.getMax());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 左右子树都不为空，则按照当前节点小于右子树的最小值，并大于左子树的最大值来进行判断是否</span></span><br><span class="line"><span class="comment">            * 满足二叉搜索树的属性</span></span><br><span class="line"><span class="comment">            * 此时，若满足属性则最小值为左子树的最小值，最大值为右子树的最大值。</span></span><br><span class="line"><span class="comment">            * 若不满足属性，此时的最大最小值设置是错的，但是没有关系，不满足属性的结果会直接向上传递。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           value.setRes(node.val &gt; left.getMax() &amp;&amp; node.val &lt; right.getMin());</span><br><span class="line">           value.setMin(left.getMin());</span><br><span class="line">           value.setMax(right.getMax());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//&lt;/editor-fold&gt;</span></span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-04-06-Successor-LCCI"><a href="#LCCI-04-06-Successor-LCCI" class="headerlink" title="LCCI.04.06 Successor LCCI"></a>LCCI.04.06 Successor LCCI</h2><p>题目：</p><blockquote><p>Write an algorithm to find the “next” node (i.e., in-order successor) of a given node in a binary search tree.</p><p>Return null if there’s no “next” node for the given node.</p></blockquote><p>这题我第一遍没有做出来，递归写的太复杂。看了书本上的答案也只是给出了伪代码，参考题解后发现有大神给出了很厉害的解法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> searchInorder(root, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode <span class="title">searchInorder</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= p.val) &#123;</span><br><span class="line">        TreeNode right = searchInorder(root.right, p);</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode left = searchInorder(root.left, p);</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? root : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我觉得这题的关键在于依赖了完全搜索二叉树的性质，按照中序遍历完全搜索二叉树得出的是一个有序数组。因此访问中序遍历的下个节点，即可理解为访问大于当前节点值得下一个节点。</p><h2 id="LCCI-04-08-First-Common-Ancestor"><a href="#LCCI-04-08-First-Common-Ancestor" class="headerlink" title="LCCI.04.08 First Common Ancestor"></a>LCCI.04.08 First Common Ancestor</h2><p>题目：</p><blockquote><p>Design an algorithm and write code to find the first common ancestor of two nodes in a binary tree. Avoid storing additional nodes in a data structure. NOTE: This is not necessarily a binary search tree</p></blockquote><p>这题我看了题解之后有了思路，其实二叉树搜索的解法与遍历递归的思想是一样的，要么自顶而下，要么自底而上。这一题要找公共祖先，则自顶而下的方法相对容易。于是先开始在根节点的左子树查找，找不到的话再从右子树查找，左右子树都没有则只有返回当前节点了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (containpq(root.left, p, q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (containpq(root.right, p, q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containpq</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root != <span class="keyword">null</span> &amp;&amp; forwardFind(root, p, q, <span class="number">0</span>)&gt;=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">forwardFind</span><span class="params">(TreeNode root, TreeNode p, TreeNode q, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    k = forwardFind(root.left, p, q, k);</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val == p.val || root.val == q.val) &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    k = forwardFind(root.right, p, q, k);</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的实现方法多了一个判断是否存在于子树的递归方法，使得我的解法耗时较长。参考题解，有个大神的解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == p.val || root.val == q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这题的思想与我的基本类似，只是作者没有用判断是否存在于子树来作为递归的条件。直接当前节点与p或q相等时返回当前节点。这里不用再继续往下遍历的原因是，若q或p在当前节点的子节点，那么当前节点就是第一个公共父节点。因此可以直接返回。若既不在左子树又不在右子树则直接返回null，通过返回结果是否为null来判断是否在子树中，这样就可以把我的containpq方法的逻辑给合并了。</p><h2 id="LCCI-04-10-Check-SubTree"><a href="#LCCI-04-10-Check-SubTree" class="headerlink" title="LCCI.04.10 Check SubTree"></a>LCCI.04.10 Check SubTree</h2><p>题目：</p><blockquote><p>T1 and T2 are two very large binary trees, with T1 much bigger than T2. Create an algorithm to determine if T2 is a subtree of T1.</p><p>A tree T2 is a subtree of T1 if there exists a node n in T1 such that the subtree of n is identical to T2. That is, if you cut off the tree at node n, the two trees would be identical.</p></blockquote><p>这题主要的要点在于如何理解两个树是相等的，可以采用前序遍历后的结果转换为字符串进行对比。要注意一下：中序遍历即使是不同的结构，也有可能产生相同的结果。但是前序遍历时，只要将为null的节点标识出来即可确定只有相同的树结构才能产生相同的结果。因为前序遍历的第一个节点一定是根节点，可以确定根节点，再确定左右节点，即可保证树的结构相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubTree</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    StringBuilder a = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    StringBuilder b = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    forwardTree(t1, a);</span><br><span class="line">    forwardTree(t2, b);</span><br><span class="line">    <span class="keyword">return</span> a.indexOf(b.toString())!=-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forwardTree</span><span class="params">(TreeNode root, StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        stringBuilder.append(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stringBuilder.append(root.val);</span><br><span class="line">    forwardTree(root.left,stringBuilder);</span><br><span class="line">    forwardTree(root.right,stringBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-04-12-Paths-with-Sum"><a href="#LCCI-04-12-Paths-with-Sum" class="headerlink" title="LCCI.04.12 Paths with Sum"></a>LCCI.04.12 Paths with Sum</h2><p>题目：</p><blockquote><p>You are given a binary tree in which each node contains an integer value (which might be positive or negative). Design an algorithm to count the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p></blockquote><p>此题可以参考书本上的解法，先从暴力求解的思路来想，需要将每个节点作为根节点，遍历其至底部节点的路径和。在这个过程中，我们不断重复计算了同个路径下的不同子路径的路径和。将其看成数组，即为求解数组中和为targetSum的区间有几个。我们可以采取类似时间轴的方式，累积每个节点路径和。将其放入到Map中，再用类似twosum的思想，遍历数组的每个节点，能得出距其targetsum的节点数。详细的可以看下书本上的解答。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> countPaths(root, <span class="keyword">new</span> HashMap&lt;&gt;(), sum, <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">countPaths</span><span class="params">(TreeNode root, HashMap&lt;Integer, Integer&gt; pathSumValueCount, <span class="keyword">int</span> targetSum, <span class="keyword">int</span> pathSum)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     pathSum = pathSum + root.val;</span><br><span class="line">     <span class="keyword">int</span> totalPath = pathSumValueCount.getOrDefault(pathSum - targetSum, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">if</span> (pathSum == targetSum) &#123;</span><br><span class="line">         totalPath++;</span><br><span class="line">     &#125;</span><br><span class="line">     handlePathSumMap(pathSumValueCount, pathSum, <span class="number">1</span>);</span><br><span class="line">     totalPath += countPaths(root.left, pathSumValueCount, targetSum, pathSum);</span><br><span class="line">     totalPath += countPaths(root.right, pathSumValueCount, targetSum, pathSum);</span><br><span class="line">     handlePathSumMap(pathSumValueCount, pathSum, -<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> totalPath;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">handlePathSumMap</span><span class="params">(HashMap&lt;Integer, Integer&gt; pathSumValueCount, <span class="keyword">int</span> pathSum, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">     Integer paths = pathSumValueCount.computeIfAbsent(pathSum, s -&gt; <span class="number">0</span>);</span><br><span class="line">     pathSumValueCount.put(pathSum, paths + delta);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-05-01-Insert-Into-Bits"><a href="#LCCI-05-01-Insert-Into-Bits" class="headerlink" title="LCCI.05.01 Insert Into Bits"></a>LCCI.05.01 Insert Into Bits</h2><p>题目：</p><blockquote><p>You are given two 32-bit numbers, N and M, and two bit positions, i and j. Write a method to insert M into N such that M starts at bit j and ends at bit i. You can assume that the bits j through i have enough space to fit all of M. That is, if M = 10011, you can assume that there are at least 5 bits between j and i. You would not, for example, have j = 3 and i = 2, because M could not fully fit between bit 3 and bit 2.</p></blockquote><p>这题主要考察的是如何通过位运算更新值，取出值。一开始按照书本上的解答做出来发现无法通过一个测试案例，查看评论才发现是当左移位数超过31时，符号位并没有改变。因此需要做一个特殊处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertBits</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= <span class="number">31</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; j - <span class="number">31</span>; b++) &#123;</span><br><span class="line">            left = left | <span class="number">1</span> &lt;&lt; b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = ~<span class="number">0</span> &lt;&lt; (j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> right = (<span class="number">1</span> &lt;&lt; (i)) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mask = left | right;</span><br><span class="line">    N = N &amp; mask;</span><br><span class="line">    <span class="keyword">return</span> N | (M &lt;&lt; i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-05-02-Binary-Number-to-String"><a href="#LCCI-05-02-Binary-Number-to-String" class="headerlink" title="LCCI.05.02 Binary Number to String"></a>LCCI.05.02 Binary Number to String</h2><p>题目：</p><blockquote><p>Given a real number between O and 1 (e.g., 0.72) that is passed in as a double, print the binary representation. If the number cannot be represented accurately in binary with at most 32 characters, print “ERROR”.</p></blockquote><p>这题的重点在于怎么理解小数的二进制表达。小数的二进制表达用的是逼近的方式：$$0.625=二进制的0.101=1\times1/2^{1}+0\times1/2^{2}+1\times1/2^{3}=1\times0.5+0\times0.25+1\times0.125$$.因此我们可以使用乘以2的方式来将小数点后的二进制往左移位。因为double类型的数据不支持直接移位运算符<code>&lt;&lt;</code>，所以必须采用乘以2的方式来完成左移。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public String printBin(double num) &#123;</span><br><span class="line">    if (num &gt;= 1 || num &lt;= 0) &#123;</span><br><span class="line">        return &quot;ERROR&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    sb.append(&quot;0.&quot;);</span><br><span class="line">    while (num &gt; 0) &#123;</span><br><span class="line">        if (sb.length() &gt; 32) &#123;</span><br><span class="line">            return &quot;ERROR&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        num = num * 2;</span><br><span class="line">        if (num &gt;= 1) &#123;</span><br><span class="line">            sb.append(&quot;1&quot;);</span><br><span class="line">            num = num - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sb.append(&quot;0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-05-03-Reverse-Bits"><a href="#LCCI-05-03-Reverse-Bits" class="headerlink" title="LCCI.05.03 Reverse Bits"></a>LCCI.05.03 Reverse Bits</h2><p>题目：</p><blockquote><p>You have an integer and you can flip exactly one bit from a 0 to a 1. Write code to find the length of the longest sequence of 1s you could create.</p></blockquote><p>此题的关键在于如何找出将一位0翻转为1后，连续的1最长的方法。参考书本答案后，给出如下解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (~num == <span class="number">0</span>) <span class="keyword">return</span> Integer.BYTES * <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> currentCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> prveCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            currentCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                prveCount = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prveCount = currentCount;</span><br><span class="line">            &#125;</span><br><span class="line">            currentCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxCount = Math.max(prveCount + currentCount + <span class="number">1</span>, maxCount);</span><br><span class="line">        num = num &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-05-04-Closed-Number"><a href="#LCCI-05-04-Closed-Number" class="headerlink" title="LCCI.05.04 Closed Number"></a>LCCI.05.04 Closed Number</h2><p>题目:</p><blockquote><p>Given a positive integer, print the next smallest and the next largest number that have the same number of 1 bits in their binary representation.</p></blockquote><p>此题的重点是要知道怎么分析问题，题目要求取出最相近的两个数。那么大的那个数应该是最右边非尾部的0变为1（假设为第i位），再在i的右边，从右往左插入n-1个1（n为i右边的1的个数）。</p><p>小的那个数应该是最右边非尾部的1变为0（假设为第j位），再在j的右边，从左往右插入m+1个1（m为j右边的1的个数）。</p><p>题目分析清楚后就是代码实现，代码实现的时候又很多细节需要注意，都写在注释里了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findClosedNumbers(<span class="keyword">int</span> num) &#123;</span><br><span class="line">      <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">      <span class="keyword">if</span> (num == <span class="number">0</span> || num == (~<span class="number">0</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line">      res[<span class="number">0</span>] = getNext(num);</span><br><span class="line">      res[<span class="number">1</span>] = getPrev(num);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPrev</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">boolean</span> find0 = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.BYTES * <span class="number">8</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((num &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>) &#123;</span><br><span class="line">              find0 = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (((num &amp; (<span class="number">1</span> &lt;&lt; i)) == (<span class="number">1</span> &lt;&lt; i))) &#123;</span><br><span class="line">              count++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (((num &amp; (<span class="number">1</span> &lt;&lt; i)) == (<span class="number">1</span> &lt;&lt; i)) &amp;&amp; find0) &#123;</span><br><span class="line">              <span class="comment">//将i位变为0  将i位右边全置为0 再添加count+1位的1</span></span><br><span class="line">              res = num &amp; (~(<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                  res = res &amp; (~(<span class="number">1</span> &lt;&lt; k));</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;<span class="comment">//由于count计数的时候将当前的1包含进去了，所以往右边添加1时不需要再将count+1了</span></span><br><span class="line">                  res = res | (<span class="number">1</span> &lt;&lt; (i - j));</span><br><span class="line">                  j++;</span><br><span class="line">                  count--;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">boolean</span> find1 = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">boolean</span> findFirstNotTail0 = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.BYTES * <span class="number">8</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((num &amp; (<span class="number">1</span> &lt;&lt; i)) == (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">              count++;</span><br><span class="line">              find1 = <span class="keyword">true</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//出现1之后的第一个0置为1，将该位右边全置为0，再从右往左放入count-1个1</span></span><br><span class="line">              <span class="keyword">if</span> (find1) &#123;</span><br><span class="line">                  res = num | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> k = i-<span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                      res = res &amp; (~(<span class="number">1</span> &lt;&lt; k));</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">                  <span class="keyword">while</span> ((count-<span class="number">1</span> ) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                      res = res | (<span class="number">1</span> &lt;&lt;  j);</span><br><span class="line">                      count--;</span><br><span class="line">                      j++;</span><br><span class="line">                  &#125;</span><br><span class="line">                  findFirstNotTail0 = <span class="keyword">true</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!findFirstNotTail0) &#123;</span><br><span class="line">          res = -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-05-06-Convert-Interger"><a href="#LCCI-05-06-Convert-Interger" class="headerlink" title="LCCI.05.06 Convert Interger"></a>LCCI.05.06 Convert Interger</h2><p>题目：</p><blockquote><p>Write a function to determine the number of bits you would need to flip to convert integer A to integer B.</p></blockquote><p>这题很容易就可以想到用异或来做，两个数相异或后，再取出异或后的数字中1的个数作为结果返回即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">convertInteger</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> C = A ^ B;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (C != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((C &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        C &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-05-07-Exchange"><a href="#LCCI-05-07-Exchange" class="headerlink" title="LCCI.05.07 Exchange"></a>LCCI.05.07 Exchange</h2><p>题目：</p><blockquote><p>Write a program to swap odd and even bits in an integer with as few instructions as possible (e.g., bit 0 and bit 1 are swapped, bit 2 and bit 3 are swapped, and so on).</p></blockquote><p>这题主要的思想在于需要取出奇数位和偶数位，再将奇数位逻辑右移1位，将偶数位左移1位。然后再二者相或即可得出交换后的值。此处需要注意的是用于取奇数位和偶数位的掩码怎么运算的。二进制的1010代表的是十进制的10，在十六进制中则是0xA。因此用于取奇数位的掩码则是0xAAAAAAAA，则取偶数位的掩码为0x55555555，或者用<code>~0xAAAAAAAA</code>也可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">exchangeBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oddMask = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line">    <span class="keyword">int</span> oddNumber = num &amp; oddMask;</span><br><span class="line">    <span class="keyword">int</span> evenMask = ~<span class="number">0xAAAAAAAA</span>;</span><br><span class="line">    <span class="keyword">int</span> evenNumber = num &amp; evenMask;</span><br><span class="line">    <span class="keyword">return</span> (oddNumber &gt;&gt;&gt; <span class="number">1</span>) | (evenNumber &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-05-08-Draw-Line"><a href="#LCCI-05-08-Draw-Line" class="headerlink" title="LCCI.05.08 Draw Line"></a>LCCI.05.08 Draw Line</h2><p>题目：</p><blockquote><p>A monochrome screen is stored as a single array of int, allowing 32 consecutive pixels to be stored in one int. The screen has width w, where w is divisible by 32 (that is, no byte will be split across rows). The height of the screen, of course, can be derived from the length of the array and the width. Implement a function that draws a horizontal line from (x1, y) to (x2, y).</p><p>Given the length of the array, the width of the array (in bit), start position x1 (in bit) of the line, end position x2 (in bit) of the line and the row number y of the line, return the array after drawing.</p></blockquote><p>这题的重点在于需要理解清楚题目的意思。我采用了简单的将x1至x2区间内的0置为1的方法。这种解法实现起来较为简单，但是效率不高。使用掩码将x1和x2之间的整数1的位置整个置为1的效率更高。当然要考虑x1和x2处于同一区间中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] drawLine(<span class="keyword">int</span> length, <span class="keyword">int</span> w, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] screen = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> startIndex = (y * w + x1) / <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">int</span> startBitIndex = (y * w + x1) % <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">int</span> total = x2 - x1 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startBitIndex; i &lt; <span class="number">32</span> &amp;&amp; total &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">            current = current | (<span class="number">1</span> &lt;&lt; (<span class="number">31</span> - i));</span><br><span class="line">            total--;</span><br><span class="line">        &#125;</span><br><span class="line">        screen[startIndex++] = current;</span><br><span class="line">        current = <span class="number">0</span>;</span><br><span class="line">        startBitIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> screen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-08-01-Three-Steps-Problem"><a href="#LCCI-08-01-Three-Steps-Problem" class="headerlink" title="LCCI.08.01 Three Steps Problem"></a>LCCI.08.01 Three Steps Problem</h2><p>题目：</p><blockquote><p>A child is running up a staircase with n steps and can hop either 1 step, 2 steps, or 3 steps at a time. Implement a method to count how many possible ways the child can run up the stairs. The result may be large, so return it modulo 1000000007.</p></blockquote><p>做题最重要的果然还是看清楚题目，然后再写出解法。这题我一开始想的过于简单，以为是需要用乘法，实则不然。只需要<code>f(n)=f(n-1)+f(n-2)+f(n-3)</code>这个基线条件即可写出递归。但是由于测试案例中的数据量很大，因此需要处理数据溢出和递归深度的问题。后来改为了动态规划的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToStep</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        d = ((a + b)%mod + c)%mod;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">        c=d;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-08-02-Robot-in-a-Grid"><a href="#LCCI-08-02-Robot-in-a-Grid" class="headerlink" title="LCCI.08.02  Robot in a Grid"></a>LCCI.08.02  Robot in a Grid</h2><p>题目：</p><blockquote><p>Imagine a robot sitting on the upper left corner of grid with r rows and c columns. The robot can only move in two directions, right and down, but certain cells are “off limits” such that the robot cannot step on them. Design an algorithm to find a path for the robot from the top left to the bottom right.</p></blockquote><p>这题的关键在于如何理解基线条件。需要自底向上的思考，找到最后一个需要一步步的往前找到倒数第二个，倒数第三个。然后遇到1的时候则返回失败。再对其失败的路线进行缓存，即是动态规划。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathWithObstacles(<span class="keyword">int</span>[][] obstacleGrid) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid == <span class="keyword">null</span> || obstacleGrid.length == <span class="number">0</span>|| obstacleGrid[<span class="number">0</span>]==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    HashSet&lt;List&lt;Integer&gt;&gt; failed = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (getPath(res, failed, obstacleGrid, obstacleGrid.length - <span class="number">1</span>, obstacleGrid[<span class="number">0</span>].length - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getPath</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, HashSet&lt;List&lt;Integer&gt;&gt; failed, <span class="keyword">int</span>[][] obstacleGrid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || (obstacleGrid[r][c] ==<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    List point = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    point.add(r);</span><br><span class="line">    point.add(c);</span><br><span class="line">    <span class="keyword">if</span> (failed.contains(point)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> isAtSourse = (r == <span class="number">0</span> &amp;&amp; c == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (isAtSourse || getPath(res, failed, obstacleGrid, r - <span class="number">1</span>, c) || getPath(res, failed, obstacleGrid, r, c - <span class="number">1</span>)) &#123;</span><br><span class="line">        res.add(point);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    failed.add(point);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-08-03-Magic-Index"><a href="#LCCI-08-03-Magic-Index" class="headerlink" title="LCCI.08.03 Magic Index"></a>LCCI.08.03 Magic Index</h2><p>题目：</p><blockquote><p>A magic index in an array A[0…n-1] is defined to be an index such that A[i] = i. Given a sorted array of distinct integers, write a method to find a magic index, if one exists, in array A. If not, return -1. If there are more than one magic index, return the smallest one.</p></blockquote><p>此题最简单的解法当然是用数组遍历，但是因为题目给出的条件是有序数组，因此可以利用排序来做。此题可以用递归实现二分法来解决。测试用例中存在重复的元素，因此需要处理下重复的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> binaryFind(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">binaryFind</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span> (nums[mid] == mid) &#123;</span><br><span class="line">         <span class="keyword">return</span> mid;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> leftres = binaryFind(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">if</span> (leftres != -<span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> leftres;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> binaryFind(nums, mid + <span class="number">1</span>, end);;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注意：当题目中给出了有序的条件时，一般来说这个条件是可以加以利用的。</p><h2 id="LCCI-08-04-Power-Set"><a href="#LCCI-08-04-Power-Set" class="headerlink" title="LCCI.08.04 Power Set"></a>LCCI.08.04 Power Set</h2><p>题目：</p><blockquote><p>Write a method to return all subsets of a set. The elements in a set are pairwise distinct.</p><p>Note: The result set should not contain duplicated subsets.</p></blockquote><p>此题类似与之前的三步问题，关键点在于找到基线条件：数组nums的子集为数组nums[n-1]的子集，将其复制一份然后每个加上nums[n]的元素即可。代码实现较为简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; sets = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        getSubSets(nums, nums.length-<span class="number">1</span>, sets);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(sets);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSubSets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, Set&lt;List&lt;Integer&gt;&gt; sets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sets.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getSubSets(nums, --i, sets);</span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; integerList : sets) &#123;</span><br><span class="line">            List&lt;Integer&gt; inn = <span class="keyword">new</span> ArrayList&lt;&gt;(integerList);</span><br><span class="line">            inn.add(nums[i+<span class="number">1</span>]);</span><br><span class="line">            temp.add(inn);</span><br><span class="line">        &#125;</span><br><span class="line">        sets.addAll(temp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看了题解中还有种解法是通过位来表示数组中的数字，这种思路很巧妙，不需要使用递归，直接将每个组合都打印出来即可。贴出题解：</p><blockquote><p>例如 [1, 2, 3] 有三位可以从 0 遍历到 7 也就是 2 ^ 3 - 1 用二进制表示就是 000, 001, 010, 011, 100, 101, 110, 111 正好代表了全部子集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">&gt;         List&lt;List&lt;Integer&gt;&gt; subsets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&gt;         <span class="keyword">int</span> bmp = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, nums.length);</span><br><span class="line">&gt;         <span class="comment">// 从 nums.length 个 0 遍历到 nums.length 个 1</span></span><br><span class="line">&gt;         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bmp; i++) &#123;</span><br><span class="line">&gt;             List&lt;Integer&gt; subset = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&gt;             <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)</span><br><span class="line">&gt;                 <span class="comment">// 将每一位右移最低位，检测其是否为1</span></span><br><span class="line">&gt;                 <span class="keyword">if</span> ((i &gt;&gt;&gt; j &amp; <span class="number">1</span>) == <span class="number">1</span>) subset.add(nums[j]);</span><br><span class="line">&gt;             subsets.add(subset);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> subsets;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="LCCI-08-05-Recursive-Multiply"><a href="#LCCI-08-05-Recursive-Multiply" class="headerlink" title="LCCI.08.05 Recursive Multiply"></a>LCCI.08.05 Recursive Multiply</h2><p>题目：</p><blockquote><p>Write a recursive function to multiply two positive integers without using the * operator. You can use addition, subtraction, and bit shifting, but you should minimize the number of those operations.</p></blockquote><p>这题有多种解法，我看了提示之后，写出了提示的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (B == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> C = B &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> multiply(A, C) + multiply(A, B - C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-08-06-Hanota"><a href="#LCCI-08-06-Hanota" class="headerlink" title="LCCI.08.06 Hanota"></a>LCCI.08.06 Hanota</h2><p>题目：</p><blockquote><p>In the classic problem of the Towers of Hanoi, you have 3 towers and N disks of different sizes which can slide onto any tower. The puzzle starts with disks sorted in ascending order of size from top to bottom (i.e., each disk sits on top of an even larger one). You have the following constraints:</p><p>(1) Only one disk can be moved at a time.<br>(2) A disk is slid off the top of one tower onto another tower.<br>(3) A disk cannot be placed on top of a smaller disk.</p><p>Write a program to move the disks from the first tower to the last using stacks.</p></blockquote><p>汉诺塔的问题，思路是将n-1合并到一起，和第n个组成两个盘子的汉诺塔去递归求解。不需要特别仔细的去追究递归的过程。我一开始就陷入了追究递归的过程中去而导致没有找到答案，实际不需要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        moveDisk(A.size() - <span class="number">1</span>, A, C, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveDisk</span><span class="params">(<span class="keyword">int</span> n, List&lt;Integer&gt; orign, List&lt;Integer&gt; dest, List&lt;Integer&gt; buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        moveDisk(n - <span class="number">1</span>, orign, buffer, dest);</span><br><span class="line">        dest.add(orign.remove(orign.size() - <span class="number">1</span>));</span><br><span class="line">        moveDisk(n - <span class="number">1</span>, buffer, dest, orign);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-08-07-Permutation"><a href="#LCCI-08-07-Permutation" class="headerlink" title="LCCI.08.07 Permutation"></a>LCCI.08.07 Permutation</h2><p>题目：</p><blockquote><p>Write a method to compute all permutations of a string of unique characters.</p></blockquote><p>这题与之前的一到题目很相似，先找到n-1个char组成的数组的所有排列组合，再将第n位的字符与之前所有的排列组合相累积在一起。这样即可得到长度为n的字符所有的排列组合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] permutation(String S) &#123;</span><br><span class="line">       List&lt;String&gt; res = permutationRecusive(S);</span><br><span class="line">       String[] ress = <span class="keyword">new</span> String[res.size()];</span><br><span class="line">       <span class="keyword">return</span> res.toArray(ress);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">List&lt;String&gt; <span class="title">permutationRecusive</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (S.length() == <span class="number">1</span>) &#123;</span><br><span class="line">           res.add(S);</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">char</span> c = S.charAt(i);</span><br><span class="line">           StringBuilder sb = <span class="keyword">new</span> StringBuilder(S);</span><br><span class="line">           sb.deleteCharAt(i);</span><br><span class="line">           List&lt;String&gt; te = permutationRecusive(sb.toString());</span><br><span class="line">           <span class="keyword">for</span> (String teString : te) &#123;</span><br><span class="line">               res.add(teString + c);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>看到题解中，大家普遍采用的是回溯算法，用深度优先搜索去实现的。贴出其中一个解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String S) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] array = S.toCharArray();</span><br><span class="line">        dfs(array, <span class="keyword">new</span> StringBuilder());</span><br><span class="line"></span><br><span class="line">        String[] res = <span class="keyword">new</span> String[list.size()];</span><br><span class="line">        <span class="keyword">return</span> list.toArray(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">char</span>[] array, StringBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (builder.length() == array.length) &#123;</span><br><span class="line">            list.add(builder.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (builder.toString().contains(String.valueOf(c))) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            builder.append(c);</span><br><span class="line">            dfs(array, builder);</span><br><span class="line">            builder.deleteCharAt(builder.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-08-09-Bracket"><a href="#LCCI-08-09-Bracket" class="headerlink" title="LCCI.08.09 Bracket"></a>LCCI.08.09 Bracket</h2><p>题目：</p><blockquote><p>Implement an algorithm to print all valid (e.g., properly opened and closed) combinations of n pairs of parentheses.</p><p>Note: The result set should not contain duplicated subsets.</p></blockquote><p>这题我是参考之前的套路采用的递归方式，先取出n-1的结果，再在n-1的结果上组装n的结果。看了题解有很多人采用的回溯的方法去做。关于回溯算法，我还是没有掌握。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        res.add(<span class="string">"()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(res);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; temp = generateParenthesis(--n);</span><br><span class="line">    <span class="keyword">for</span> (String s : temp) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                res.add(insertParent(s, i));</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="string">"()"</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">insertParent</span><span class="params">(String orign, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    String left = orign.substring(<span class="number">0</span>, offset + <span class="number">1</span>);</span><br><span class="line">    String right = orign.substring(offset + <span class="number">1</span>, orign.length());</span><br><span class="line">    <span class="keyword">return</span> left + <span class="string">"()"</span> + right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-08-10-Color-Fill"><a href="#LCCI-08-10-Color-Fill" class="headerlink" title="LCCI.08.10 Color Fill"></a>LCCI.08.10 Color Fill</h2><p>题目：</p><blockquote><p>Implement the “paint fill” function that one might see on many image editing programs. That is, given a screen (represented by a two-dimensional array of colors), a point, and a new color, fill in the surrounding area until the color changes from the original color.</p></blockquote><p>这题与之前的方格类似，我采用的也是类似于深度优先搜索的解法，一开始有用例没过去，其实可以采用特殊的处理方式将其规避。我采用的是动态规划的方式，将每个已经被填充的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">    <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[image.length][image[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">return</span> floodFill(image, sr, sc, newColor, image[sr][sc], memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor, <span class="keyword">int</span> origColor, <span class="keyword">int</span>[][] memo) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sr &lt; <span class="number">0</span> || sc &lt; <span class="number">0</span> || sr &gt; image.length - <span class="number">1</span> || sc &gt; image[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (origColor == image[sr][sc] &amp;&amp; memo[sr][sc] != <span class="number">1</span>) &#123;</span><br><span class="line">        image[sr][sc] = newColor;</span><br><span class="line">        memo[sr][sc] = <span class="number">1</span>;</span><br><span class="line">        image = floodFill(image, sr - <span class="number">1</span>, sc, newColor, origColor, memo);</span><br><span class="line">        image = floodFill(image, sr + <span class="number">1</span>, sc, newColor, origColor, memo);</span><br><span class="line">        image = floodFill(image, sr, sc - <span class="number">1</span>, newColor, origColor, memo);</span><br><span class="line">        image = floodFill(image, sr, sc + <span class="number">1</span>, newColor, origColor, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-08-11-Coin"><a href="#LCCI-08-11-Coin" class="headerlink" title="LCCI.08.11 Coin"></a>LCCI.08.11 Coin</h2><p>按照书本解法的动态规划未能通过，金额总是变化导致动态规划的存储内容失效</p><h2 id="LCCI-08-12-Eight-Queens"><a href="#LCCI-08-12-Eight-Queens" class="headerlink" title="LCCI.08.12 Eight Queens"></a>LCCI.08.12 Eight Queens</h2><p>题目：</p><blockquote><p>Write an algorithm to print all ways of arranging n queens on an n x n chess board so that none of them share the same row, column, or diagonal. In this case, “diagonal” means all diagonals, not just the two that bisect the board.</p></blockquote><p>这题我是参考的书本上的解法，我一开始么有想到好的递归写法。写递归的时候还是有时候无法组织清楚，还需要加强练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">     List&lt;Integer[]&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     List&lt;List&lt;String&gt;&gt; stringRes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     placeQueen(result, <span class="number">0</span>, <span class="keyword">new</span> Integer[n], n);</span><br><span class="line">     <span class="keyword">for</span> (Integer[] integerArray : result) &#123;</span><br><span class="line">         List&lt;String&gt; stringList = transString(integerArray);</span><br><span class="line">         stringRes.add(stringList);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> stringRes;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">transString</span><span class="params">(Integer[] arrays)</span> </span>&#123;</span><br><span class="line">     List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrays.length; i++) &#123;</span><br><span class="line">         Integer columns = arrays[i];</span><br><span class="line">         StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arrays.length; j++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (columns==j) &#123;</span><br><span class="line">                 sb.append(<span class="string">'Q'</span>);</span><br><span class="line">             &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                 sb.append(<span class="string">'.'</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         res.add(sb.toString());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">placeQueen</span><span class="params">(List&lt;Integer[]&gt; result, <span class="keyword">int</span> row, Integer[] columns, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">         result.add(columns.clone());</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (checkValid(row, col, columns)) &#123;</span><br><span class="line">                 columns[row] = col;</span><br><span class="line">                 placeQueen(result, row + <span class="number">1</span>, columns, n);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkValid</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, Integer[] columns)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">         <span class="comment">//检查其他行的col列是否有数据</span></span><br><span class="line">         <span class="keyword">if</span> (columns[i] == col) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">int</span> columnDistance = Math.abs(columns[i] - col);</span><br><span class="line">         <span class="keyword">int</span> rowDistance = row - i;</span><br><span class="line">         <span class="keyword">if</span> (columnDistance == rowDistance) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这题的一个难点在于校验对角线：两个皇后之间的行距和列距相等则认为是在同一对角线上。另一个难点在于处理校验失败的情形。</p><h2 id="LCCI-08-13-Pile-Box"><a href="#LCCI-08-13-Pile-Box" class="headerlink" title="LCCI.08.13 Pile Box"></a>LCCI.08.13 Pile Box</h2><p>题目：</p><blockquote><p>You have a stack of n boxes, with widths wi, depths di, and heights hi. The boxes cannot be rotated and can only be stacked on top of one another if each box in the stack is strictly larger than the box above it in width, height, and depth. Implement a method to compute the height of the tallest possible stack. The height of a stack is the sum of the heights of each box.</p><p>The input use [wi, di, hi] to represents each box.</p></blockquote><p>这题我也是参考书本的解法才写出来的，主要思想就是通过dp来实现子问题的解，先将所有的箱子按照某一维度排序，再将每个箱子作为bottom来计算高度，取出最大的高度即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pileBox</span><span class="params">(<span class="keyword">int</span>[][] box)</span> </span>&#123;</span><br><span class="line">        sort(box);</span><br><span class="line">        <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[box.length];</span><br><span class="line">        <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; box.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> stackHeight = createStack(box, i, memo);</span><br><span class="line">            maxHeight = Math.max(stackHeight, maxHeight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[][] box)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; box.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; box.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (box[j][<span class="number">2</span>] &lt; box[j + <span class="number">1</span>][<span class="number">2</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span>[] temp = box[j];</span><br><span class="line">                    box[j] = box[j + <span class="number">1</span>];</span><br><span class="line">                    box[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">createStack</span><span class="params">(<span class="keyword">int</span>[][] box, <span class="keyword">int</span> bottomIndex, <span class="keyword">int</span>[] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[bottomIndex] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[bottomIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] bottom = box[bottomIndex];</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = bottomIndex + <span class="number">1</span>; i &lt; box.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canAbove(bottom, box[i])) &#123;</span><br><span class="line">                <span class="keyword">int</span> stackHight = createStack(box, i, memo);</span><br><span class="line">                height = Math.max(stackHight, height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        height += bottom[<span class="number">2</span>];</span><br><span class="line">        memo[bottomIndex] = height;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canAbove</span><span class="params">(<span class="keyword">int</span>[] lower, <span class="keyword">int</span>[] upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lower[<span class="number">0</span>] &gt; upper[<span class="number">0</span>] &amp;&amp; lower[<span class="number">1</span>] &gt; upper[<span class="number">1</span>] &amp;&amp; lower[<span class="number">2</span>] &gt; upper[<span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-08-14-Boolean-Evaluation"><a href="#LCCI-08-14-Boolean-Evaluation" class="headerlink" title="LCCI.08.14 Boolean Evaluation"></a>LCCI.08.14 Boolean Evaluation</h2><p>题目：</p><blockquote><p>Given a boolean expression consisting of the symbols 0 (false), 1 (true), &amp; (AND), | (OR), and ^ (XOR), and a desired boolean result value result, implement a function to count the number of ways of parenthesizing the expression such that it evaluates to result.</p></blockquote><p>这题参考题解，并对照着花花的1.4类型的动态规划解出来的，对动态规划有了更深的认识了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countEval</span><span class="params">(String s, <span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//区间长度，至少新增2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; len += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + len - <span class="number">1</span> &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][i + len - <span class="number">1</span>][s.charAt(i) == <span class="string">'0'</span> ? <span class="number">0</span> : <span class="number">1</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//遍历子区间的起点和终点，通过操作符分割左右两边。</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; i + len - <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">//第j位是分隔符的位置</span></span><br><span class="line">                    <span class="keyword">char</span> op = s.charAt(j);</span><br><span class="line">                    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'&amp;'</span>:</span><br><span class="line">                            <span class="comment">//分割符为 &amp; 时，左边为0，则右边为0或1均可</span></span><br><span class="line">                            dp[i][i + len - <span class="number">1</span>][<span class="number">0</span>] += dp[i][j - <span class="number">1</span>][<span class="number">0</span>] * (dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">0</span>] + dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">1</span>]) +</span><br><span class="line">                                    <span class="comment">//左边为1，则右边必须为0</span></span><br><span class="line">                                    dp[i][j - <span class="number">1</span>][<span class="number">1</span>] * dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                            dp[i][i + len - <span class="number">1</span>][<span class="number">1</span>] += dp[i][j - <span class="number">1</span>][<span class="number">1</span>] * dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'|'</span>:</span><br><span class="line">                            dp[i][i + len - <span class="number">1</span>][<span class="number">0</span>] += dp[i][j - <span class="number">1</span>][<span class="number">0</span>] * dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                            dp[i][i + len - <span class="number">1</span>][<span class="number">1</span>] += dp[i][j - <span class="number">1</span>][<span class="number">1</span>] * (dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">0</span>] + dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">1</span>]) +</span><br><span class="line">                                    dp[i][j - <span class="number">1</span>][<span class="number">0</span>] * dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'^'</span>:</span><br><span class="line">                            dp[i][i + len - <span class="number">1</span>][<span class="number">0</span>] += dp[i][j - <span class="number">1</span>][<span class="number">0</span>] * dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">0</span>] +</span><br><span class="line">                                    dp[i][j - <span class="number">1</span>][<span class="number">1</span>] * dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                            dp[i][i + len - <span class="number">1</span>][<span class="number">1</span>] += dp[i][j - <span class="number">1</span>][<span class="number">0</span>] * dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">1</span>] +</span><br><span class="line">                                    dp[i][j - <span class="number">1</span>][<span class="number">1</span>] * dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>][result];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-10-01-Sorted-Merge"><a href="#LCCI-10-01-Sorted-Merge" class="headerlink" title="LCCI.10.01 Sorted Merge"></a>LCCI.10.01 Sorted Merge</h2><p>题目：</p><blockquote><p>You are given two sorted arrays, A and B, where A has a large enough buffer at the end to hold B. Write a method to merge B into A in sorted order.</p><p>Initially the number of elements in A and B are m and n respectively.</p></blockquote><p>这题我的思路比较粗暴简单，直接把B的数据放到A的后面，然后用快排来做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span>[] B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(B, <span class="number">0</span>, A, m, n);</span><br><span class="line">    quickSort(A, <span class="number">0</span>, m + n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pivot = array[end];</span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; end; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &lt; pivot) &#123;</span><br><span class="line">            swap(array,j,i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(array,i,end);</span><br><span class="line">    quickSort(array,start,i-<span class="number">1</span>);</span><br><span class="line">    quickSort(array,i+<span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> src, <span class="keyword">int</span> dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = A[src];</span><br><span class="line">    A[src] = A[dest];</span><br><span class="line">    A[dest] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-10-02-Group-Anagrams"><a href="#LCCI-10-02-Group-Anagrams" class="headerlink" title="LCCI.10.02 Group Anagrams"></a>LCCI.10.02 Group Anagrams</h2><p>题目：</p><blockquote><p>Write a method to sort an array of strings so that all the anagrams are in the same group.</p></blockquote><p>这题的难点有两个，一个是如何识别异位词，另个是处理整个数组中所有相同异位词的不同字符。采取了类似桶排序的思想：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; lengthStr = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        List&lt;String&gt; strings = lengthStr.computeIfAbsent(sortString(str), (k) -&gt; &#123;</span><br><span class="line">            List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            res.add(temp);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;);</span><br><span class="line">        strings.add(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">sortString</span><span class="params">(String orig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = orig.toCharArray();</span><br><span class="line">    Arrays.sort(chars);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-10-03-Search-Rotate-Array"><a href="#LCCI-10-03-Search-Rotate-Array" class="headerlink" title="LCCI.10.03 Search Rotate Array"></a>LCCI.10.03 Search Rotate Array</h2><p>题目：</p><blockquote><p>Given a sorted array of n integers that has been rotated an unknown number of times, write code to find an element in the array. You may assume that the array was originally sorted in increasing order. If there are more than one target elements in the array, return the smallest index.</p></blockquote><p>这题因为有一个迷惑，就是数组的翻转次数，其实无论数组翻转了多少次。最终只有一个乱序的区间。因此可以使用二分法，但是需要仔细的区分每种情况，在每个区间内做好判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &lt; arr[right]) &#123;</span><br><span class="line">                <span class="comment">//从mid至right之间是递增的</span></span><br><span class="line">                <span class="keyword">if</span> (arr[mid] &lt; target &amp;&amp; arr[right] &gt;= target &amp;&amp; target != arr[left]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;<span class="comment">//下一次从[mid+1,right]中查找</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid;<span class="comment">//下一次从[left，mid]中查找</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; arr[right]) &#123;</span><br><span class="line">                <span class="comment">//从left到mid之间是递增的</span></span><br><span class="line">                <span class="keyword">if</span> (arr[left] &lt;= target &amp;&amp; arr[mid] &gt;= target) &#123;</span><br><span class="line">                    right = mid;<span class="comment">//下一次从[left,mid]中查找</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;<span class="comment">//下一次从[mid+1,right]中查找</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//arr[mid] == arr[right]</span></span><br><span class="line">                <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right--;<span class="comment">//下一轮从 [left,right-1]</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[left] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-10-05-Sparse-Array-Search"><a href="#LCCI-10-05-Sparse-Array-Search" class="headerlink" title="LCCI.10.05 Sparse Array Search"></a>LCCI.10.05 Sparse Array Search</h2><p>题目：</p><blockquote><p>Given a sorted array of strings that is interspersed with empty strings, write a method to find the location of a given string.</p></blockquote><p>这题主要思想在于使用二分查找时，需要过滤空字符串，左右边界点和mid点都可能会遇到空字符串，因此需要把它给滤掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findString</span><span class="params">(String[] words, String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = words.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (words[left].equals(<span class="string">""</span>)) left++;</span><br><span class="line">        <span class="keyword">while</span> (words[right].equals(<span class="string">""</span>)) right--;</span><br><span class="line">        <span class="keyword">while</span> (words[mid].equals(<span class="string">""</span>) &amp;&amp; mid &lt; right) mid++;</span><br><span class="line">        <span class="keyword">if</span> (words[mid].equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            right = ((left + right) &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (words[mid].compareTo(s) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (words[mid].compareTo(s) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-10-09-Sorted-Matrix-Search"><a href="#LCCI-10-09-Sorted-Matrix-Search" class="headerlink" title="LCCI.10.09 Sorted Matrix Search"></a>LCCI.10.09 Sorted Matrix Search</h2><p>题目：</p><blockquote><p>Given an M x N matrix in which each row and each column is sorted in ascending order, write a method to find an element.</p></blockquote><p>这题我采用了对矩阵的每一行进行二分查找的方法来实现对整个数组的搜索：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> column = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (row &lt;= matrix.length - <span class="number">1</span> &amp;&amp; column &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (matrix[row][column] &gt; target) &#123;</span><br><span class="line">               column--;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][column] &lt; target) &#123;</span><br><span class="line">               row++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-10-11-Peaks-and-Valleys"><a href="#LCCI-10-11-Peaks-and-Valleys" class="headerlink" title="LCCI.10.11 Peaks and Valleys"></a>LCCI.10.11 Peaks and Valleys</h2><p>题目：</p><blockquote><p>In an array of integers, a “peak” is an element which is greater than or equal to the adjacent integers and a “valley” is an element which is less than or equal to the adjacent inte­gers. For example, in the array {5, 8, 6, 2, 3, 4, 6}, {8, 6} are peaks and {5, 2} are valleys. Given an array of integers, sort the array into an alternating sequence of peaks and valleys.</p></blockquote><p>这题的解法我看了提示才做出来，先将数组排序，再将排序好的数组按照峰谷位置进行交换。将前半段的峰位换到后半段的谷位上即可，需要注意的是处理中间位的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> mid = nums.length / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//排好序之后，将前半段的峰位与后半段的谷位进行交换即可得到峰-谷交错的序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mid &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//当中间位是偶数时，那么后半段的谷位从mid+1开始，如[1,2,3,4]的mid是2，下标为2的数字是3，后半段的谷位开始是第2+1位=4</span></span><br><span class="line">            swapab(nums, i, i + mid + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当中间位是奇数时，那么后半段的谷位从mid开始，如[1,2,3,4,5,6]的mid是3，下标为3的数字是4，后半段的谷位开始是第3位=4</span></span><br><span class="line">            swapab(nums, i, i + mid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapab</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[a];</span><br><span class="line">    nums[a] = nums[b];</span><br><span class="line">    nums[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-16-01-Swap-Numbers"><a href="#LCCI-16-01-Swap-Numbers" class="headerlink" title="LCCI.16.01 Swap Numbers"></a>LCCI.16.01 Swap Numbers</h2><p>题目：</p><blockquote><p>Write a function to swap a number in place (that is, without temporary vari­ ables).</p></blockquote><p>题目要求不使用额外的变量来实现两个数字的交换，因此我的第一反应是使用异或来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] swapNumbers(<span class="keyword">int</span>[] numbers) &#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers[<span class="number">0</span>] == numbers[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> numbers;</span><br><span class="line">    &#125;</span><br><span class="line">    numbers[<span class="number">0</span>] = numbers[<span class="number">0</span>] ^ numbers[<span class="number">1</span>];</span><br><span class="line">    numbers[<span class="number">1</span>] = numbers[<span class="number">0</span>] ^ numbers[<span class="number">1</span>];</span><br><span class="line">    numbers[<span class="number">0</span>] = numbers[<span class="number">0</span>] ^ numbers[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> numbers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-16-04-Tic-Tac-Toe"><a href="#LCCI-16-04-Tic-Tac-Toe" class="headerlink" title="LCCI.16.04 Tic-Tac-Toe"></a>LCCI.16.04 Tic-Tac-Toe</h2><p>题目：</p><blockquote><p>Design an algorithm to figure out if someone has won a game of tic-tac-toe. Input is a string array of size N x N, including characters “ “, “X” and “O”, where “ “ represents a empty grid.</p><p>The rules of tic-tac-toe are as follows:</p><ul><li><p>Players place characters into an empty grid(“ “) in turn.</p></li><li><p>The first player always place character “O”, and the second one place “X”.</p></li><li><p>Players are only allowed to place characters in empty grid. Replacing a character is not allowed.</p></li><li><p>If there is any row, column or diagonal filled with N same characters, the game ends. The player who place the last charater wins.</p></li><li><p>When there is no empty grid, the game ends.</p></li><li><p>If the game ends, players cannot place any character further.</p></li></ul><p>If there is any winner, return the character that the winner used. If there’s a draw, return “Draw”. If the game doesn’t end and there is no winner, return “Pending”.</p></blockquote><p>这题其实比较简单，一开始我想通过动态规划来做，后来发现无法使用动态规划，因为这个不是路径问题。采用简单的分类讨论，注意下循环的细节处理就好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">tictactoe</span><span class="params">(String[] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有玩家获胜</span></span><br><span class="line">        <span class="keyword">boolean</span> hasEmpty = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> hasWon = <span class="keyword">false</span>;</span><br><span class="line">        String res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> rowCheck = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">char</span> rowChar = board[i].charAt(<span class="number">0</span>);</span><br><span class="line">            res = String.valueOf(rowChar);</span><br><span class="line">            <span class="keyword">if</span> (rowChar == <span class="string">' '</span>) &#123;</span><br><span class="line">                hasEmpty = <span class="keyword">true</span>;</span><br><span class="line">                rowCheck = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i].charAt(j) == <span class="string">' '</span>) &#123;</span><br><span class="line">                    hasEmpty = <span class="keyword">true</span>;</span><br><span class="line">                    rowCheck = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rowChar != board[i].charAt(j)) &#123;</span><br><span class="line">                    rowCheck = <span class="keyword">false</span>;<span class="comment">//横向检查失败</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rowCheck) &#123;</span><br><span class="line">                hasWon = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hasWon) &#123;</span><br><span class="line">            <span class="comment">//纵向检查</span></span><br><span class="line">            String fRow = board[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fRow.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> cloumnCheck = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">char</span> charCon = fRow.charAt(i);</span><br><span class="line">                res = String.valueOf(charCon);</span><br><span class="line">                <span class="keyword">if</span> (charCon == <span class="string">' '</span>) &#123;</span><br><span class="line">                    hasEmpty = <span class="keyword">true</span>;</span><br><span class="line">                    cloumnCheck = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//纵向检查</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; board.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (board[j].charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                        cloumnCheck = <span class="keyword">false</span>;</span><br><span class="line">                        hasEmpty = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (charCon != board[j].charAt(i)) &#123;</span><br><span class="line">                        cloumnCheck = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cloumnCheck) &#123;</span><br><span class="line">                    hasWon = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!hasWon) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> diaglonCheck = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">char</span> charConStart = board[<span class="number">0</span>].charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">char</span> charConEnd = board[<span class="number">0</span>].charAt(board.length - <span class="number">1</span>);</span><br><span class="line">            res = String.valueOf(charConStart);</span><br><span class="line">            <span class="keyword">if</span> (charConStart == <span class="string">' '</span>) &#123;</span><br><span class="line">                hasEmpty = <span class="keyword">true</span>;</span><br><span class="line">                diaglonCheck = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">                <span class="comment">//对角线检查</span></span><br><span class="line">                <span class="keyword">if</span> (board[i].charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                    diaglonCheck = <span class="keyword">false</span>;</span><br><span class="line">                    hasEmpty = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (charConStart != board[i].charAt(i)) &#123;</span><br><span class="line">                    diaglonCheck = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (diaglonCheck) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">boolean</span> rightDiaglonCheck = <span class="keyword">true</span>;</span><br><span class="line">            res = String.valueOf(charConEnd);</span><br><span class="line">            <span class="keyword">if</span> (charConEnd == <span class="string">' '</span>) &#123;</span><br><span class="line">                hasEmpty = <span class="keyword">true</span>;</span><br><span class="line">                rightDiaglonCheck = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">                <span class="comment">//对角线检查</span></span><br><span class="line">                <span class="keyword">if</span> (board[i].charAt(board.length - <span class="number">1</span> - i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                    rightDiaglonCheck = <span class="keyword">false</span>;</span><br><span class="line">                    hasEmpty = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (charConEnd != board[i].charAt(board.length - <span class="number">1</span> - i)) &#123;</span><br><span class="line">                    rightDiaglonCheck = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rightDiaglonCheck) <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasWon) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasEmpty) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Pending"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Draw"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-16-05-Factorial-Zeros"><a href="#LCCI-16-05-Factorial-Zeros" class="headerlink" title="LCCI.16.05 Factorial Zeros"></a>LCCI.16.05 Factorial Zeros</h2><p>题目：</p><blockquote><p> Write an algorithm which computes the number of trailing zeros in n factorial.</p></blockquote><p>这题的主要思路是找出阶乘中的5的倍数有几个。如果遍历阶乘中的每个数来找则会超时，题目要求使时间复杂度达到O(logn)。因此，需要使用对5取整的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        count += n / <span class="number">5</span>;</span><br><span class="line">        n = n / <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-16-06-Smallest-Difference"><a href="#LCCI-16-06-Smallest-Difference" class="headerlink" title="LCCI.16.06 Smallest Difference"></a>LCCI.16.06 Smallest Difference</h2><p>题目：</p><blockquote><p>Given two arrays of integers, compute the pair of values (one value in each array) with the smallest (non-negative) difference. Return the difference.</p></blockquote><p>这题我只想到了排序，并没有想到双指针的算法，看了题解后才知道可以通过双指针逼近的方法来求解。此题有一点需要注意，就是当int中的数为int的最小值时，通过<code>Math.abs</code>取绝对值会溢出。在jdk中<code>Math.abs</code>方法是这么实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">abs</span><span class="params">(<span class="keyword">long</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &lt; <span class="number">0</span>) ? -a : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此需要使用long型来存储俩数之间的差，在相减之后对int数据进行强转，即可避免数据溢出的问题。同时由于方法的返回值是int，所以只需要在最后方法返回时，将最小值强转会int型即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestDifference</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">     Arrays.sort(a);</span><br><span class="line">     Arrays.sort(b);</span><br><span class="line">     <span class="keyword">long</span> min = Integer.MAX_VALUE;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (i &lt; a.length &amp;&amp; j &lt; b.length) &#123;</span><br><span class="line">         <span class="keyword">if</span> (Math.abs((<span class="keyword">long</span>)a[i] - (<span class="keyword">long</span>) b[j]) &lt; min) &#123;</span><br><span class="line">             min = Math.abs((<span class="keyword">long</span>)a[i] - (<span class="keyword">long</span>) b[j]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (a[i] &gt; b[j]) &#123;</span><br><span class="line">             j++;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             i++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">int</span>)min;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-16-07-Maximum"><a href="#LCCI-16-07-Maximum" class="headerlink" title="LCCI.16.07 Maximum"></a>LCCI.16.07 Maximum</h2><p>题目：</p><blockquote><p>Write a method that finds the maximum of two numbers. You should not use if-else or any other comparison operator.</p></blockquote><p>这题的主要思想在于，当不允许使用比较运算符和if-else时，可以通过将大数乘以1+小数乘以0的方式来返回最终的值。如果a和b是相同符好的数，则可以通过判断a-b的符号位来判断两个数的大小。将a乘以符号位，b乘以符号位的相反即可。</p><p>但是当符合位不同时，则需要对其进行特殊的处理。可以先取出a的符号位和b的符号位，再将两个数进行异或，为1说明符合位不同，为0说明符合位相同。那么当为0时，之间按照上述处理即可。为1时，则返回a乘以a的符号位加上b乘以b的符号位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> signa = sign(a);</span><br><span class="line">        <span class="keyword">int</span> signb = sign(b);</span><br><span class="line">        <span class="keyword">int</span> signc = sign(a - b);</span><br><span class="line">        <span class="keyword">int</span> same_sign_a = signa ^ signb;<span class="comment">//a,b符合相同为0  符号不同为1</span></span><br><span class="line">        <span class="keyword">int</span> same_sign_c = flip(same_sign_a);<span class="comment">//same_sign_a 的反向数</span></span><br><span class="line">        <span class="keyword">int</span> k = same_sign_a * signa + same_sign_c * signc;<span class="comment">//符合相同为signc，不同为signa</span></span><br><span class="line">        <span class="keyword">int</span> q = flip(k);</span><br><span class="line">        <span class="keyword">return</span> a * k + b * q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//翻转符号位</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">flip</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a ^ <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//负数返回0 正数返回a</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sign</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flip((a &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x01</span>);<span class="comment">//此处使用算术右移必须与0x01做与运算，不能与1做与运算</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-16-09-Operations"><a href="#LCCI-16-09-Operations" class="headerlink" title="LCCI.16.09 Operations"></a>LCCI.16.09 Operations</h2><p>题目：</p><blockquote><p>write methods to implement the multiply, subtract, and divide operations for integers. The results of all of these are integers. Use only the add operator.</p></blockquote><p>此题的解法与书本上不同，因为整数的最大和最小值很容易在LeetCode上跑超时，因此可采用二分法来做。减法用的是<code>a+-b</code>来实现。乘法使用二分累加即可。除法比较困难，参考题解后，采用的是32位数组来实现的每一位指数递增，详见解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + (-b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sameSign = ((a &gt;&gt; <span class="number">31</span>) ^ (b &gt;&gt; <span class="number">31</span>)) &amp; <span class="number">1</span>;<span class="comment">//符号位相同为0，相异为1</span></span><br><span class="line">        <span class="keyword">long</span> absA = Math.abs((<span class="keyword">long</span>) a) &lt; Math.abs((<span class="keyword">long</span>) b) ? Math.abs((<span class="keyword">long</span>) a) : Math.abs((<span class="keyword">long</span>) b);</span><br><span class="line">        <span class="keyword">long</span> absB = Math.abs((<span class="keyword">long</span>) a) &lt; Math.abs((<span class="keyword">long</span>) b) ? Math.abs((<span class="keyword">long</span>) b) : Math.abs((<span class="keyword">long</span>) a);</span><br><span class="line">        <span class="keyword">long</span> res = absB;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (absA &gt; temp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (absA &gt; temp + temp) &#123;</span><br><span class="line">                res += res;</span><br><span class="line">                temp += temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += absB;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sameSign == <span class="number">0</span> ? (<span class="keyword">int</span>) res : (<span class="keyword">int</span>) -res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0x80000000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sameSign = ((a &gt;&gt; <span class="number">31</span>) ^ (b &gt;&gt; <span class="number">31</span>)) &amp; <span class="number">1</span>;<span class="comment">//符号位相同为0，相异为1</span></span><br><span class="line">        <span class="keyword">int</span> absA = Math.abs(a);</span><br><span class="line">        <span class="keyword">int</span> absB = Math.abs(b);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">int</span>[] bit = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        temp[<span class="number">0</span>] = absB;</span><br><span class="line">        bit[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp[i - <span class="number">1</span>] + temp[i - <span class="number">1</span>] &gt; absA || temp[i - <span class="number">1</span>] + temp[i - <span class="number">1</span>] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            temp[i] = temp[i - <span class="number">1</span>] + temp[i - <span class="number">1</span>];</span><br><span class="line">            bit[i] = bit[i - <span class="number">1</span>] + bit[i - <span class="number">1</span>];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (absA &gt;= temp[i]) &#123;</span><br><span class="line">                absA = minus(absA, temp[i]);</span><br><span class="line">                res += bit[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sameSign == <span class="number">0</span> ? res : -res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-16-10-Living-People"><a href="#LCCI-16-10-Living-People" class="headerlink" title="LCCI.16.10 Living People"></a>LCCI.16.10 Living People</h2><p>题目：</p><blockquote><p>Given a list of people with their birth and death years, implement a method to compute the year with the most number of people alive. You may assume that all people were born between 1900 and 2000 (inclusive). If a person was alive during any portion of that year, they should be included in that year’s count. For example, Person (birth= 1908, death= 1909) is included in the counts for both 1908 and 1909.</p><p>If there are more than one years that have the most number of people alive, return the smallest one.</p></blockquote><p>这题我的思路是用双指针解法，但是一开始没有考虑到排序。具体解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAliveYear</span><span class="params">(<span class="keyword">int</span>[] birth, <span class="keyword">int</span>[] death)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(birth);</span><br><span class="line">        Arrays.sort(death);</span><br><span class="line">        <span class="keyword">int</span> length = birth.length;</span><br><span class="line">        <span class="keyword">int</span> maxLivedYear = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> aliveCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> birthCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> deathCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (birth[i] &lt;= death[j]) &#123;</span><br><span class="line">                birthCount++;</span><br><span class="line">                <span class="keyword">if</span> (birthCount - deathCount &gt; aliveCount) &#123;</span><br><span class="line">                    aliveCount= birthCount-deathCount;</span><br><span class="line">                    maxLivedYear = birth[i];</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (birthCount - deathCount &gt; aliveCount) &#123;</span><br><span class="line">                    aliveCount= birthCount-deathCount;</span><br><span class="line">                    maxLivedYear = death[j];</span><br><span class="line">                &#125;</span><br><span class="line">                deathCount++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLivedYear;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-16-11-Diving-Board"><a href="#LCCI-16-11-Diving-Board" class="headerlink" title="LCCI.16.11 Diving Board"></a>LCCI.16.11 Diving Board</h2><p>题目：</p><blockquote><p>You are building a diving board by placing a bunch of planks of wood end-to-end. There are two types of planks, one of length shorter and one of length longer. You must use exactly K planks of wood. Write a method to generate all possible lengths for the diving board.</p><p>return all lengths in non-decreasing order.</p></blockquote><p>这题的思路是，因为必须要使用k个木板，所以从k个全是最短的木板，然后逐一新增长的木板开始计算总长度必然是递增的。只是需要注意处理下shoter与longer相等的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] divingBoard(<span class="keyword">int</span> shorter, <span class="keyword">int</span> longer, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shorter == longer) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;shorter * k&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        ans[i] = shorter * (k - i) + longer * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-16-13-Bisect-Squares"><a href="#LCCI-16-13-Bisect-Squares" class="headerlink" title="LCCI.16.13 Bisect Squares"></a>LCCI.16.13 Bisect Squares</h2><p>题目：</p><blockquote><p>Given two squares on a two-dimensional plane, find a line that would cut these two squares in half. Assume that the top and the bottom sides of the square run parallel to the x-axis.</p><p>Each square consists of three values, the coordinate of bottom left corner [X,Y] = [square[0],square[1]], and the side length of the square square[2]. The line will intersect to the two squares in four points. Return the coordinates of two intersection points [X1,Y1] and [X2,Y2] that the forming segment covers the other two intersection points in format of {X1,Y1,X2,Y2}. If X1 != X2, there should be X1 &lt; X2, otherwise there should be Y1 &lt;= Y2.</p><p>If there are more than one line that can cut these two squares in half, return the one that has biggest slope (slope of a line parallel to the y-axis is considered as infinity).</p></blockquote><p>这题的难点有三个，一个是分析清楚，平分两个正方形的直线应该是两个正方形中心点的连线。第二点是需要知道斜率方程式：<code>y=kx+b</code>，计算每个点的值时需要加上截距<code>b</code>。第三点是，在计算最终的结果时，需要区分一些细节，这考验的是编码能力。边界重合的情况。最简单的做法应该是参照题解那样将几个交点列出来，取出最大最小值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">double</span>[] cutSquares(<span class="keyword">int</span>[] square1, <span class="keyword">int</span>[] square2) &#123;</span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span> x1 = square1[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> x2 = square2[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y1 = square1[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> y2 = square2[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> center1x = (x1 + x1 + square1[<span class="number">2</span>]) / <span class="number">2</span>d;</span><br><span class="line">        <span class="keyword">double</span> center1y = (y1 + y1 + square1[<span class="number">2</span>]) / <span class="number">2</span>d;</span><br><span class="line">        <span class="keyword">double</span> center2x = (x2 + x2 + square2[<span class="number">2</span>]) / <span class="number">2</span>d;</span><br><span class="line">        <span class="keyword">double</span> center2y = (y2 + y2 + square2[<span class="number">2</span>]) / <span class="number">2</span>d;</span><br><span class="line">        <span class="keyword">if</span> (center1x == center2x) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = center1x;</span><br><span class="line">            res[<span class="number">1</span>] = y1 &lt; y2 ? y1 : y2;</span><br><span class="line">            res[<span class="number">2</span>] = center2x;</span><br><span class="line">            res[<span class="number">3</span>] = y1 + square1[<span class="number">2</span>] &lt; y2 + square2[<span class="number">2</span>] ? y2 + square2[<span class="number">2</span>] : y1 + square1[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (center1y == center2y) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = x1 &lt; x2 ? x1 : x2;</span><br><span class="line">            res[<span class="number">1</span>] = center1y;</span><br><span class="line">            res[<span class="number">2</span>] = x1 + square1[<span class="number">2</span>] &lt; x2 + square2[<span class="number">2</span>] ? x2 + square2[<span class="number">2</span>] : x1 + square1[<span class="number">2</span>];</span><br><span class="line">            res[<span class="number">3</span>] = center2y;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//斜率</span></span><br><span class="line">        <span class="keyword">double</span> rate = (center2y - center1y) / (center2x - center1x);</span><br><span class="line">        <span class="comment">//截距</span></span><br><span class="line">        <span class="keyword">double</span> dis = center1y - rate * center1x;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(rate) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//交点在上下边</span></span><br><span class="line">            <span class="keyword">int</span> bottomy = y1 &lt; y2 ? y1 : y2;</span><br><span class="line">            <span class="keyword">int</span> topy = y1 + square1[<span class="number">2</span>] &lt; y2 + square2[<span class="number">2</span>] ? y2 + square2[<span class="number">2</span>] : y1 + square1[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">double</span> bottomx = bottomy / rate;</span><br><span class="line">            <span class="keyword">double</span> topx = topy / rate;</span><br><span class="line">            <span class="comment">//point1：(y1+square[2]-dis)/rate , y1+square1[2]   ponit2:(y1-dis)/rate ,y1</span></span><br><span class="line">            <span class="comment">//point3: (y2+square2[2]-dis)/rate ,y2+square2[2]   point4:(y2-dis)/rate ,y2</span></span><br><span class="line">            res[<span class="number">0</span>] = Math.min(Math.min((y1+square1[<span class="number">2</span>]-dis)/rate,(y1-dis)/rate),Math.min((y2+square2[<span class="number">2</span>]-dis)/rate,(y2-dis)/rate));</span><br><span class="line">            res[<span class="number">1</span>] = res[<span class="number">0</span>] * rate + dis;</span><br><span class="line">            res[<span class="number">2</span>] = Math.max(Math.max((y1+square1[<span class="number">2</span>]-dis)/rate,(y1-dis)/rate),Math.max((y2+square2[<span class="number">2</span>]-dis)/rate,(y2-dis)/rate));</span><br><span class="line">            res[<span class="number">3</span>] = res[<span class="number">2</span>] * rate + dis;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//交点在左右两边</span></span><br><span class="line">            <span class="keyword">int</span> leftx = x1 &lt; x2 ? x1 : x2;</span><br><span class="line">            <span class="keyword">int</span> rightx = x1 + square1[<span class="number">2</span>] &lt; x2 + square2[<span class="number">2</span>] ? x2 + square2[<span class="number">2</span>] : x1 + square1[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">double</span> topy = leftx * rate;</span><br><span class="line">            <span class="keyword">double</span> bottomy = rightx * rate;</span><br><span class="line">            res[<span class="number">0</span>] = leftx;</span><br><span class="line">            res[<span class="number">1</span>] = topy + dis;</span><br><span class="line">            res[<span class="number">2</span>] = rightx;</span><br><span class="line">            res[<span class="number">3</span>] = bottomy + dis;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h2><p>题目：</p><blockquote><p>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p><p>The same repeated number may be chosen from candidates unlimited number of times.</p><p>Note:</p><p>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.</p></blockquote><p>这题可以采用树的dfs来做，需要注意一点的是，在递归遍历的时候需要做去重。因为是结果取得是组合，而不是排列。同时，可以通过一些条件来实现剪枝处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfsCombination(candidates, target, <span class="number">0</span>, <span class="keyword">new</span> LinkedList&lt;&gt;(), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfsCombination</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start, LinkedList&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(current));<span class="comment">//current对象需要不断被修改，因此需要复制一份</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> currValue = candidates[i];</span><br><span class="line">            <span class="keyword">if</span> (currValue &gt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//由于前面未对数组进行排序，所以此处当发现值大于目标时直接跳过。 剪枝处理</span></span><br><span class="line">            &#125;</span><br><span class="line">            current.push(currValue);</span><br><span class="line">            <span class="comment">//由于可以使用重复的数字所以下次的循环起点可以从i开始</span></span><br><span class="line">            dfsCombination(candidates, target - currValue, i, current, res);</span><br><span class="line">            current.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="784-Letter-Case-Permutation"><a href="#784-Letter-Case-Permutation" class="headerlink" title="784 Letter Case Permutation"></a>784 Letter Case Permutation</h2><p>题目：</p><blockquote><p>Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string.  Return a list of all possible strings we could create</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfsLetterPermutation(res, <span class="number">0</span>, S.length(), S, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfsLetterPermutation</span><span class="params">(List&lt;String&gt; res, <span class="keyword">int</span> start, <span class="keyword">int</span> length, String S, StringBuilder currentString)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == length) &#123;</span><br><span class="line">            res.add(currentString.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> cur = S.charAt(start);</span><br><span class="line">        currentString.append(cur);</span><br><span class="line">        dfsLetterPermutation(res, start + <span class="number">1</span>, length, S, currentString);</span><br><span class="line">        <span class="keyword">if</span> (!Character.isDigit(cur)) &#123;</span><br><span class="line">            currentString.setLength(start);</span><br><span class="line">            currentString.append(Character.isUpperCase(cur) ? Character.toLowerCase(cur) : Character.toUpperCase(cur));</span><br><span class="line">            dfsLetterPermutation(res, start + <span class="number">1</span>, length, S, currentString);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这题需要注意的是，stringbuilder可以使用<code>setLength</code>方法实现截断到指定长度，这样可以降低时间复杂度。</p><p>在字符的时候比数字多走一个分支，反转大小写之后即可。同时反转大小写有个很好的写法是使用异或：<code>S.charAt[i]^(1&lt;&lt;5)</code>，因为大写字母与小写字母的ASCII码之间相距32，即2的6次方。因此可以用异或来每次将该位取反，即得到了相反的大小写。</p><h2 id="模板总结"><a href="#模板总结" class="headerlink" title="模板总结"></a>模板总结</h2><h3 id="DFS求排列组合问题"><a href="#DFS求排列组合问题" class="headerlink" title="DFS求排列组合问题"></a>DFS求排列组合问题</h3><ul><li><p>搜索求排列和组合的时候，可以考虑使用dfs的模板套路来做：</p><p><img src="/2020/04/21/LeetCode/LeetCode/模板.png" alt=""></p><p>排列的时间复杂度通常为O(每个答案时间*答案个数，常为n!)，空间复杂度为O(n).</p><p>组合的时间复杂度通常为O(每个答案的时间* 答案个数，常为)，空间复杂度为O(n).</p></li><li><p>关于有重复数字的去重：</p><p><img src="/2020/04/21/LeetCode/LeetCode/排列组合.jpg" alt=""></p></li></ul><h3 id="二分查找类问题"><a href="#二分查找类问题" class="headerlink" title="二分查找类问题"></a>二分查找类问题</h3><ul><li><p>二分法的三种类型模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">查找到一个数： </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="comment">// 直接返回</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接返回</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">查找到最左边一个数问题：</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123; </span><br><span class="line">            <span class="comment">// 保持左边界不动，收缩右边界</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后要检查 left 越界的情况</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">查找到最右边一个数问题：</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="comment">// 保持右边界不动，收缩左边界</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后要检查 right 越界的情况</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>上述三个模板，<strong>在<code>while</code>条件处均采用<code>left&lt;=right</code>这种写法，这种写法需要注意的是，在循环内部不管什么情况下都需要收缩左侧或者右侧边界（因为在找到答案时，一定会出现<code>mid==left==right</code>的情况，此时判断满足条件的情况下若不收缩边界，则会导致死循环）</strong>，因此，需要在跳出循环时判断左右边界是否越界。</p></li><li><p>在二分查找中，若用<code>left&lt;=right</code>条件，则最后的结果一定会是<code>mid==left==right</code>的情况下产生的，所以最后返回的是<code>left</code>还是<code>right</code>就需要判断最后走的是哪个分支（详见162,287,74提交）。</p></li><li><p>在二分查找中，若用<code>left&lt;right</code>条件，则最后结果是<code>right==left</code>，因此返回哪个都一样。</p></li><li><p>若在<code>while</code>循环内部不好找到左右均收缩边界的条件时，则不能再继续使用<code>left&lt;=right</code>的条件，需要灵活变通。</p></li><li><p>如若遇到复杂些的问题时，不建议使用<code>left&lt;=right</code>作为<code>while</code>语句的条件，应当针对实际的二分场景进行区别对待，经常会是使用<code>left&lt;right</code>条件的解法更优，但要注意当使用<code>left&lt;right</code>时，right是没有被包含进检查区间内的，需注意初始化的right值，或者在跳出循环后检查该点。</p></li><li><p>二分法在内部查找时，查找区间一直是左边界指定的，<code>while</code>条件用<code>left&lt;=right</code>时，则查找区间会包含right，否则就不会包含，因此需要注意right的初始化值。</p></li><li><p><strong>注意：在<code>while(left&lt;right)</code>循环条件下，在收缩边界时，切不可使用<code>left=mid</code>这个语句，这个条件会造成死循环。而<code>right=mid</code>则可以使用，因为二分取值时，当right=left+1时，mid的值等于left，此时若使用<code>left=mid</code>则会产生死循环，使用<code>right=mid</code>收缩边界，则会导致<code>left==right</code>条件成立，进而跳出循环。</strong></p></li><li><p>写完二分后，可以通过以下方式校验是否存在死循环以及越界：</p><ul><li>使用<code>while(left&lt;right)</code>条件时，将<code>mid = left = right-1</code>，带入代码判断if条件分支，看是否会存在没有收缩边界的情况，若存在则有死循环。</li><li>使用<code>while(left&lt;=right)</code>条件时，将<code>mid = left = right</code>，带入代码判断if条件分支，看是否会存在没有收缩边界的情况，若存在则有死循环。</li><li>在退出循环后，使用target小于或大于数组内全部数据的情况，带入代码判断是否存在数组越界的情况。</li></ul></li></ul><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><ul><li><p>最重要的是要理解清楚题目的意思！！！</p></li><li><p>当使用异或进行数字交换时需要注意，刚开始的两个引用是否指向的是同个对象，若是同个对象则第一次异或时就会产生错误的结果，导致最终的结果是错误的。</p></li><li><p>字符串的调换位置、去重、判断奇偶操作这种类型的题目可以考虑将采取哈希映射为数组，或者bit位。用位操作来完成最后的识别判断。注意，当有顺序要求，不能去重统计时则不适用于哈希映射法。</p></li><li><p>双指针类问题，需要仔细分清不同 代码分支情况，一条条的梳理清楚。</p></li><li><p>对字符数组遍历，边界问题的测试需要考虑到字符长度为1，为0，遍历到尾部最后一个字符的处理逻辑；可以尝试通过在字符的最后补了一位来规避遍历时处理最后一个字符的特殊情况。</p></li><li><p>链表的删除可以考虑使用后续节点代替当前节点</p></li><li><p>在两个引用指向相同对象的，若想对两个对象内的数值进行互换不能采用异或操作。否则会导致结果为0。</p></li><li><p>遇到栈相关的问题，一般可以考虑使用临时的另一个栈来完成题目对于栈的顺序要求。</p></li><li><p>ArrayList和LinkedList的toArray方法并不能直接转换为数组，否则会报错。可以新建个数组，在使用<code>toArray(新数组)</code>的方法来实现转换为数组。</p></li><li><p>递归可以通过返回特定值来向上传递某种结果退出递归。</p></li><li><p><strong>递归题目，首要条件是要找到基准条件。找到之后可以分为自底向上和自顶而下两种写法，自底向上是将每一层的处理结果返回给上一层处理，每层在调用完递归后处理自己本层逻辑再返回。自顶而下则是先对自己本层的逻辑进行处理，然后再将数据封装到参数中递交给下一层处理。不管是自底向上还是自顶而下，都需要对返回条件进行特殊处理！</strong></p></li><li><p><strong>树的查找类问题，思考方向与递归遍历类似，应该是自顶而下或者自底而上。做优化时可以考虑如何将重复的递归逻辑给进行合并</strong></p></li><li><p>中等难度的问题基本都是将题目分析出来，再将思路编码出来。分析可以由暴力逐步优化，编码能力需要不断刷题实践。</p></li><li><p>当题目给出有序的条件时，这个条件利用好一般会有很好的效果。</p></li><li><p>在递归时，若发现可以缓存的数据，可以想办法通过数组或hash表来进行缓存，当然在缓存的时候也需要考虑内存是否会过大超出限制，这也是实现动态规划的一种方法。</p></li><li><p>递归需要全局的思考，不能陷入追究递归的过程中。</p></li><li><p>需要考虑数据规模，否则有些题目采用递归是无法做出来的，时间会超出限制。</p></li><li><p>二分查找的难点在于需要处理好左右边界点的移动，这涉及到循环打破的条件设置。</p></li><li><p>String 类型的输入需要带入测试<strong>空字符串</strong>的情形。</p></li><li><p>二叉树的遍历问题，一定要带上一个单节点情形的案例去测试。</p></li><li><p>排列问题的去重时，只要带上<code>i &gt; 0 &amp;&amp; str[i] == str[i - 1] &amp;&amp; visited[i - 1] == 0</code>这个条件即可</p></li><li><p>LinkedList的add方法会将数据放在队尾，addFirst()和push()方法会将数据放在队头。removeFirst()，poll()，pollFirst()和pop()方法都会从队列头部取出数据。pollLast()、removeLast()方法会从队尾取出数据。</p></li><li><p>O(1)删除list中的元素：将待删除元素放入队列的尾部，再删除尾部的元素即可。</p></li><li><p><strong>针对每一题都需要思考时间复杂度和空间复杂度</strong></p></li><li><p>关于质数、因数、质因数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">被除数是除数的倍数。</span><br><span class="line">除数是被除数的因数。</span><br><span class="line">将一个合数分成几个质数相乘的形式,这样的几个质数叫做这个合数的质因数。比如6,就可以写成2*3,2和3就是6的质因数，把一个数写成几个质数相乘的形式,就称为分解质因数。</span><br><span class="line">质数=素数，也就是只能够被1和自身整除的数,比如：2,3,5,7之类的。</span><br></pre></td></tr></table></figure></li><li><p>Coding Style 相关:<br>• 二元运算符两边加空格，单元运算符不加空格<br>• 花括号和 for, if 之间要加空格(Java)，圆括号和 if 之间要加空格<br>• 用空行分隔开不同的逻辑块<br>• 逗号后面加空格</p></li><li><p>Readability 相关<br>• 函数名和变量名用1-2个单词作为名称<br>• 确保一个函数内部不超过 3 层缩进（indention）<br>• 多用子函数来减少入口函数的代码量<br>• 多用 continue 少用 if</p></li><li><p>Bug Free 相关<br>• 不管有没有可能出问题，都要对入口函数的参数进行异常检测<br>• 访问一个下标的时候，一定要确保这个下标不会越界<br>• 访问一个对象的属性或者方法时，一定要确保这个对象不是空<br>• 不用全局变量</p></li><li><p>二维数组类的题目，一定要带入只有一个数字的情况进行测试！</p></li><li><p>坐标型dp，需要注意是按照列进行遍历，还是按照行进行遍历！</p></li><li><p><strong>快慢指针，需要快指针从head.next开始，慢指针从head开始</strong>，可以理解为快指针包含的节点数始终是慢节点的两倍。最开始慢指针有1个节点。快指针有2个节点。</p></li><li><p>试图使用Integer.MAX_VALUE这种数字来做特殊情况时，切记需要与面试官商量数据规模。</p></li><li><p>遇到取K个数问题，通常可以考虑下使用最大堆或者最小堆。然后维持堆内的k个元素满足条件，最后再取出K个元素即可。</p></li><li><p><strong>反向思考是极其重要的一种思考方式</strong>，当正向找不到更好的解或者找不出解时，尝试反向的思路。如，在合并两个排序数组的题目中，用反向思路，从大往小开始合并就可以只用O(1)的空间来解决。在前缀和的问题上也是通过反向思路来查找另一部分的值。</p></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode记录总结&quot;&gt;&lt;a href=&quot;#LeetCode记录总结&quot; class=&quot;headerlink&quot; title=&quot;LeetCode记录总结&quot;&gt;&lt;/a&gt;LeetCode记录总结&lt;/h1&gt;&lt;p&gt;本文章主要记录LeetCode刷题学到的知识&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="LEETCODE" scheme="http://yoursite.com/tags/LEETCODE/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search</title>
    <link href="http://yoursite.com/2019/08/03/Binary%20Search/"/>
    <id>http://yoursite.com/2019/08/03/Binary Search/</id>
    <published>2019-08-03T08:28:39.000Z</published>
    <updated>2019-08-04T15:17:31.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h1><p>This is a summary of binary search algorithm.</p><a id="more"></a><h2 id="Item-1-need-find-a-number-is-exactly-equal-to-the-target"><a href="#Item-1-need-find-a-number-is-exactly-equal-to-the-target" class="headerlink" title="Item 1: need find a number is exactly equal to the target"></a>Item 1: need find a number is exactly equal to the target</h2><p>This circumstances we can use this schema:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (s &lt;= e) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (num[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num[mid] &gt; target) &#123;</span><br><span class="line">                e = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num[mid] &lt; target) &#123;</span><br><span class="line">                s = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>the recusive schema:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">recusiveBinarySearch</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (s &gt; e) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> mid = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (num[mid] == target) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num[mid] &gt; target) &#123;</span><br><span class="line">           <span class="keyword">return</span> recusiveBinarySearch(num, s, mid - <span class="number">1</span>, target);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> recusiveBinarySearch(num, mid + <span class="number">1</span>, e, target);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>the break condition is <code>s&gt;e</code>,the expression is <code>f(s-e)=f(s-mid)||f(s-e)=f(mid-e)</code>.</p><h2 id="Item-2-find-first-no-less-than-target"><a href="#Item-2-find-first-no-less-than-target" class="headerlink" title="Item 2: find first no less than target"></a>Item 2: find first no less than target</h2><p>To find no less than target value , we should use following schema:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (s &lt; e) &#123;</span><br><span class="line">           <span class="keyword">int</span> mid = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">               s = mid + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//end point is no less than target(&gt;=target)</span></span><br><span class="line">               e = mid;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> e;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>this shcema need the end point equal to array’s length , when <code>e==length</code> , it indicate the target value is greater than the array’s biggest element. when <code>e==0</code>, it means that the target value is less than the array’s smallest one.</p><p>Besides, this Item have a variant, which is  <strong>find last less than target value</strong>. we can solve this proble by return <code>e-1</code>.Note that </p><h2 id="Item-3-find-first-greater-than-target"><a href="#Item-3-find-first-greater-than-target" class="headerlink" title="Item 3: find first greater than target"></a>Item 3: find first greater than target</h2><p>when you want to find first greater than target value , just change the condition is ok.use <code>nums[mid]&lt;=target</code> ,you can solve this problem.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (s &lt; e) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                s = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//end point is greater than target(&gt;target)</span></span><br><span class="line">                e = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>now, the end point is greater than the target value.if  <code>e == length</code> , then array doesn’t exist a element greater than target.</p><h2 id="Item-4-Use-subfunction-as-the-conditions"><a href="#Item-4-Use-subfunction-as-the-conditions" class="headerlink" title="Item 4: Use subfunction as the conditions"></a>Item 4: Use subfunction as the conditions</h2><h2 id="Citations"><a href="#Citations" class="headerlink" title="Citations"></a>Citations</h2><p><a href="https://www.cnblogs.com/grandyang/p/6854825.html" target="_blank" rel="noopener">LeetCode Binary Search Summary 二分搜索法小结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Binary-Search&quot;&gt;&lt;a href=&quot;#Binary-Search&quot; class=&quot;headerlink&quot; title=&quot;Binary Search&quot;&gt;&lt;/a&gt;Binary Search&lt;/h1&gt;&lt;p&gt;This is a summary of binary search algorithm.&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第十二周</title>
    <link href="http://yoursite.com/2019/07/21/ARTS/ARTS-12/"/>
    <id>http://yoursite.com/2019/07/21/ARTS/ARTS-12/</id>
    <published>2019-07-21T12:28:39.000Z</published>
    <updated>2019-07-21T15:17:13.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第十二周"><a href="#ARTS第十二周" class="headerlink" title="ARTS第十二周"></a>ARTS第十二周</h1><p>本次ARTS主要包括：853题（car fleet）算法题；《effective java》中关于接口应该只被用来定义类型和通过继承来实现标志类，以及关于内部类的使用和类的命名；关于DDIA的部分阅读后真理的脑图。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><ol start="524"><li>car fleet</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">carFleet</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] position, <span class="keyword">int</span>[] speed)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> cars = position.length;</span><br><span class="line">        <span class="keyword">if</span> (cars &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cars;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Double&gt; posiSpeedMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cars; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> distence = target - position[i];</span><br><span class="line">            <span class="keyword">double</span> time =(<span class="keyword">double</span>) distence / (<span class="keyword">double</span>) speed[i] ;</span><br><span class="line">            posiSpeedMap.put(position[i], time);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//from farest to earliest car</span></span><br><span class="line">        Arrays.sort(position);</span><br><span class="line">        <span class="keyword">int</span> res = cars;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cars - <span class="number">1</span>; i &gt;<span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (posiSpeedMap.get(position[i]) &gt;= posiSpeedMap.get(position[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                position[i - <span class="number">1</span>] = position[i];</span><br><span class="line">                res--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这个问题换个角度思考，按照起始位置排列的汽车，远的那辆到达终点的时间比近的那辆到达终点的时间要短的话，那么必然会在途中产生一个fleet。有个需要注意的地方是，在追上前面那辆车之后，车速会被限制跟前车相同，此时则需考虑后车若快于被限制之后的情况。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>continue reading 《effective java》</p><ul><li><p>Item 22: Use interfaces only to define types</p><blockquote><ul><li>When a class implements an interface, the interface serves as a <em>type</em> that can be used to refer to instances of the class. </li><li>The constant interface pattern is a poor use of interfaces.It is of no consequence to the users of a class that the class implements a constant interface. In fact, it may even confuse them. Worse, it represents a commitment: if in a future release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility. If a nonfinal class implements a constant interface, all of its subclasses will have their namespaces polluted by the constants in the interface.</li><li>If you want to export constants, there are several reasonable choices. If the constants are strongly tied to an existing class or interface, you should add them to the class or interface.</li></ul></blockquote></li><li><p>Item 23: Prefer class hierarchies to tagged classes</p><blockquote><ul><li>Tagged classes are verbose, error-prone, and ineficient.</li><li>In summary, tagged classes are seldom appropriate. If you’re tempted to write a class with an explicit tag field, think about whether the tag could be eliminated and the class replaced by a hierarchy. When you encounter an existing class with a tag field, consider refactoring it into a hierarchy.</li></ul></blockquote></li><li><p>Item 24: Favor static member classes over nonstatic</p><blockquote><ul><li>If you declare a member class that does not require access to an enclosing instance, always put the static modifier in its declaration.If you omit this modifier, each instance will have a hidden extraneous reference to its enclosing instance.</li><li>To recap , there are four different kinds of nested classes, and each has its place. If a nested class needs to be visible outside of a single method or is too long to fit comfortably inside a method, use a member class.If each instance of a member class needs a referenece to its enclosing instance, make it nonstatic; otherwise, make it static. Assuming the class belongs inside a method, if you need to create instances from only one location and there is a preexisting type that characterizes the class, make if an anonymous class;otherwise, make it a local class.</li></ul></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>无</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><img src="/2019/07/21/ARTS/ARTS-12/微信截图_20190721231103.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第十二周&quot;&gt;&lt;a href=&quot;#ARTS第十二周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第十二周&quot;&gt;&lt;/a&gt;ARTS第十二周&lt;/h1&gt;&lt;p&gt;本次ARTS主要包括：853题（car fleet）算法题；《effective java》中关于接口应该只被用来定义类型和通过继承来实现标志类，以及关于内部类的使用和类的命名；关于DDIA的部分阅读后真理的脑图。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第十一周</title>
    <link href="http://yoursite.com/2019/06/30/ARTS/ARTS-11/"/>
    <id>http://yoursite.com/2019/06/30/ARTS/ARTS-11/</id>
    <published>2019-06-30T12:28:39.000Z</published>
    <updated>2019-07-14T03:19:32.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第十一周"><a href="#ARTS第十一周" class="headerlink" title="ARTS第十一周"></a>ARTS第十一周</h1><p>本次ARTS主要包括：564题（通过删除匹配到字典里最长的单词）和767题（重构字符串）算法题；《effective java》中关于类的最小可修改和接口优于继承的内容。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><ol start="524"><li>Longest word in Dictionary through Deleting</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length()&lt;=<span class="number">0</span>||d.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(d, <span class="keyword">new</span> compareSpecial());</span><br><span class="line">        <span class="keyword">for</span> (String word : d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSubStr(s,word)) &#123;</span><br><span class="line">                <span class="keyword">return</span> word;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubStr</span><span class="params">(String s, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word==<span class="string">""</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=s.length())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!(s.charAt(j) == word.charAt(i))) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= s.length()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">compareSpecial</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o1.length() &gt; o2.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1.length() == o2.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体的思想是，通过自定义的Comparator实现由大到小先按照字符的长度，再按照字典顺序排序。将整个数组里的字符串都排序好，再遍历给定的字符串s和数组里的单个单词进行字符匹配。</p><blockquote><ol start="767"><li>Reorganize String </li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reorganizeString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = S.length();</span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: S.toCharArray()) counts[c-<span class="string">'a'</span>] += <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) counts[i] += i;</span><br><span class="line">    <span class="comment">//Encoded counts[i] = 100*(actual count) + (i)</span></span><br><span class="line">        Arrays.sort(counts);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] ans = <span class="keyword">new</span> <span class="keyword">char</span>[N];</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> code: counts) &#123;</span><br><span class="line">        <span class="keyword">int</span> ct = code / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = (<span class="keyword">char</span>) (<span class="string">'a'</span> + (code % <span class="number">100</span>));</span><br><span class="line">        <span class="keyword">if</span> (ct &gt; (N+<span class="number">1</span>) / <span class="number">2</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ct; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t &gt;= N) t = <span class="number">0</span>;</span><br><span class="line">            ans[t] = ch;</span><br><span class="line">            t += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一题没做出来，采用的是讨论区一位前辈的思想。大体上运用了计数排序的思想，不过这个解法有两个点很厉害：一是采用乘100，再加上数组下标的方式，来保存排序前每个数组下标的值，方便排序后转换为字符。另一个是采用循环数组的方法将每个字符放到字符串对应的位置上。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>continue reading 《effective java》</p><ul><li><p>Item 19: Design and document for inheritance or else prohibit it</p><blockquote><ul><li>First, the class must document its self-use of override methods;</li><li>a class may have to provide hooks into its internal working in the form of judiciously chosen protected methods;</li><li>The onlt way to test a class designed for inheritance is to write subclasses;</li><li>Constructors must not invoke overridable methods, directly or indirectly;</li><li>Prohibit subclassing in classes that are not designed and documented to be safety subclassed. One way to prohibit subclassing is declare the class final. The Second is make all constructors private or package-private and to add public static factories in place of the constructors.</li></ul></blockquote></li><li><p>Item 20: Prefer interfaces to abstract classes</p><blockquote><ul><li>Existing classes can easily be retrofitted to implement a new interface.</li><li>To summarize, an interface is generally the best way to define a type that permits multiple implementations. If you export a nontrivial interface, you should strongly consider providing a skeletal implementation to go with it. To the extent possible, you should provide the skeletal implementation via default methods on the interface so that all implementors of the interface can make use of it. That said, restrictions on interfaces typically mandate that a skeletal implementation take the form of an abstract class.</li></ul></blockquote></li><li><p>Item 21: Design interface for posterity</p><blockquote><ul><li>Java 8 provide <em>default</em> to allow the addition of  method to  existing interfaces.But it is <strong><em>fraught</em></strong> !</li><li>The declaration for a default method includes a default implementation that is used by all classes that implement the interface but not implement the default method.</li><li>In the presence of default methods, existing implementations of an interface  may compile without error or warning but fail at runtime.</li><li>Using default methods to add new methods should be avoided unless the need is critical, in which case you should think long and hard about whether an existing interface implementation might be broken by your default method implementation.</li><li>It may be possible to correct some interface flaws after an interface is released , But you cannot count on it.</li></ul></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>无</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>无</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第十一周&quot;&gt;&lt;a href=&quot;#ARTS第十一周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第十一周&quot;&gt;&lt;/a&gt;ARTS第十一周&lt;/h1&gt;&lt;p&gt;本次ARTS主要包括：564题（通过删除匹配到字典里最长的单词）和767题（重构字符串）算法题；《effective java》中关于类的最小可修改和接口优于继承的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>RPS曲线制作与使用</title>
    <link href="http://yoursite.com/2019/06/29/%E6%9C%88%E7%BA%BF%E5%8F%8D%E8%BD%AC/"/>
    <id>http://yoursite.com/2019/06/29/月线反转/</id>
    <published>2019-06-29T01:11:23.000Z</published>
    <updated>2019-06-29T02:17:28.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="月线反转的应用"><a href="#月线反转的应用" class="headerlink" title="月线反转的应用"></a>月线反转的应用</h2><ol><li>超长的底部平台+月线反转信号；周线的特征是：股价围绕10周、20周和50周线上下波动。当周线的10周、20周、50周线形成多头排列，是长线牛股的最重要技术特征。买点：超长底部平台后出现月线反转，随后首次到10日线的下方是陶最喜欢的买点。</li><li>月线反转之后出现净利润断层，则应高度重视。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;月线反转的应用&quot;&gt;&lt;a href=&quot;#月线反转的应用&quot; class=&quot;headerlink&quot; title=&quot;月线反转的应用&quot;&gt;&lt;/a&gt;月线反转的应用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;超长的底部平台+月线反转信号；周线的特征是：股价围绕10周、20周和50周线上下波动。当
      
    
    </summary>
    
      <category term="Reading" scheme="http://yoursite.com/categories/Reading/"/>
    
    
      <category term="陶博士2006" scheme="http://yoursite.com/tags/%E9%99%B6%E5%8D%9A%E5%A3%AB2006/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第十周</title>
    <link href="http://yoursite.com/2019/06/19/ARTS/ARTS-10/"/>
    <id>http://yoursite.com/2019/06/19/ARTS/ARTS-10/</id>
    <published>2019-06-19T14:28:39.000Z</published>
    <updated>2019-06-23T08:20:36.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第十周"><a href="#ARTS第十周" class="headerlink" title="ARTS第十周"></a>ARTS第十周</h1><p>本次ARTS主要包括：78题（颜色分类）和179题（最大数）算法题；《effective java》中关于类的最小可修改和接口优于继承的内容；《vim编程技巧》中关于在插入模式即时更正错误操作。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><ol start="78"><li>颜色分类</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        recurisionFastOrder(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recurisionFastOrder</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=end)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pivot =  nums[end];</span><br><span class="line">        <span class="keyword">int</span> i=start;</span><br><span class="line">        <span class="comment">// int j =start;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = start;j&lt;end;j++)&#123;</span><br><span class="line">            <span class="comment">//j指向的数字小于中枢点时 则需要与i交换，同时i往后移，保证从i到j都是大于中枢点的值</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;pivot)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = pivot;</span><br><span class="line">        nums[end] = temp;</span><br><span class="line">        recurisionFastOrder(nums,start,i-<span class="number">1</span>);</span><br><span class="line">        recurisionFastOrder(nums,i+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我得解法与题解给的不同，用的是快排的算法，快排的递推公式为：<code>f(p,r)=f(p,q-1)+f(q+1,r)</code>.其中的q为中枢点。将整个排序的数据分为两部分，[p,q-1]为小于q的部分，[q+1,r]为大于q的部分。剩下的就是确定中枢点的位置了。快排算法是使用两个指针i和j，一个从头开始遍历，当遇到比尾部的值小的时候，则将两个指针的值交换，并将两个指针都往后移一步。这样保持从i到j之间的区间一直都是大于尾部的值的。一次遍历完成后，将i指针的值与尾部的值交换，i点则为中枢点。</p><blockquote><ol start="179"><li>最大数</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(nums[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">int</span>[] res = sort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(res[<span class="number">0</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder re = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;res.length;i++)&#123;</span><br><span class="line">            re.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并排序的递推公式为：A[p,r] = merge(A[p,q],A[q+1,r]);</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> p , <span class="keyword">int</span> r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p&gt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = &#123;nums[r]&#125;;</span><br><span class="line">            <span class="keyword">return</span> temp ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> q = (p+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] a = sort(nums,p,q);</span><br><span class="line">        <span class="keyword">int</span>[] b = sort(nums,q+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">int</span>[] res = merge(a,a.length,b,b.length);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并a，b两个有序数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] a ,<span class="keyword">int</span> m, <span class="keyword">int</span>[] b,<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[m+n];</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m &amp;&amp; j&lt;n)&#123;</span><br><span class="line">            res[k]=compare(a[i],b[j])?a[i++]:b[j++];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;m)&#123;</span><br><span class="line">          System.arraycopy(a,i,res,k,m-i);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;n)&#123;</span><br><span class="line">            System.arraycopy(b,j,res,k,n-j);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义比较大小的规则 x&gt;y return true</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">              StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                sb.append(x).append(y);</span><br><span class="line">        Long a = Long.valueOf(sb.toString());</span><br><span class="line">        </span><br><span class="line">                     StringBuilder sb2 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                sb2.append(y).append(x);</span><br><span class="line">         Long b = Long.valueOf(sb2.toString());</span><br><span class="line">        <span class="keyword">return</span> a&gt;=b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题的核心思想在于自定义排序规则，一开始没想想到，看了题解才知道的。我是故意想着用合并排序的方法来做，练习下写合并排序的代码。合并排序的主要点在于两个：递推公式和合并有序数组；递推公式为：<code>f(p,r)=merge(f(p,q),f(q+1,r))</code>;合并有序数组就比较简单了，类似leetcode第88题的解法。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>continue reading 《effective java》</p><ul><li><p>Item 17：Minimize mutability</p><blockquote><ol><li>To make a class immutable, follow these rules:<ul><li>Don’t provide methods that modify the object’s state .</li><li>Ensure that the class can’t be extended.</li><li>Make all fields private and final.</li><li>Ensure exclusive access to any mutable components.</li></ul></li><li>Immutable objects are inherently thread-safe; they required no synchronization. Besides, they can be shared freely, you never have to make <em>defensive copies</em> of them.</li><li>The major disadvantage of immutable classes is that they require a separate object for each distinct value , even if they are diffrent at one bit.</li><li>To guarantee immutability, instaed of making the class final , you can make all of its constructors private or package-private and  add pbulic static factorices in place of the public constructor.</li><li>To summarize, classes should be immutable unless there’s a compelling reason to make them mutable.<strong><em>Combining this item with item 15, your natural inclination should be to declare every field private final unless there are compelling reson to do otherwise.</em></strong></li></ol></blockquote></li><li><p>Item 18 : Favor composition over inheritance</p><blockquote><ol><li>Inheritance used inappropriately, it leads to fragile software.<strong>Unlike method invocation, inheritance violates encapsulation.</strong> A subclass depends on the implementation detail of its superclass for its proper function. The superclass’s implementation may change from release to release.</li><li>Instead of extending an existing class, give your new class a private field that references an instance of the existing class, give your new class a private field that references an instance of the existing class. This design is called <strong>composition</strong>. This is known as forwarding, and the methods in the new class are known as forwarding methods. This is also known as the <strong><em>Decorator</em></strong> pattern.</li><li>Inheritance is appropriate only in circumstances where the subclass really is a subtype of the superclass.In the other words, a class B should extend a class A only if an “is-a” relationship exists between the two classes.</li></ol></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol><li>在插入模式中，使用如下操作更正错误：</li></ol><p><img src="/2019/06/19/ARTS/ARTS-10/微信截图_20190623160456.png" alt=""></p><ol start="2"><li>在插入模式下，使用<code>ctrl+0</code>，可以将寄存器0中的内容粘贴到文本中。</li><li>使用<code>xp</code>命令可调换光标之后的两个字符；使用<code>ddp</code>命令可调换当前行和它的下一行；</li></ol><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>无</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第十周&quot;&gt;&lt;a href=&quot;#ARTS第十周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第十周&quot;&gt;&lt;/a&gt;ARTS第十周&lt;/h1&gt;&lt;p&gt;本次ARTS主要包括：78题（颜色分类）和179题（最大数）算法题；《effective java》中关于类的最小可修改和接口优于继承的内容；《vim编程技巧》中关于在插入模式即时更正错误操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第九周</title>
    <link href="http://yoursite.com/2019/06/16/ARTS/ARTS-9/"/>
    <id>http://yoursite.com/2019/06/16/ARTS/ARTS-9/</id>
    <published>2019-06-16T08:28:39.000Z</published>
    <updated>2019-06-19T14:14:50.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第九周"><a href="#ARTS第九周" class="headerlink" title="ARTS第九周"></a>ARTS第九周</h1><p>本次ARTS主要包括：合并两个有序数组算法题；《effective java》 中关于类的访问权限设置；vim中标记跳转的用法；分享关于java中锁的底层实现机制。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><ol start="88"><li>合并两个有序数组</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>&amp;&amp;n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m+n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(m&gt;<span class="number">0</span>)&#123;</span><br><span class="line">               a= nums1[m-<span class="number">1</span>]; </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               nums1[i]=nums2[n-<span class="number">1</span>];</span><br><span class="line">               n--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">               <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                 b= nums2[n-<span class="number">1</span>];  </span><br><span class="line">               &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                  nums1[i]=nums1[m-<span class="number">1</span>];</span><br><span class="line">                   m--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">               nums1[i] = a;</span><br><span class="line">               m--;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               nums1[i] = b;</span><br><span class="line">               n--;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题我是看了题解的思想后，再自己写的代码出来的。刚开始一直想着用类似合并有序链表的方式，用递归来做。但是一直没有弄出来递推表达式，后来看了题解，都没有用递归的。于是采用了从后往前遍历的方式来做。先将最大的数放在第m+n-1的位置，往前遍历，然后当其中一个数组遍历完成了之后，再把另个数组剩余的值全部搬到结果中来即可。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>continue reading 《effective java》</p><ul><li><p>Item 15 : Minimize the accessibility of the classes and members</p><blockquote><ol><li>The single most important factor that distinguishes a well-designed component from a poorly designed ont is the degree to which the component hides its internal data and other implementation details, clearnly separating its API from its implementation.</li><li>The rule of thumb is simple : <strong><em>make each class or member as inaccessible as possible.</em></strong></li><li>To summarize, <strong><em>you should reduce accessibility of program elements as much as possible(within reason).</em></strong> After carefully designing a minimal public API, you should prevent any stray classes, interfaces, or members from becoming part of the API. <strong>With the exception of public static final fields, which serve as constants, public class should have no public fields .</strong> Ensure that objects referenced by public static final fields are immutable.</li></ol></blockquote></li><li><p>Item 16: In public classes, use accessor methods, not public fields</p><blockquote><ol><li>If a classis accessible outside its package, provide accessor methods to preserve the flexibility to change the class’s internal representation</li><li>If a class is package-private or is a private nested class, there is nothing inherently wrong with exposing its data fields</li><li>In summary, public classes should never expose mutable fields.</li></ol></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li>使用<code>m{a-zA-Z}</code>表示在当前光标所在位置设标记，小写字母标记只在缓冲区局部可见，大写字母则全局可见。</li><li><code>mm</code>和<code></code>m`是一对便于使用的命令，分别用于设置标记位m和跳转到编辑位m上。同时vim还会自动编辑一些位置：</li></ul><p><img src="/2019/06/16/ARTS/ARTS-9/微信截图_20190616213221.png" alt=""></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>跟朋友做了个关于Java锁的实现机制的分享，ppt内容就不截图了，链接贴在这：</p><p><a href="https://github.com/Banana1995/PersonRepo/tree/master/Document/ShareDoc" target="_blank" rel="noopener">锁的实现机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第九周&quot;&gt;&lt;a href=&quot;#ARTS第九周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第九周&quot;&gt;&lt;/a&gt;ARTS第九周&lt;/h1&gt;&lt;p&gt;本次ARTS主要包括：合并两个有序数组算法题；《effective java》 中关于类的访问权限设置；vim中标记跳转的用法；分享关于java中锁的底层实现机制。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第八周</title>
    <link href="http://yoursite.com/2019/06/04/ARTS/ARTS-8/"/>
    <id>http://yoursite.com/2019/06/04/ARTS/ARTS-8/</id>
    <published>2019-06-04T14:41:39.000Z</published>
    <updated>2019-06-16T08:36:47.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第八周"><a href="#ARTS第八周" class="headerlink" title="ARTS第八周"></a>ARTS第八周</h1><p>本次ARTS主要包括：合并两个有序链表算法题；《effective java》 关于建议实现comparable接口；工作中学到的mysql中关于插入重复记录的几种处理方式。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><ol start="783"><li>Merge Two sorted list</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&gt;=l2.val)&#123;</span><br><span class="line">            res = l2;</span><br><span class="line">            res.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res = l1;</span><br><span class="line">            res.next =  mergeTwoLists(l1.next,l2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题一开始使用暴力解法没有解出来，采用了题解的一个递归方法。也学习到了递归的一些思想，可以用一个变量来保存需要返回的结果，然后再缩小范围继续递归。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p> continue reading 《effective java》</p><ul><li><p>Item 14 : consider implement comparable</p><blockquote><ol><li><p>By implement comparable, you allow you class to interoperate with all of many generic algorithms and collection implementations that depends on this interface.</p></li><li><p>If  a field does not implement comparable or you need a nonstandard ordering , use a Comparator instead.</p></li><li><p>Use of the relational operators &lt; and &gt; in compareTo methods is<br>verbose and error-prone and no longer recommended</p></li><li><p>In Java8, the Comparator interface was outfitted with a set of comparator construction methods, which enable fluent construction of comparators.These comparators can then be used to implement a compareTo method, as required by the Comparable interface.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="comment">// Comparable with comparator construction methods</span></span><br><span class="line">&gt;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;PhoneNumber&gt; COMPARATOR =</span><br><span class="line">&gt;    comparingInt((PhoneNumber pn) -&gt; pn.areaCode)</span><br><span class="line">&gt;    .thenComparingInt(pn -&gt; pn.prefix)</span><br><span class="line">&gt;    .thenComparingInt(pn -&gt; pn.lineNum);</span><br><span class="line">&gt;    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PhoneNumber pn)</span> </span>&#123;</span><br><span class="line">&gt;    <span class="keyword">return</span> COMPARATOR.compare(<span class="keyword">this</span>, pn);</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="5"><li><strong>In summary, whenever you implement a value class that has a sensible ordering, you should have the class implement the Comparable interface so that its instances can be easily sorted , searched, and user in comparison-based collections. When comparing field values in the implementations of the compareTo methods, avoid the use of &lt; and &gt; operators. Instead, user the static compare methods inthe boxed primitive classes or the comparator construction methods in the Comparator interface.</strong></li></ol></blockquote></li></ul><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>处理mysql插入记录重复的几种方式</p><ul><li>使用<code>insert ignore</code></li></ul><blockquote><p>Use the <strong>INSERT IGNORE</strong> command rather than the <strong>INSERT</strong> command. If a record doesn’t duplicate an existing record, then MySQL inserts it as usual. If the record is a duplicate, then the <strong>IGNORE</strong> keyword tells MySQL to discard it silently without generating an error.</p><p>当记录不存在是，mysql会正常插入；当记录已经存在时，<code>ignore</code>关键字会告诉mysql静默的将数据丢掉而不报出错误。下面的sql语句将不会报错：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; mysql&gt; INSERT IGNORE INTO person_tbl (last_name, first_name)</span><br><span class="line">&gt;    -&gt; VALUES( 'Jay', 'Thomas');</span><br><span class="line">&gt; Query OK, 1 row affected (0.00 sec)</span><br><span class="line">&gt; </span><br><span class="line">&gt; mysql&gt; INSERT IGNORE INTO person_tbl (last_name, first_name)</span><br><span class="line">&gt;    -&gt; VALUES( 'Jay', 'Thomas');</span><br><span class="line">&gt; Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li>使用<code>replace</code> </li></ul><blockquote><p>Use the <strong>REPLACE</strong> command rather than the INSERT command. If the record is new, it is inserted just as with INSERT. If it is a duplicate, the new record replaces the old one.</p><p>使用<code>replace</code>命令来插入时，当记录不存在，则会正常插入。若已经存在，则会用新的记录代替原先的记录（先删再插）。示例如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; mysql&gt; REPLACE INTO person_tbl (last_name, first_name)</span><br><span class="line">&gt;    -&gt; VALUES( 'Ajay', 'Kumar');</span><br><span class="line">&gt; Query OK, 1 row affected (0.00 sec)</span><br><span class="line">&gt; </span><br><span class="line">&gt; mysql&gt; REPLACE INTO person_tbl (last_name, first_name)</span><br><span class="line">&gt;    -&gt; VALUES( 'Ajay', 'Kumar');</span><br><span class="line">&gt; Query OK, 2 rows affected (0.00 sec)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><strong><em>当处理重复插入记录时，应该在<code>insert ignore</code>和<code>replace</code>中选择一个，<code>insert ignore</code>会保留第一次插入的记录，而<code>replace</code>则保留的是最后的一条记录。</em></strong> </li><li>使用<code>insert into...on duplicate key update id=id</code></li></ul><blockquote><p>这里使用<code>id=id</code>来在更新时做无用操作来完成在key重复时什么都不做。</p></blockquote><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>无</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第八周&quot;&gt;&lt;a href=&quot;#ARTS第八周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第八周&quot;&gt;&lt;/a&gt;ARTS第八周&lt;/h1&gt;&lt;p&gt;本次ARTS主要包括：合并两个有序链表算法题；《effective java》 关于建议实现comparable接口；工作中学到的mysql中关于插入重复记录的几种处理方式。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第七周</title>
    <link href="http://yoursite.com/2019/05/26/ARTS/ARTS-7/"/>
    <id>http://yoursite.com/2019/05/26/ARTS/ARTS-7/</id>
    <published>2019-05-26T15:46:39.000Z</published>
    <updated>2019-06-03T16:23:09.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第七周"><a href="#ARTS第七周" class="headerlink" title="ARTS第七周"></a>ARTS第七周</h1><p>本次ARTS主要包括：最大同值路径问题算法；读完《Java并发编程艺术》整书的思维导图；VIM编程技巧关于上下移动一行和向上或向下查询当前游标下的单词等操作；</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p>168.Longest Univalue Path</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Integer res =<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        recurisionMethod(root);</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">recurisionMethod</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = recurisionMethod(root.left) ;</span><br><span class="line">        <span class="keyword">int</span> right = recurisionMethod(root.right);</span><br><span class="line">        <span class="keyword">if</span>(root.left !=<span class="keyword">null</span> &amp;&amp; root.left.val == root.val)&#123;</span><br><span class="line">            left = left +<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left =<span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.right !=<span class="keyword">null</span> &amp;&amp; root.right.val == root.val)&#123;</span><br><span class="line">            right= right+<span class="number">1</span>;</span><br><span class="line">        &#125;   <span class="keyword">else</span>&#123;</span><br><span class="line">            right=<span class="number">0</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        res = Math.max(res,left+right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最长同值路径问题。自己没有做出来，看了题解的思路。对于递归的问题，我解起来还是比较费劲的。另外就是犯了一个java方法传递值得问题。此处的结果需要定义成全局变量，不能使用一个int类型作为参数传递。因为java是值传递而不是引用传递。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p> continue reading 《effective java》</p><ul><li><p>Item 12 : Always override toString</p><blockquote><ol><li>Providing  a good toString implementation makes your class much more pleasant to use and makes systems using the class easier to debug.</li><li>When practical, the toString method should return all insteresting information contained in the  object.</li><li>Whether or not you decide to specify the format , you should clearly document you intentions.</li><li>Whether or not you specify the format, provide programmatic access to the information contained in the value returned by toString.</li></ol></blockquote></li><li><p>Item 13 : Override clone judiciously</p><blockquote><ol><li>Though the specification doesn’t say it , in practice , a class implementing Cloneable is expected to provide a properly functioning public clone method. And the class and all of its superclass should obey a complex , unenforceable,thinly docemented protocol to achieve that.</li><li>You can use <code>throw new CloneNotSupportedException();</code> for degenerate clone implementation.</li><li>To recap, all classes that implement Cloneable should override clone with a public method whose return type is the class itself. This method should first call <code>super.clone</code>, then fix any fields tha need fixing. Typically, this means copying any mutable objects that comprise the internal “deep structure” of the object and replacing the clone’s references to these objects with references to their copies.</li><li>A better approach to object copying is to provide a <strong><em>copy constructor</em></strong> or <strong><em>copy factory</em></strong>. A notable exception to this rule is arrays, which are best copied with the clone method.</li></ol></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>vim编程技巧：</p><p>使用<code>#</code>可以自动向上查询当前游标下的单词；</p><p>使用<code>*</code>可以自动向下查询当前游标下的单词；</p><p>使用<code>ctrl</code>+<code>e</code>可以向上翻滚一行；</p><p>使用<code>ctrl</code>+<code>y</code>可以自动向下翻滚一行；</p><p>使用<code>zz</code>可以将当前行移动到屏幕中央。</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周阅读完了《Java并发编程艺术》这本书，将其全部的思维导图贴出：</p><p><img src="/2019/05/26/ARTS/ARTS-7/Java并发编程的艺术.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第七周&quot;&gt;&lt;a href=&quot;#ARTS第七周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第七周&quot;&gt;&lt;/a&gt;ARTS第七周&lt;/h1&gt;&lt;p&gt;本次ARTS主要包括：最大同值路径问题算法；读完《Java并发编程艺术》整书的思维导图；VIM编程技巧关于上下移动一行和向上或向下查询当前游标下的单词等操作；&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第六周</title>
    <link href="http://yoursite.com/2019/05/09/ARTS/ARTS-6/"/>
    <id>http://yoursite.com/2019/05/09/ARTS/ARTS-6/</id>
    <published>2019-05-09T15:05:39.000Z</published>
    <updated>2019-06-04T14:37:44.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第六周"><a href="#ARTS第六周" class="headerlink" title="ARTS第六周"></a>ARTS第六周</h1><p>本次ARTS主要包括：Excel列名称算法题；《Java并发编程艺术》内存模型的思维导图；《effective java》中关于重写hashcode方法的章节。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p>168.Excel表列名称</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String contanier = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;</span><br><span class="line">        <span class="keyword">int</span> temp =<span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">26</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(contanier.charAt(n-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb =  <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        List&lt;String&gt; te = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            temp = (n-<span class="number">1</span>)%<span class="number">26</span>;</span><br><span class="line">            n=(n-<span class="number">1</span>)/<span class="number">26</span>;</span><br><span class="line">            te.add(String.valueOf(contanier.charAt(temp)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j= (te.size()-<span class="number">1</span>);j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">            sb.append(te.get(j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的思路是对26取余，从低到高位，一位一位的取。其中的<code>n-1</code>将整除26的数取不到Z字母的问题解决了。</p><p>见到题解中有同学使用<code>&#39;A&#39;+数字</code>来取值，引发了我对char类型数据的思考：char占有2个字节，用16位表示Unicode编码。可以使用’A’加上一个整数来表示其编码的字符，如’A’+1则表示’B’这个字符。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p> continue reading 《effective java》</p><ul><li><p>Item 11 : Always override hashCode when you override equals</p><blockquote><ol><li>You must override hashCode method in every class that overrides equals.Here are the contract,adapted from the Object specification:<ul><li>when the hashCode method is invoked on an object repeatedly during an execution of an application, it must consistently return the same value.</li><li>if two objects are equal according to the equals method , then calling hashCode on the two  objects should return the same integer result.</li><li>if two objects are unequal according to the equals method , it is <strong>not required</strong> that calling hashCode method return distinct value.However, the programmer should be aware that producing distinct results for unequal objects may improve the performance of hash tables.(cause the same hashCode value can make the hashtable degenerate to linked list).</li></ul></li><li>A good hash function tends to produce unequal hash codes for unequal instances.</li><li>When you compute the hash codes , you <strong>must exclude</strong> any fields that are not used in equals comparisons, or you risk violating the second provision of the hashCode contract.</li><li>If you have a bona fide need for hash functions less likely to produce collisions , see Guava’s <code>com.google.common.hash.Hashing</code></li><li>if a class if immutable and the cost of computing the hash code is significant, you might consider caching the hash code in the object rather than recalculating it each time it is requested.</li><li>Do not be tempted to exclude significant fields from the hash code computation to improve perfoemance.</li></ol></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>无</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周新增了《并发编程的艺术》第三章内存模型相关内容的思维导图</p><p><img src="/2019/05/09/ARTS/ARTS-6/Java并发编程的艺术.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第六周&quot;&gt;&lt;a href=&quot;#ARTS第六周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第六周&quot;&gt;&lt;/a&gt;ARTS第六周&lt;/h1&gt;&lt;p&gt;本次ARTS主要包括：Excel列名称算法题；《Java并发编程艺术》内存模型的思维导图；《effective java》中关于重写hashcode方法的章节。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第五周</title>
    <link href="http://yoursite.com/2019/05/05/ARTS/ARTS-5/"/>
    <id>http://yoursite.com/2019/05/05/ARTS/ARTS-5/</id>
    <published>2019-05-05T15:15:09.000Z</published>
    <updated>2019-05-05T15:15:09.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第五周"><a href="#ARTS第五周" class="headerlink" title="ARTS第五周"></a>ARTS第五周</h1><p>本次ARTS主要包括：回文数、最长公共前缀算法、《effective java》关于复写equals方法的Item、VIM使用文本对象选择选区操作、《Java并发编程艺术》前两章的思维导图。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><ol start="9"><li>回文数</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rightToLeft =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> te =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = x;</span><br><span class="line">        <span class="keyword">while</span>(y!=<span class="number">0</span>)&#123;</span><br><span class="line">            te = y%<span class="number">10</span>;</span><br><span class="line">            rightToLeft = rightToLeft*<span class="number">10</span>+te;</span><br><span class="line">            y=y/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==rightToLeft)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚好昨晚刷题刷到了整数反转的题目，这里顺手一上来就想到了使用整数反转的方式来做。果然效果很不错。对于整数溢出的问题其实可以不用担心，因为回文数字肯定不会溢出。</p><blockquote><ol start="14"><li>最长公共前缀</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;;j++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag =<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">char</span> publicChar = <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">if</span>(strs[<span class="number">0</span>]!=<span class="keyword">null</span> &amp;&amp; strs[<span class="number">0</span>].length()&gt;=j+<span class="number">1</span>)&#123;</span><br><span class="line">                publicChar = strs[<span class="number">0</span>].charAt(j);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">                String te = strs[i];</span><br><span class="line">                <span class="keyword">if</span>(te!=<span class="keyword">null</span> &amp;&amp;  te.length()&gt;=j+<span class="number">1</span> &amp;&amp; publicChar==te.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    flag=<span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag )&#123;</span><br><span class="line">                res.append(publicChar);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最开始写的时候没有考虑到String获取长度的是length()方法与数组的length调用方式是不同的，导致编译未通过。后来测试案例又未通过<code>&quot;&quot;</code>的校验。测试了一番之后才知道<code>&quot;&quot;</code>的长度为0，在调用length()方法后，应该判断的条件是字符串的长度大于数组下标+1的值。</p><p>我的这个算法的最坏的时间复杂度为O(m*n)，m为数组的长度，n为公共前缀的字符数。查看了题解后发现与题解中的算法二思路相同，但是代码实现没有它的简单。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>continue reading 《effective java 》</p><ul><li><p>Item 10 Obey the general contract when overriding equals</p><blockquote><ul><li>Each instance of the class is inherently unique.</li><li><strong>There is no need for the class to privide a “logical equality” test.</strong> For example,<em>java.util.regex.Pattern</em> could have overridden equals to check whether two Pattern instances represented exactly the same regular expression.But the client user doesn’t need this function.</li><li>A superclass has already overriden equals, and the superclass behavior is approriate for this class.For example, most Set implementations inherit their equals implementation from AbstractSet, List implementations from AbstractList, and Map implementations from AbstractMap.</li><li><strong>It’s  appropriate for you to overriden equal method when a class has a notion of <em>logical equality</em> that differ from mere object identity and a superclass has not already overridden equals.</strong> This is generally the case for value classes. A value class is simply a class that represents a value, such as Integer or String. A clent user need invoke equals method to find out whether they are logically equivalent or they refer to same object.</li><li>Here are some contract for overriden the <em>equals method</em>. <ul><li>Reflexive: For any non-null reference value x, x.equals(x) must return true.</li><li>Symmetric: For any non-null reference values x and y, x.equals(y) must return true if and only if y.equals(x) returns true.</li><li>Transitive: For any non-null reference values x, y, z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) must return true.</li><li>Consistent: For any non-null reference values x and y, multiple invocations of x.equals(y) must consistently return true or consistently return false, provided no information used in equals comparisons is modified.</li><li>For any non-null reference value x, x.equals(null) must return false.</li></ul></li></ul></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>在使用vim编辑时，可以使用文本对象来进行选择。如：</p><p><img src="/2019/05/05/ARTS/ARTS-5/微信截图_20190505222619.png" alt=""></p><p>同时还可以使用<code>ci}</code>或<code>da&quot;</code>、<code>ya&quot;</code>这种操作来将选中的部分替换、删除、复制。其中的<code>i</code>和<code>a</code>可以理解为<code>inside</code>和<code>arround</code>;<code>a&quot;</code>会选中由双引号括起来的字,<code>i}</code>会选中在一对大括号里面的内容。</p><p>除此之外，还可以使用<code>daw</code>、<code>ciw</code>、<code>yaw</code>这种操作来对一个单词进行删除、替换、复制等。</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>放假期间在读《Java并发编程艺术》这本书。在读完了《Java并发编程实战》再来读这本书，发现很多东西，理解起来更容易了。同时这本书也对底层的指令实现原理讲解的更透彻，推荐阅读。</p><p><img src="/2019/05/05/ARTS/ARTS-5/Java并发编程的艺术.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第五周&quot;&gt;&lt;a href=&quot;#ARTS第五周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第五周&quot;&gt;&lt;/a&gt;ARTS第五周&lt;/h1&gt;&lt;p&gt;本次ARTS主要包括：回文数、最长公共前缀算法、《effective java》关于复写equals方法的Item、VIM使用文本对象选择选区操作、《Java并发编程艺术》前两章的思维导图。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第四周</title>
    <link href="http://yoursite.com/2019/04/27/ARTS/ARTS-4/"/>
    <id>http://yoursite.com/2019/04/27/ARTS/ARTS-4/</id>
    <published>2019-04-27T15:05:39.000Z</published>
    <updated>2019-04-27T15:07:49.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第四周"><a href="#ARTS第四周" class="headerlink" title="ARTS第四周"></a>ARTS第四周</h1><p>快五一了，最近这段时间都是在看并发相关的知识。刚看完《Java并发编程实战》，基础部分还是需要恶补呀。加油，一步步来。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><ol start="7"><li>整数反转</li></ol></blockquote><p>标准答案的解法是通过使用取余法不断地取出整数的每一位，再用乘法加到新数的后面去，再判断一下整数是否溢出了即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> te = x%<span class="number">10</span>;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span>(rev&gt;Integer.MAX_VALUE/<span class="number">10</span> || (rev ==  Integer.MAX_VALUE/<span class="number">10</span> &amp;&amp; te&gt;<span class="number">7</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rev&lt;Integer.MIN_VALUE/<span class="number">10</span> || (rev == Integer.MIN_VALUE/<span class="number">10</span> &amp;&amp; te &lt;-<span class="number">8</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            rev = rev*<span class="number">10</span>+te;</span><br><span class="line">              x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>continue reading 《effective java》</p><ul><li><p>Item 7 Eliminate obsolete object references</p><blockquote><ol><li><strong>Nulling out object references should be the exception rather than the norm </strong></li><li>when a class manager its own memory , the programmer should be alert for memory leaks.</li><li>caches is common source of memory leaks</li></ol></blockquote></li><li><p>Item 8  Avoid Finalizers and cleaners</p><blockquote><ol><li>Finalizers are unpredictable , often dangerous, and generally unneccessary.Cleaners are less dangerous than finalizers,but still unpredicatable,slow,and generally unnecessary.</li><li>There is a severe performance penatly for using finalizer and cleaners.</li><li>They have two legitimate uses. One is to act as a safety net in case the owner of a resource neglects to call its close method .Another is native peers</li></ol></blockquote></li><li><p>Item 9 Perfer try-with-resources to try-finally</p></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>在工作中遇到了需要用sql处理字符串的问题，使用到了substring_index这个函数，具体用法如下：</p><blockquote><p> <strong>substring_index(“待截取字符”，”分隔符”，截取第n个字符)</strong></p></blockquote><p>当最后的数字n为负数时，代表倒着数第n个字符。</p><p>将从<code>1010a2|192b23|33c23|12383d|12312f</code>这段字符中取出竖线分割的倒数第一个字符的用法为：<code>substring_index(&quot;1010a2|192b23|33c23|12383d|12312f&quot;,&quot;|&quot;,-1)</code>,取出第三个用法为<code>substring_index(&quot;1010a2|192b23|33c23|12383d|12312f&quot;,&quot;1&quot;,3)</code></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>最近几周都在死磕并发编程这本书，终于读完，收获颇丰，贴上自己整理的思维导图</p><p><img src="/2019/04/27/ARTS/ARTS-4/Java 并发编程实战.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第四周&quot;&gt;&lt;a href=&quot;#ARTS第四周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第四周&quot;&gt;&lt;/a&gt;ARTS第四周&lt;/h1&gt;&lt;p&gt;快五一了，最近这段时间都是在看并发相关的知识。刚看完《Java并发编程实战》，基础部分还是需要恶补呀。加油，一步步来。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS补卡第三周</title>
    <link href="http://yoursite.com/2019/04/16/ARTS/ARTS-3/"/>
    <id>http://yoursite.com/2019/04/16/ARTS/ARTS-3/</id>
    <published>2019-04-16T13:20:29.000Z</published>
    <updated>2019-04-21T14:41:58.564Z</updated>
    
    <content type="html"><![CDATA[<p>上周工作任务很重，周日没来得及打卡，今天补上。真心希望忙完这一阵可以轻松点，不然真的撑不下去了。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p>237.删除链表中的结点</p></blockquote><p>本来是一道很简单的题，没有理解清楚变量<code>x</code>的含义，结果导致使用了递归还是没有做出来，很可惜；</p><p>贴上最后的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        ListNode nextNode =node.next;</span><br><span class="line">        node.val = nextNode.val;</span><br><span class="line">        node.next = nextNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>continue reading 《effective java》.</p><ul><li><p>Item 5 : Prefer Dependency injection to hardwiring resources.</p><blockquote><ol><li>static utility classes and singletons are inappropriate for classes whose behavior is parameterized by an underlying resource.</li><li>a simple pattern that satisfies that requirement is to pass the resource into the constructor when creating instance. This is one form of Dependency injection .</li><li>Do not use a singleton or static utility class to implements a class that depends on one or more   underlying resource whose  behavior affects that of class. And do not have the class create these resource.Instead, pass the resources,or factories to create them, into the constructor.</li></ol></blockquote></li><li><p>Item 6 : Avoid creating unnecessary object.</p><blockquote><ol><li>you can often avoid creating unnecessary object by using <code>static factory method</code> in preference to constructor on immutable classes that provide both.like use <code>String a= &quot;banana&quot;</code> ,not <code>String a = new String(&quot;banana&quot;)</code>. Besides,<code>Boolean(String)</code> is deprecated in Java 9,cause it must create the instance each time it’s invoked.The factory method <code>Boolean.valueOf(String)</code> is preferable to the constructor. </li><li>you can also reuse the <strong>mutable </strong>object if you know it won’t be modified. Some object creations are so expensive , cache it for reuse will provides significant performance gains if they are invoked frequently. if the object is immutable , it is obvious it can be reused safely.</li><li>Another way to create unnecessary object is <strong>autoboxing</strong> .we should prefer primitives to boxed primitives , and watch out unintentional autoboxing.</li><li>Conversely,avoid object creation by maintaining you own object pool is a bad idea,unless the object is extremely heavyweight.</li></ol></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>这周在工作中遇到一个问题，当我试图把一个很大的文件通过流转换为<code>String</code>存储时，这个转换有时候会出错，报出<code>OutOfMemoryError:null</code>的错误。随即我开始调整内存大小，但是无论我怎么调整都没有用。</p><p>当我观察后发现，错误信息的后面是<code>null</code>而不是通常的堆栈溢出等。于是我开始跟踪源码，发现当我用流读进来后，用<code>StringBuilder</code>去拼接成字符串。然而<code>String</code>的字符数组的最大长度为：$$2^{31}=2^{10}\times2^{10}\times2^{10}\times2^{1}=1024\times1024\times1024\times2$$，即2GB。而我的文件刚好大于2GB。所以之前我在转其他文件的时候没有报错是由于文件小于2GB。此处的<code>OOM</code>错误是<code>StringBuilder</code>抛出的，而不是由于堆内存 不够导致的内存溢出。</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>无</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周工作任务很重，周日没来得及打卡，今天补上。真心希望忙完这一阵可以轻松点，不然真的撑不下去了。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第二周</title>
    <link href="http://yoursite.com/2019/04/03/ARTS/ARTS-2/"/>
    <id>http://yoursite.com/2019/04/03/ARTS/ARTS-2/</id>
    <published>2019-04-03T15:28:39.000Z</published>
    <updated>2019-04-07T08:01:45.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第二周"><a href="#ARTS第二周" class="headerlink" title="ARTS第二周"></a>ARTS第二周</h1><p>第二周赶上清明假期，察觉自己欠缺诸多，还是踏踏实实的一步一步来。所谓慢就是快，时常想尽力追赶前面的东西，没把基础打好，后面搞得自己很狼狈，实则是得不偿失。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>本周做的题目是最长回文子串，第一遍做的时候没有理解清楚什么是回文。第二次提交的时候未能通过测试用例。看了题解才做出来的。</p><p>思路是用中心点方法，从中心点开始往两侧推移。</p><p>贴出大佬的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] range = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            i = findLongest(str, i, range);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(range[<span class="number">0</span>], range[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLongest</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> low, <span class="keyword">int</span>[] range)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> high = low;</span><br><span class="line">        <span class="keyword">while</span> (high &lt; str.length - <span class="number">1</span> &amp;&amp; str[high + <span class="number">1</span>] == str[low]) &#123;</span><br><span class="line">            high++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = high;</span><br><span class="line">        <span class="keyword">while</span> (low &gt; <span class="number">0</span> &amp;&amp; high &lt; str.length - <span class="number">1</span> &amp;&amp; str[low - <span class="number">1</span>] == str[high + <span class="number">1</span>]) &#123;</span><br><span class="line">            low--;</span><br><span class="line">            high++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (high - low &gt; range[<span class="number">1</span>] - range[<span class="number">0</span>]) &#123;</span><br><span class="line">            range[<span class="number">0</span>] = low;</span><br><span class="line">            range[<span class="number">1</span>] = high;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于动态规划、字符串查找等算法还是很迷糊，还是需要加强训练和看书啊。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周继续阅读英文版《effective java》。</p><ul><li>Item2 consider a builder pattern when face many constructor parameters.</li></ul><blockquote><ol><li><p>The Builder pattern is a good choice when designing classes whose construct or static factories would have more than a handful parameters.</p></li><li><p>builder pattern is provide a public method which return ‘Builder’ type Object.And,The instant of Builder type Object would provide a build() method,which return the instant of outclass Object.</p></li></ol></blockquote><ul><li>Item 3 Enforce the singleton property with a private constructor or an enum type</li></ul><blockquote><ol><li>the normal approach to implement singletons are base on keeping the construstor private and export a public static member to provide access to the sole instance.but serialized instantce will create a new instance,unless you declare all instance fields <code>transient</code> and provide <code>readResolve</code> method.</li><li>a single-element enum type is often the best way to implement singleton.</li></ol></blockquote><ul><li>Item 4 Enforce nonistantiablity with a private contructor</li></ul><blockquote><ol><li>some utility classes is not designed for instantied. but the default construct would make it can be instantiated.we could make the constructor private to avoid user instantiated it.</li><li>private construct can make the subclass could’t instantiated too.cause the all constructors must invoke superclass contructor,explicitly or implicitly. and the private constructor is inaccessible from outside class.</li><li>The AccessError is not strictly required,but it provides insurance in case the constructor is invoked from inside class.</li></ol></blockquote><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>学习《VIM使用技巧》，工作中使用vim一直不会快速移动，在此记录下，最近学到的快速移动技巧</p><ol><li>区分屏幕行和实际行。例如在工作中编辑baseInfo文件时，其实就是一个实际行，但是这一行的内容非常多，导致在做查找、跳转等动作时很不方便，但是vim可以在移动命令前加上<code>g</code>表示移动屏幕行。如<code>gk</code>表示向上移动一个屏幕行。</li></ol><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center"><code>g0</code></td><td style="text-align:center">移动到屏幕行的行首</td></tr><tr><td style="text-align:center"><code>0</code></td><td style="text-align:center">移动到实际行的行首</td></tr><tr><td style="text-align:center"><code>gk</code></td><td style="text-align:center">向上移动一个屏幕行</td></tr><tr><td style="text-align:center"><code>^</code></td><td style="text-align:center">移动到实际行的第一个非空白字符</td></tr><tr><td style="text-align:center"><code>g^</code></td><td style="text-align:center">移动到屏幕行的第一个非空白字符</td></tr><tr><td style="text-align:center"><code>$</code></td><td style="text-align:center">移动到实际行的行尾</td></tr><tr><td style="text-align:center"><code>g$</code></td><td style="text-align:center">移动到屏幕行的行尾</td></tr></tbody></table><ol start="2"><li><p>基于单词的移动，下面这张截图即可了解清楚各个命令的操作：</p><p><img src="/2019/04/03/ARTS/ARTS-2/moveBaseWord.png" alt=""></p></li></ol><ol start="3"><li><p>区分单词和字符串：对于vim来说，单词是以各种逗号，括号，空格等符号分割的，而字符串则是单纯的以空格分割开来。基于这个认知，我们在做移动命令的时候，便可使用<code>W</code>/<code>E</code>/<code>B</code>等命令基于字符串移动。这样会比基于单词移动快很多，如果希望以细粒·度来移动则可以使用基于单词的方式。</p></li><li><p>使用<code>f{char}</code>+<code>;</code>命令可以在同一行中，根据查找的字母快速移动到自己希望的位置上去。若不小心跳过头了，还可以使用<code>,</code>命令往回跳。</p><blockquote><p>可以把 <code>t{char}</code> 及 <code>T{char}</code>命令当成“直到查找到指定的字符为止”（search till<br>the specified character）的命令，它们使光标停留在 {char} 前面的那个字符上，而<br><code>f{char}</code> 和 <code>F{char}</code>命令则把光标移动到指定字符上。</p></blockquote></li></ol><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>和同学一起做了个分享会，把提纲内容贴在这里，这个内容还没做完，后续还会在这里更新。</p><p><img src="/2019/04/03/ARTS/ARTS-2/Java-concurrency-in-practice.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第二周&quot;&gt;&lt;a href=&quot;#ARTS第二周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第二周&quot;&gt;&lt;/a&gt;ARTS第二周&lt;/h1&gt;&lt;p&gt;第二周赶上清明假期，察觉自己欠缺诸多，还是踏踏实实的一步一步来。所谓慢就是快，时常想尽力追赶前面的东西，没把基础打好，后面搞得自己很狼狈，实则是得不偿失。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第一周</title>
    <link href="http://yoursite.com/2019/03/31/ARTS/ARTS-1/"/>
    <id>http://yoursite.com/2019/03/31/ARTS/ARTS-1/</id>
    <published>2019-03-31T15:28:39.000Z</published>
    <updated>2019-03-31T15:32:00.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第一周"><a href="#ARTS第一周" class="headerlink" title="ARTS第一周"></a>ARTS第一周</h1><p>第一周参加ARTS打卡，将本周的总结都记录在个人的blog里。刚开始第二天，由于周末加班准备的很仓促，质量感觉一般，最后的share没有做，下周补上。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>先是LeetCode上简单的算法题，两数之和。上次刷算法题应该是大四秋招前，那会儿什么也不懂，也没坚持下去，甚至当时都没觉得以后可以成为一个程序猿。直到阴差阳错，真的成为了程序猿后，发现基础太薄弱，需要补的东西太多了。索性一步一步来，花两年时间把改补的尽量都补上。下面是我的答案，做的很不好，只想到了暴力解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i]+nums[j] == target)&#123;</span><br><span class="line">                result[<span class="number">0</span>]=i;</span><br><span class="line">                result[<span class="number">1</span>]=j;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了题解后发现可以用<code>map</code>来做，而让我没能转过弯的是可以把两数之和转换成<code>x</code> 和 <code>target-x</code> 来从数组中查找。我只想到了单纯的相加。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>读了中英对照版的《effective java》Chapter 2 Item 1，英语不太好，对于其中的很多点理解的有些不到位，所以 需要对照着中文版才能看懂一些。模仿github上的总结，将自己的总结写在下面：</p><blockquote><ol><li><p>static factory methods have names,but constructors not;</p></li><li><p>not required to create new object when they’re invoked;</p></li><li>they can return any subtype of return type;</li><li>return type can vary from call to call as a function of the input parameters;</li><li>the return type can not exist when the static factory method is written;</li></ol></blockquote><p>there are two main limitation of static factory method :</p><blockquote><ol><li>the class without public or protected contructors can not be subclassed;</li><li>documentation is not frendly for programmers;</li></ol></blockquote><p><a href="https://jiapengcai.gitbooks.io/effective-java/content/chapter1/di-1-tiao-ff1a-kao-lv-yong-jing-tai-fang-fa-er-bu-shi-gou-zao-qi.html" target="_blank" rel="noopener">gitbook中英对照版</a></p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>最近在练习使用<code>vim</code>插件编辑代码，想到上次在客户现场，<code>json</code>文件是一行数据，很长很长。我用<code>vim</code>编辑不知道如何使用<code>replace</code>功能在同一行中选中部分进行替换。后来问了同学，他抛给我一个链接，是英文搜索出来的，而且讲解很详细。这次让我认识到学习英语对于查找问题很重要，很多信息确实在中文里搜索很难找到解答。在此记录下<code>vim</code>在<code>visual</code>模式下的替换技巧：可以使用<code>\%V</code>来指定在<code>visual</code>模式中替换选中部分的查找对象。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">music amuse fuse refuse</span><br></pre></td></tr></table></figure><p>In normal mode, type <code>^wvee</code> to visually select “amuse fuse” (<code>^</code> goes to first nonblank character, <code>w</code> moves forward a word, <code>v</code> enters visual mode, <code>e</code> moves forward to end of next word). Then press Escape and enter the following command to change all “us” to “az” in the last-selected area within the current line:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&apos;&lt;,&apos;&gt;s/\%Vus/az/g</span><br></pre></td></tr></table></figure><p>the result is :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">music amaze faze refaze</span><br></pre></td></tr></table></figure><p>注意V是大写，不是小写。</p><p><a href="https://vim.fandom.com/wiki/Search_and_replace_in_a_visual_selection" target="_blank" rel="noopener">原文地址链接</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>无</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第一周&quot;&gt;&lt;a href=&quot;#ARTS第一周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第一周&quot;&gt;&lt;/a&gt;ARTS第一周&lt;/h1&gt;&lt;p&gt;第一周参加ARTS打卡，将本周的总结都记录在个人的blog里。刚开始第二天，由于周末加班准备的很仓促，质量感觉一般，最后的share没有做，下周补上。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
</feed>
