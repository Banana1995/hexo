<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.png?v=5.1.4">


  <link rel="mask-icon" href="/images/avatar.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="LEETCODE," />





  <link rel="alternate" href="/atom.xml" title="小蚂蚁爱吃香蕉" type="application/atom+xml" />






<meta name="description" content="LeetCode记录总结本文章主要记录LeetCode刷题学到的知识">
<meta name="keywords" content="LEETCODE">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode记录总结">
<meta property="og:url" content="http://yoursite.com/2020/05/13/LeetCode -Template/index.html">
<meta property="og:site_name" content="小蚂蚁爱吃香蕉">
<meta property="og:description" content="LeetCode记录总结本文章主要记录LeetCode刷题学到的知识">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-05-13T12:32:45.587Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode记录总结">
<meta name="twitter:description" content="LeetCode记录总结本文章主要记录LeetCode刷题学到的知识">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/05/13/LeetCode -Template/"/>





  <title>LeetCode记录总结 | 小蚂蚁爱吃香蕉</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小蚂蚁爱吃香蕉</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">It's what you do in the dark puts you in the light</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/13/LeetCode -Template/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小蚂蚁爱吃香蕉">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小蚂蚁爱吃香蕉">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">LeetCode记录总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-13T20:28:39+08:00">
                2020-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java基础/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  20,670
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="LeetCode记录总结"><a href="#LeetCode记录总结" class="headerlink" title="LeetCode记录总结"></a>LeetCode记录总结</h1><p>本文章主要记录LeetCode刷题学到的知识</p>
<a id="more"></a>
<h2 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242.Valid Anagram"></a>242.Valid Anagram</h2><p>题目：</p>
<blockquote>
<p>Given two strings s and t , write a function to determine if t is an anagram of s.</p>
</blockquote>
<p>我的解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> ((s.isEmpty() &amp;&amp; !t.isEmpty())||s.length()!=t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] tchars = t.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] schars = s.toCharArray();</span><br><span class="line">       Arrays.sort(tchars);</span><br><span class="line">        Arrays.sort(schars);</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tchars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tchars[i] != schars[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路是想通过将字符串排序，然后逐一对比字符。看到官方有种解法是通过哈希映射，先准备一个26长度的int数组，将每个字符与<code>a</code>相减得出对应的ASCII码，将其作为数组的下标，s的字符对下标上的值++，t的字符对下标上的值–。最后，判断这个数组有没有不为0的，若不为0，则说明字符不一样。<strong>以后遇到字符串比较的问题，可以往数组映射上进行考虑</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        counter[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        counter[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : counter) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题的follow up是，如果字符串是unicode编码的，那么怎么实现。那样的话我的这种解法依然有效，但是使用定长数组的解法则不行，需要使用hashmap来代替数组。</p>
<p>Unicode相关：<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p>
<h2 id="LCCI-01-01-Is-Unique"><a href="#LCCI-01-01-Is-Unique" class="headerlink" title="LCCI.01.01 Is Unique"></a>LCCI.01.01 Is Unique</h2><p>题目：</p>
<blockquote>
<p>Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?</p>
</blockquote>
<p>我的思路是直接采用整形数组，将每个字符与<code>A</code>相减得出的数字作为数组下标，将数组的值+1，当发现某个字符对应的数组值大于1时，则说明该字符重复了，返回false。</p>
<p>题目说的是不采用其他数据结构，而我用了数组来解，其实也是一种数据结构。看了题解，发现可以用整形的bit位代替数组，将每个字符与<code>A</code>的差作为数字1的左移位数，这样每次和mark的值相与，若字符没重复着则会为0，不为0则说明重复了。在不重复的时候，用或运算来将mark的bit位置位。贴出我修改后的解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String astr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (astr.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chars = astr.toCharArray();</span><br><span class="line">        <span class="keyword">long</span> flag =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">            <span class="keyword">long</span> i = aChar - <span class="string">'A'</span>;</span><br><span class="line">            <span class="keyword">if</span> ((flag &amp; (<span class="number">1L</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                flag =flag|(<span class="number">1L</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-01-02-Check-Permutation"><a href="#LCCI-01-02-Check-Permutation" class="headerlink" title="LCCI.01.02 Check Permutation"></a>LCCI.01.02 Check Permutation</h2><p>题目：</p>
<blockquote>
<p>Given two strings,write a method to decide if one is a permutation of the other.</p>
</blockquote>
<p>此题类似与#242 valid anagram 那道题。可以采用相同的解法。但是看到题解里有采用异或的方式来解的，异或本身的原理是：<code>0^a=a;1^a=a取反</code>。因此当用0跟字符串每个字符异或后，得到的值是字符串每个字符相异或的。这样对两个字符串进行异或后再对两个值进行比较，若相等则说明是同个字符串，否则为不同字符串。</p>
<p>解法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">CheckPermutation</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (s1 == <span class="keyword">null</span> || s2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> s1 == <span class="keyword">null</span> &amp;&amp; s2 == <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">char</span>[] s1Chars = s1.toCharArray();</span><br><span class="line">       <span class="keyword">char</span>[] s2Chars = s2.toCharArray();</span><br><span class="line">       <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">char</span> s1Char : s1Chars) &#123;</span><br><span class="line">           a = a ^ s1Char;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">char</span> s2Char : s2Chars) &#123;</span><br><span class="line">           b = b ^ s2Char;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> a == b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-01-03-String-toURL"><a href="#LCCI-01-03-String-toURL" class="headerlink" title="LCCI.01.03 String toURL"></a>LCCI.01.03 String toURL</h2><p>题目：</p>
<blockquote>
<p>Write a method to replace all spaces in a string with ‘%20’. You may assume that the string has sufficient space at the end to hold the additional characters,and that you are given the “true” length of the string. (Note: If implementing in Java,please use a character array so that you can perform this operation in place.)</p>
</blockquote>
<p>刚开始理解错了题目的意思，以为要将字符串中的空格全部替换为<code>%20</code>，后来测试才发现，需要转换的字符串其实是给定的长度，所以只需要遍历字符串，将给定长度内的空格字符替换为<code>%20</code>即可。</p>
<p>解法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpaces</span><span class="params">(String S, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">char</span>[] charArray = S.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = charArray[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</span><br><span class="line">                res.append(<span class="string">"%20"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-01-04-Palindrome-Permutation"><a href="#LCCI-01-04-Palindrome-Permutation" class="headerlink" title="LCCI.01.04 Palindrome Permutation"></a>LCCI.01.04 Palindrome Permutation</h2><p>题目：</p>
<blockquote>
<p>Given a string, write a function to check if it is a permutation of a palin­ drome. A palindrome is a word or phrase that is the same forwards and backwards. A permutation is a rearrangement of letters. The palindrome does not need to be limited to just dictionary words.</p>
</blockquote>
<p>可以把题目中的回文字符串理解为一个字符串中字母出现次数为奇数的不超过1个。理解了这个之后，就可以使用哈希映射的方式来解决这个问题了，先将每个字母对应的数字放到数组中，然后将数组的值奇数，作为出现此处。最后判断次数是否为奇数即可。此处判断是否为奇数可以使用<code>(a&amp;1)==1</code>来判断，若位与后结果为1，则说明是奇数。</p>
<p>关于位运算总结可以参考这篇博客：<a href="http://blog.tomtung.com/2007/05/bitwise-operation/" target="_blank" rel="noopener">位运算总结</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPermutePalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>|| s.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    HashMap&lt;Character, Integer&gt; letters = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">        letters.merge(aChar, <span class="number">1</span>, (a, b) -&gt; a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> letter : letters.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((letter&amp;<span class="number">1</span>)==<span class="number">1</span>)&amp;&amp; (++flag)&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-01-05-One-Away"><a href="#LCCI-01-05-One-Away" class="headerlink" title="LCCI.01.05 One Away"></a>LCCI.01.05 One Away</h2><p>题目：</p>
<blockquote>
<p>There are three types of edits that can be performed on strings: insert a character, remove a character, or replace a character. Given two strings, write a function to check if they are one edit (or zero edits) away.</p>
</blockquote>
<p>此题并不是单词的判断字符串少了几个字符的问题，而是两个字符串除了不一样的那个字符外，其他字符的顺序也需要一直。没有想到更好的办法，于是我采用的是双指针暴力法。双指针类的题目需要分清不同情况下两个指针的处理，在这题中，两个字符串长度相差大于1肯定返回false，其他的分为长度相同和长度相差为1来分别处理。长度相同时，最多有一个字符可以不一样。长度相差为1时，短字符串的顺序必须与长字符串一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">oneEditAway</span><span class="params">(String first, String second)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (first == <span class="keyword">null</span> || second == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     String longer = first.length() &gt;= second.length() ? first : second;</span><br><span class="line">     String shorter = first.length() &lt; second.length() ? first : second;</span><br><span class="line">     <span class="keyword">if</span> (longer.length() - shorter.length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (longer.isEmpty() || shorter.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">return</span> longer.length() - shorter.length() &lt;= <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> (longer.length() == shorter.length()) &#123;</span><br><span class="line">                 </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; longer.length(); k++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (longer.charAt(k) != shorter.charAt(k)) &#123;</span><br><span class="line">                 flag++;</span><br><span class="line">                 <span class="keyword">if</span> (flag &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (; j &lt; shorter.length(); ) &#123;</span><br><span class="line">             <span class="keyword">if</span> (longer.charAt(i) != shorter.charAt(j)) &#123;</span><br><span class="line">                 i++;</span><br><span class="line">                 flag++;</span><br><span class="line">                 <span class="keyword">if</span> (flag &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             i++;</span><br><span class="line">             j++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-01-06-Compress-String"><a href="#LCCI-01-06-Compress-String" class="headerlink" title="LCCI.01.06 Compress String"></a>LCCI.01.06 Compress String</h2><p>题目：</p>
<blockquote>
<p>Implement a method to perform basic string compression using the counts of repeated characters. For example, the string aabcccccaaa would become a2blc5a3. If the “compressed” string would not become smaller than the original string, your method should return the original string. You can assume the string has only uppercase and lowercase letters (a - z).</p>
</blockquote>
<p>这题我采用普通的遍历法做出来了，需要注意的是不能使用哈希映射的方法。因为相同字母在不连续位置出现是不能统计到一起去的。看题解中，有同学<strong>在字符的最后补了一位来规避遍历时处理最后一个字符的特殊情况</strong>，这种思路值得学习。还有的同学采用了双指针的思路，一个指针遍历字符，另个指针统计相同的字符个数。</p>
<p>我的解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.isEmpty()||S.length()&lt;<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chars = S.toCharArray();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> repeat = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == chars[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                repeat++;</span><br><span class="line">                <span class="keyword">if</span> (i == chars.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    sb.append(chars[i]).append(repeat);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(chars[i - <span class="number">1</span>]).append(repeat);</span><br><span class="line">                repeat = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == chars.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    sb.append(chars[i]).append(repeat);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S.length() &lt;= sb.length() ? S : sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-01-07-Rotate-Matrix"><a href="#LCCI-01-07-Rotate-Matrix" class="headerlink" title="LCCI.01.07 Rotate Matrix"></a>LCCI.01.07 Rotate Matrix</h2><p>题目：</p>
<blockquote>
<p>Given an image represented by an N x N matrix, where each pixel in the image is 4 bytes, write a method to rotate the image by 90 degrees. Can you do this in place?</p>
</blockquote>
<p>一开始我的解题思路是通过新建一个二维数组，然后，将矩阵进行转换，按照<code>a=j,b=N-i-j</code>的逻辑转换，最后再将转换后的数组复制到原数组中。这样会导致空间复杂度为O(N)。看了书本上的解法是原地旋转，由外层向内层每一层都是将上边移到右边，右边移到下边，下边移到左边，左边移到上边。通过这种方式完成整个矩阵的旋转。这种方式的实现逻辑交易较为清晰，时间复杂度为O(N2)。修改我的解法后，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = matrix.length;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> layer = <span class="number">0</span>; layer &lt; N / <span class="number">2</span>; layer++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = layer; j &lt; N - layer - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> top = matrix[layer][j];</span><br><span class="line">            matrix[layer][j] = matrix[N - j - <span class="number">1</span>][layer];<span class="comment">//left-&gt;top</span></span><br><span class="line">            matrix[N - j - <span class="number">1</span>][layer] = matrix[N - layer - <span class="number">1</span>][N - j - <span class="number">1</span>];<span class="comment">//bottom-&gt;left</span></span><br><span class="line">            matrix[N - layer - <span class="number">1</span>][N - j - <span class="number">1</span>] = matrix[j][N - layer - <span class="number">1</span>];<span class="comment">//right-&gt;bottom</span></span><br><span class="line">            matrix[j][N - layer - <span class="number">1</span>] = top;<span class="comment">//top-&gt;right</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>矩阵旋转时，可以将矩阵的数组下标写出来，然后找出每一步转换的<code>i，j</code>的规律。一般无非就是<code>x=j,y=length-i-1</code>这种情况。</p>
<h2 id="LCCI-01-08-Zero-Matrix"><a href="#LCCI-01-08-Zero-Matrix" class="headerlink" title="LCCI.01.08 Zero Matrix"></a>LCCI.01.08 Zero Matrix</h2><p>题目：</p>
<blockquote>
<p>Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column are set to 0.</p>
</blockquote>
<p>我的思路是将矩阵中应该被清0的行和列分别用数组记录下来。然后再拿行数组和列数组处理矩阵中对应的行和列。但是这样占用的空间复杂度为O(N)。参考书本上给出的优化方案是，将矩阵的第一行和第一列作为行数组和列数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">       <span class="keyword">int</span> cloumns = matrix[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span>[] rowsToZero = <span class="keyword">new</span> <span class="keyword">int</span>[rows];</span><br><span class="line">       <span class="keyword">int</span>[] cloums = <span class="keyword">new</span> <span class="keyword">int</span>[cloumns];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                   rowsToZero[i]=<span class="number">1</span>;</span><br><span class="line">                   cloums[j]=<span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowsToZero.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (rowsToZero[i] == <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="comment">//set i row to 0</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">                   matrix[i][j]=<span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cloums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (cloums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix.length; j++) &#123;</span><br><span class="line">                   matrix[j][i]=<span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-01-09-String-Rotation"><a href="#LCCI-01-09-String-Rotation" class="headerlink" title="LCCI.01.09 String Rotation"></a>LCCI.01.09 String Rotation</h2><p>题目：</p>
<blockquote>
<p>Given two strings, s1 and s2, write code to check if s2 is a rotation of s1 (e.g.,”waterbottle” is a rotation of”erbottlewat”). Can you use only one call to the method that checks if one word is a substring of another?</p>
</blockquote>
<p>这一题我给它想的复杂了，第一反应是通过双指针来做，结果没有做出来。考虑的情况漏了。看了书本才想起用包含子串的方法应该是最简单的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlipedString</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.isEmpty() || s2.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.isEmpty() &amp;&amp; s2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() != s2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       String s1s1 = s1+s1;</span><br><span class="line">    <span class="keyword">return</span> s1s1.contains(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-02-01-Remove-Duplicate-Node"><a href="#LCCI-02-01-Remove-Duplicate-Node" class="headerlink" title="LCCI.02.01 Remove Duplicate Node"></a>LCCI.02.01 Remove Duplicate Node</h2><p>题目：</p>
<blockquote>
<p>Write code to remove duplicates from an unsorted linked list.</p>
</blockquote>
<p>此题的follow up是想让不用额外的空间来实现，于是我直接采用双指针法。一个指针指向尾部，另个之前在前面做判重。这样会增加时间复杂度，为O(N2)；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeDuplicateNodes</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode tail = head;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    <span class="keyword">while</span> (tail.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = tail.next;</span><br><span class="line">        <span class="keyword">boolean</span> nextIsDup = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 != tail.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.val == next.val) &#123;</span><br><span class="line">                nextIsDup = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1= head;</span><br><span class="line">        <span class="keyword">if</span> (nextIsDup) &#123;</span><br><span class="line">            <span class="comment">//delete current node</span></span><br><span class="line">            tail.next= next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            tail = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-02-02-Kth-Node-From-End-of-List"><a href="#LCCI-02-02-Kth-Node-From-End-of-List" class="headerlink" title="LCCI.02.02 Kth Node From End of List"></a>LCCI.02.02 Kth Node From End of List</h2><p>题目：</p>
<blockquote>
<p>Implement an algorithm to find the kth to last element of a singly linked list. Return the value of the element.</p>
</blockquote>
<p>这题的第一想法觉得很简单，用遍历就可以实现。看了follow up 说可以用递归和双指针。递归没有什么想法，于是便实现了一个双指针版本的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode b = head;</span><br><span class="line">    ListNode a = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">        b=b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (b.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        b=b.next;</span><br><span class="line">        a=a.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>贴上题解里的递归解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开始全局变量 K 保持不变</span></span><br><span class="line">    <span class="keyword">int</span> K = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当节点在最末尾时触发返回</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head.val;</span><br><span class="line">        <span class="comment">// 返回的值</span></span><br><span class="line">        <span class="keyword">int</span> val = kthToLast(head.next, k);</span><br><span class="line">        <span class="comment">// 一旦触发返回，从第一个产生返回的位置用 K 计数</span></span><br><span class="line">        <span class="keyword">if</span> (K++ &gt;= k) &#123;</span><br><span class="line">            <span class="comment">// 当到达或超过倒数第 k 时，即 K &gt;= k 时保持返回值不变</span></span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没到达则更新需要返回的值</span></span><br><span class="line">            <span class="keyword">return</span> head.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-02-03-Delete-Middle-Node"><a href="#LCCI-02-03-Delete-Middle-Node" class="headerlink" title="LCCI.02.03 Delete Middle Node"></a>LCCI.02.03 Delete Middle Node</h2><p>题目：</p>
<blockquote>
<p>Implement an algorithm to delete a node in the middle (i.e., any node but the first and last node, not necessarily the exact middle) of a singly linked list, given only access to that node.</p>
</blockquote>
<p>这题我并没有想到解法，其实链表的操作不应该被固定思维给限制住。这题可以通过将当前节点替换为下一节点，并将下一节点删除的方式来实现。代码也非常简单。主要考察的是这种思维。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    node.val=node.next.val;</span><br><span class="line">    node.next=node.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-02-04-Partition-List"><a href="#LCCI-02-04-Partition-List" class="headerlink" title="LCCI.02.04 Partition List"></a>LCCI.02.04 Partition List</h2><p>题目：</p>
<blockquote>
<p>Write code to partition a linked list around a value x, such that all nodes less than x come before all nodes greater than or equal to x. If x is contained within the list, the values of x only need to be after the elements less than x (see below). The partition element x can appear anywhere in the “right partition”; it does not need to appear between the left and right partitions.</p>
</blockquote>
<p>这一题我的思路是通过使用双指针来做，一个指针做遍历，另个指针指向小于x的数据的next。若遍历遇到小于x的值，则将其与小于x的next交换即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    ListNode p2 = head;</span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p2.val &lt; x) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = p1.val;</span><br><span class="line">            p1.val = p2.val;</span><br><span class="line">            p2.val = temp;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处需要注意的是，当我尝试使用如下异或来做交换操作时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1.val = p1.val^p2.val;</span><br><span class="line">p2.val = p1.val^p2.val;</span><br><span class="line">p1.val = p1.val^p2.val;</span><br></pre></td></tr></table></figure>
<p>发现在刚开始头指针指向同个对象时，对<code>p1.val</code>和<code>p2.val</code>做异或操作得出的值为0，再将0复制给<code>p1.val</code>，这样使得<code>p2.val</code>同时变为了0，因为<code>p1.val</code>和<code>p2.val</code>指向的是相同的值。</p>
<h2 id="LCCI-02-05-Sum-Lists"><a href="#LCCI-02-05-Sum-Lists" class="headerlink" title="LCCI.02.05 Sum Lists"></a>LCCI.02.05 Sum Lists</h2><p>题目：</p>
<blockquote>
<p>You have two numbers represented by a linked list, where each node contains a single digit. The digits are stored in reverse order, such that the 1’s digit is at the head of the list. Write a function that adds the two numbers and returns the sum as a linked list.</p>
</blockquote>
<p>这题一开始我的思路是将链表给合并成整数，再相加，然后再拆成链表。后来看了提示里说尝试用递归，才想到可以用递归来解决这个问题。刚开始的时候，递归写出来了，但是有几个用例总是执行不过，原因是我用的整型变量结果相加之后溢出了，改为了long之后发现还是会溢出。然后想到了不应该用中累加再拆成链表的方式。应该每一个节点算出对应的结果里的节点。递归时直接将节点拼接在一起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum(l1,l2,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode <span class="title">sum</span><span class="params">(ListNode s1, ListNode s2, <span class="keyword">int</span> buy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> currentLevelSum = s1.val + s2.val + buy;</span><br><span class="line">    ListNode currentNode = <span class="keyword">new</span> ListNode(currentLevelSum % <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (s1.next == <span class="keyword">null</span> &amp;&amp; s2.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentLevelSum / <span class="number">10</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            currentLevelSum = currentLevelSum/<span class="number">10</span>;</span><br><span class="line">            currentNode.next = <span class="keyword">new</span> ListNode(currentLevelSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line">    s1 = s1.next != <span class="keyword">null</span> ? s1.next : <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    s2 = s2.next != <span class="keyword">null</span> ? s2.next : <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    currentNode.next = sum(s1, s2, currentLevelSum / <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看题解中也有没有用递归的，不过也是类似的思想，不能将链表所有的数据都加起来再拆成链表， 那样会导致数据溢出。对于递归的题目我还是不太熟悉，做出来有点难度。</p>
<h2 id="LCCI-02-06-Palindrome-Linked-List"><a href="#LCCI-02-06-Palindrome-Linked-List" class="headerlink" title="LCCI.02.06  Palindrome Linked List"></a>LCCI.02.06  Palindrome Linked List</h2><p>题目：</p>
<blockquote>
<p>Implement a function to check if a linked list is a palindrome.</p>
</blockquote>
<p>这题我的思路是采用双指针或者反转整个链表再对比的方式。双指针我没有想到采用快慢指针这种方式，所以用了反转链表，但是没能实现follow up中的O(n)时间和O(1)空间的复杂度。贴上我的解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     ListNode p1 = head;</span><br><span class="line">     ListNode a = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">while</span> (p1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ListNode b = <span class="keyword">new</span> ListNode(p1.val);</span><br><span class="line">         p1 = p1.next;</span><br><span class="line">         b.next = a;</span><br><span class="line">         a = b;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (a.val != head.val) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         head = head.next;</span><br><span class="line">         a = a.next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-02-07-Intersection-of-Two-Linked-Lists"><a href="#LCCI-02-07-Intersection-of-Two-Linked-Lists" class="headerlink" title="LCCI.02.07 Intersection of Two Linked Lists"></a>LCCI.02.07 Intersection of Two Linked Lists</h2><p>题目:</p>
<blockquote>
<p>Given two (singly) linked lists, determine if the two lists intersect. Return the inter­ secting node. Note that the intersection is defined based on reference, not value. That is, if the kth node of the first linked list is the exact same node (by reference) as the jth node of the second linked list, then they are intersecting.</p>
</blockquote>
<p>这题我刚开始没什么好的思路，只有个暴力的算法思想，找不到能在O(n)时间和O(1)空间内解决的办法。看到了提示才想起来先将长度对齐再用双指针同时往后遍历找。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p1 = headA;</span><br><span class="line">    ListNode p2 = headB;</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        len1++;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        len2++;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode fast = len1 &gt; len2 ? headA : headB;</span><br><span class="line">    ListNode lag = len1 &gt; len2 ? headB : headA;</span><br><span class="line">    <span class="keyword">int</span> dis = len1 &gt; len2 ? len1 - len2 : len2 - len1;</span><br><span class="line">    <span class="keyword">while</span> (dis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">        dis--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast != lag) &#123;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">        lag=lag.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-02-08-Linked-List-Cycle"><a href="#LCCI-02-08-Linked-List-Cycle" class="headerlink" title="LCCI.02.08 Linked List Cycle"></a>LCCI.02.08 Linked List Cycle</h2><p>题目：</p>
<blockquote>
<p>Given a circular linked list, implement an algorithm that returns the node at the beginning of the loop.</p>
<p>Circular linked list: A (corrupt) linked list in which a node’s next pointer points to an earlier node, so as to make a loop in the linked list.</p>
</blockquote>
<p>这题我一开始没什么好的思路，后来只好用额外的空间将这题解出来了。使用set存储已经遍历过的节点，然后不停的往后将next 节点添加进set中，当发现添加失败时，即为循环的开始点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!set.add(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我看题解和书本上有种解法用的是快慢指针，先用快慢指针判断是否会碰撞，若不会碰撞则不会有循环。再判断快慢指针碰撞的位置。当慢指针到达loop点时，快指针为距离loop点的loopsize-k的位置，k为head距离loop点的距离。因此，当碰撞后，碰撞点距离loop点的距离为k。此时只需将慢指针指向head，快指针从碰撞点开始，二者以不断的next，当再次相等时，即为loop点。</p>
<h2 id="LCCI-03-01-Three-in-One"><a href="#LCCI-03-01-Three-in-One" class="headerlink" title="LCCI.03.01 Three in One"></a>LCCI.03.01 Three in One</h2><p>题目：</p>
<blockquote>
<p>Describe how you could use a single array to implement three stacks.</p>
<p>Yout should implement push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum) methods. stackNum is the index of the stack. value is the value that pushed to the stack.</p>
<p>The constructor requires a stackSize parameter, which represents the size of each stack.</p>
</blockquote>
<p>该题我一开始理解错了题意，并没有找出很好的解决办法。第一反应是将数组拆分为三份。但是我没有理解到构造器传进来的会是每个栈的长度。看了提示里有说使用环形数组来动态构建栈。这个我没有实现出来，感觉难度有点高，劝退了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TripleInOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] stackArray;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> eachStackSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] points = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TripleInOne</span><span class="params">(<span class="keyword">int</span> stackSize)</span> </span>&#123;</span><br><span class="line">            stackArray = <span class="keyword">new</span> <span class="keyword">int</span>[stackSize*<span class="number">3</span>];</span><br><span class="line">            eachStackSize = stackSize ;</span><br><span class="line">            points[<span class="number">0</span>] = eachStackSize;</span><br><span class="line">            points[<span class="number">1</span>] = eachStackSize * <span class="number">2</span>;</span><br><span class="line">            points[<span class="number">2</span>] = eachStackSize * <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isfull</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (points[stackNum] == eachStackSize * stackNum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> stackNum, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isfull(stackNum)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            points[stackNum] = points[stackNum] - <span class="number">1</span>;</span><br><span class="line">            stackArray[points[stackNum]] = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(stackNum)) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            points[stackNum] = points[stackNum] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> stackArray[points[stackNum] - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(stackNum)) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stackArray[points[stackNum]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (points[stackNum] == eachStackSize * (stackNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-03-02-Min-Stack"><a href="#LCCI-03-02-Min-Stack" class="headerlink" title="LCCI.03.02 Min Stack"></a>LCCI.03.02 Min Stack</h2><p>题目：</p>
<blockquote>
<p>How would you design a stack which, in addition to push and pop, has a function min which returns the minimum element? Push, pop and min should all operate in 0(1) time.</p>
</blockquote>
<p>这题我的思路是通过数组实现一个堆栈，要求在O(1)时间内返回pop和min，那么就只有用一个指针来记录栈顶和栈中最小值得位置。这么实现的后果是导致这个指针的维护比较复杂，从而在提交的时候报了好几次错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> topPoint = array.length;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> minPoint = array.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * initialize your data structure here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (topPoint == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length * <span class="number">2</span>];</span><br><span class="line">                System.arraycopy(array, <span class="number">0</span>, temp, temp.length - array.length, array.length);</span><br><span class="line">                topPoint = temp.length - array.length;</span><br><span class="line">                minPoint = minPoint + temp.length - array.length;</span><br><span class="line">                array = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            topPoint = topPoint - <span class="number">1</span>;</span><br><span class="line">            array[topPoint] = x;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; array[minPoint]) &#123;</span><br><span class="line">                minPoint = topPoint;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (minPoint == topPoint &amp;&amp; minPoint &lt; array.length - <span class="number">1</span>) &#123;</span><br><span class="line">                minPoint = minPoint + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = minPoint ; i &lt; array.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (array[i] &lt; array[minPoint]) &#123;</span><br><span class="line">                        minPoint=i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            topPoint = topPoint + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> array[topPoint];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> array[minPoint];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我看书本上这题用的是java本身的Stack类来实现的。再用额外的栈来保存最小值。这样实现起来会简单很多。</p>
<h2 id="LCCI-03-03-Stack-of-Plates"><a href="#LCCI-03-03-Stack-of-Plates" class="headerlink" title="LCCI.03.03 Stack of Plates"></a>LCCI.03.03 Stack of Plates</h2><p>题目：</p>
<blockquote>
<p>Imagine a (literal) stack of plates. If the stack gets too high, it might topple. Therefore, in real life, we would likely start a new stack when the previous stack exceeds some threshold. Implement a data structure SetOfStacks that mimics this. SetOfStacks should be composed of several stacks and should create a new stack once the previous one exceeds capacity. SetOfStacks.push() and SetOfStacks.pop() should behave identically to a single stack (that is, pop() should return the same values as it would if there were just a single stack). Follow Up: Implement a function popAt(int index) which performs a pop operation on a specific sub-stack.</p>
<p>You should delete the sub-stack when it becomes empty. pop, popAt should return -1 when there’s no element to pop.</p>
</blockquote>
<p>这题的思想比较简单，但是代码实现较为复杂。我写了很久没能够通过所有的测试用例。最后参考题解里的答案才写了出来。基本思路跟我的是类似的，但是我在代码实现的时候没能够处理好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackOfPlates</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line">        <span class="keyword">private</span> List&lt;Stack&gt; stack = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StackOfPlates</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">            stack.add(<span class="keyword">new</span> Stack&lt;&gt;());</span><br><span class="line">            <span class="keyword">this</span>.cap = cap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (cap &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()||stack.get(stack.size()-<span class="number">1</span>).size() == cap) &#123;</span><br><span class="line">                stack.add(<span class="keyword">new</span> Stack&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            stack.get(stack.size()-<span class="number">1</span>).push(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> popAt(stack.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">popAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (index&lt;<span class="number">0</span> || index &gt;= stack.size()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Stack&lt;Integer&gt; indexStack = stack.get(index);</span><br><span class="line">            <span class="keyword">if</span> (indexStack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> val = indexStack.pop();</span><br><span class="line">            <span class="keyword">if</span> (indexStack.isEmpty()) &#123;</span><br><span class="line">                stack.remove(indexStack);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-03-04-Implement-Queue-using-Stacks"><a href="#LCCI-03-04-Implement-Queue-using-Stacks" class="headerlink" title="LCCI.03.04 Implement Queue using Stacks"></a>LCCI.03.04 Implement Queue using Stacks</h2><p>题目：</p>
<blockquote>
<p>Implement a MyQueue class which implements a queue using two stacks.</p>
</blockquote>
<p>这题的关键在于队列是先入先出的顺序，而堆栈是后入先出的顺序。因此使用两个堆栈，一个堆栈用于队列的pop和peek，另个队列用于队列的push。这样在需要出队时，只需要将用于push的堆栈出栈再入栈到另个堆栈中。最后使用另个堆栈完成pop和peek即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> Stack&lt;Integer&gt; oldStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">private</span> Stack&lt;Integer&gt; newStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Initialize your data structure here.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Push element x to the back of queue.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">           newStack.push(x);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (oldStack.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">while</span> (!newStack.isEmpty()) &#123;</span><br><span class="line">                   oldStack.push(newStack.pop());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> oldStack.pop();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Get the front element.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (oldStack.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">while</span> (!newStack.isEmpty()) &#123;</span><br><span class="line">                   oldStack.push(newStack.pop());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> oldStack.peek();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Returns whether the queue is empty.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> oldStack.isEmpty() &amp;&amp; newStack.isEmpty();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-03-05-Sort-of-Stacks"><a href="#LCCI-03-05-Sort-of-Stacks" class="headerlink" title="LCCI.03.05 Sort of Stacks"></a>LCCI.03.05 Sort of Stacks</h2><p>题目：</p>
<blockquote>
<p>Write a program to sort a stack such that the smallest items are on the top. You can use an additional temporary stack, but you may not copy the elements into any other data structure (such as an array). The stack supports the following operations: push, pop, peek, and isEmpty. When the stack is empty, peek should return -1.</p>
</blockquote>
<p>这题跟上面题目类似，采用额外的一个堆栈来存储一部分数据。因为排序的堆栈栈顶是最小的，因此可以用另外个堆栈存小于push的值得数据。然后再把小于的那部分值pop出来，加入到排序堆栈中。一开始我在每次push完后都会将小于当前push值得数据都放回到排序堆栈中，后来看了题解，可以采用懒加载的方式。只在需要pop和peek的时候才做这些工作。这样使得我的运行时间得到了很大的优化，从205ms降到了27ms。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedStack</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Stack&lt;Integer&gt; sortedStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> Stack&lt;Integer&gt; tempStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SortedStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (sortedStack.isEmpty() &amp;&amp; tempStack.isEmpty()) &#123;</span><br><span class="line">                sortedStack.push(val);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (sortedStack.peek() &lt; val) &#123;</span><br><span class="line">                tempStack.push(sortedStack.pop());</span><br><span class="line">                <span class="keyword">if</span> (sortedStack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!sortedStack.isEmpty() &amp;&amp; !tempStack.isEmpty() &amp;&amp; sortedStack.peek() &gt; val &amp;&amp;</span><br><span class="line">                    tempStack.peek() &gt; val) &#123;</span><br><span class="line">                sortedStack.push(tempStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            sortedStack.push(val);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!tempStack.isEmpty()) &#123;</span><br><span class="line">                sortedStack.push(tempStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sortedStack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sortedStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!tempStack.isEmpty()) &#123;</span><br><span class="line">                sortedStack.push(tempStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sortedStack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sortedStack.peek();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sortedStack.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-03-06-Animal-Shelter"><a href="#LCCI-03-06-Animal-Shelter" class="headerlink" title="LCCI.03.06 Animal Shelter"></a>LCCI.03.06 Animal Shelter</h2><p>题目：</p>
<blockquote>
<p>An animal shelter, which holds only dogs and cats, operates on a strictly”first in, first out” basis. People must adopt either the”oldest” (based on arrival time) of all animals at the shelter, or they can select whether they would prefer a dog or a cat (and will receive the oldest animal of that type). They cannot select which specific animal they would like. Create the data structures to maintain this system and implement operations such as enqueue, dequeueAny, dequeueDog, and dequeueCat. You may use the built-in Linked list data structure.</p>
<p>enqueue method has a animal parameter, animal[0] represents the number of the animal, animal[1] represents the type of the animal, 0 for cat and 1 for dog.</p>
<p>dequeue* method returns [animal number, animal type], if there’s no animal that can be adopted, return [-1, -1].</p>
</blockquote>
<p>这题比较简单，思路就是使用LinkedList来将保存数组。然后在取出的时候，遍历链表判断是猫是狗，再将取出的节点删除即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalShelf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> LinkedList&lt;<span class="keyword">int</span>[]&gt; shelter = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] negative = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AnimalShelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span>[] animal)</span> </span>&#123;</span><br><span class="line">            shelter.add(animal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] dequeueAny() &#123;</span><br><span class="line">            <span class="keyword">if</span> (shelter.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> negative;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> shelter.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] dequeueDog() &#123;</span><br><span class="line">            <span class="keyword">if</span> (shelter.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> negative;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shelter.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shelter.get(i)[<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> shelter.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> negative;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] dequeueCat() &#123;</span><br><span class="line">            <span class="keyword">if</span> (shelter.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> negative;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shelter.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shelter.get(i)[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> shelter.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> negative;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个需要注意的点就是，LinkedList是可以用来保存数组的，而且不需要是包装类型<code>Integer</code>，直接是原始类型数组即可<code>int[]</code>。</p>
<h2 id="LCCI-04-01-Route-Between-Nodes"><a href="#LCCI-04-01-Route-Between-Nodes" class="headerlink" title="LCCI.04.01 Route Between Nodes"></a>LCCI.04.01 Route Between Nodes</h2><p>题目：</p>
<blockquote>
<p>Given a directed graph, design an algorithm to find out whether there is a route between two nodes.</p>
</blockquote>
<p>这题是典型的图的搜索应用场景，可以使用BFS和DFS。使用BFS可以尽快的搜索到需要的目标，因此这题我采用的是BFS。BFS有着典型的实现方式模板，这题我就是套用了模板。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findWhetherExistsPath</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] graph, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; breathList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        HashMap&lt;Integer, Set&lt;Integer&gt;&gt; temp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : graph) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = ints[<span class="number">0</span>];</span><br><span class="line">            Set&lt;Integer&gt; valueList = temp.computeIfAbsent(key,r-&gt;<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            valueList.add(ints[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; nodeSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        nodeSet.add(start);</span><br><span class="line">        breathList.add(start);</span><br><span class="line">        <span class="keyword">while</span> (!breathList.isEmpty()) &#123;</span><br><span class="line">            Integer first = breathList.removeFirst();</span><br><span class="line">            <span class="keyword">if</span> (first == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从图中获取该节点的所有相关点</span></span><br><span class="line">            Set&lt;Integer&gt; adjacent = temp.get(first);</span><br><span class="line">            <span class="keyword">if</span> (adjacent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Integer i : adjacent) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!nodeSet.contains(i)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == target) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        nodeSet.add(i);</span><br><span class="line">                        breathList.add(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nodeSet.add(first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-04-02-Minimum-Height-Tree"><a href="#LCCI-04-02-Minimum-Height-Tree" class="headerlink" title="LCCI.04.02 Minimum Height Tree"></a>LCCI.04.02 Minimum Height Tree</h2><p>题目：</p>
<blockquote>
<p>Given a sorted (increasing order) array with unique integer elements, write an algo­rithm to create a binary search tree with minimal height.</p>
</blockquote>
<p>这题我参考了书本上的解答，才发现可以这么用递归来解决。有点类似与二分法的解答：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createTreeNode(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">createTreeNode</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> midIndex = (start + end) / <span class="number">2</span>;</span><br><span class="line">        TreeNode mid = <span class="keyword">new</span> TreeNode(nums[midIndex]);</span><br><span class="line">        mid.left = createTreeNode(nums, start, midIndex - <span class="number">1</span>);</span><br><span class="line">        mid.right = createTreeNode(nums, midIndex + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-04-03-List-of-Depth"><a href="#LCCI-04-03-List-of-Depth" class="headerlink" title="LCCI.04.03 List of Depth"></a>LCCI.04.03 List of Depth</h2><p>题目：</p>
<blockquote>
<p>Given a binary tree, design an algorithm which creates a linked list of all the nodes at each depth (e.g., if you have a tree with depth D, you’ll have D linked lists). Return a array containing all the linked lists.</p>
</blockquote>
<p>我的思路是按照广度优先的算法进行遍历，然后将每一层的数据放入到list中。实现起来比我想象的要难一些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode[] listOfDepth(TreeNode tree) &#123;</span><br><span class="line">        List&lt;ListNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode depthPoint = <span class="keyword">new</span> ListNode(tree.val);</span><br><span class="line">        TreeNode head = tree;</span><br><span class="line">        Queue&lt;TreeNode&gt; nextDepList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; tempnextDepList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        nextDepList.add(head);</span><br><span class="line">        <span class="keyword">while</span> (!nextDepList.isEmpty()) &#123;</span><br><span class="line">            tempnextDepList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            TreeNode poll = nextDepList.poll();</span><br><span class="line">            <span class="keyword">if</span> (poll.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                tempnextDepList.add(poll.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (poll.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                tempnextDepList.add(poll.right);</span><br><span class="line">            &#125;</span><br><span class="line">            depthPoint = <span class="keyword">new</span> ListNode(poll.val);</span><br><span class="line">            ListNode a = depthPoint;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode treeNode : nextDepList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (treeNode.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    tempnextDepList.add(treeNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (treeNode.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    tempnextDepList.add(treeNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">                a.next = <span class="keyword">new</span> ListNode(treeNode.val);</span><br><span class="line">                a = a.next;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(depthPoint);</span><br><span class="line">            nextDepList = tempnextDepList;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode[] resArray = <span class="keyword">new</span> ListNode[res.size()];</span><br><span class="line">        res.toArray(resArray);</span><br><span class="line">        <span class="keyword">return</span> resArray ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-04-04-Check-Balance"><a href="#LCCI-04-04-Check-Balance" class="headerlink" title="LCCI.04.04 Check Balance"></a>LCCI.04.04 Check Balance</h2><p>题目：</p>
<blockquote>
<p>Implement a function to check if a binary tree is balanced. For the purposes of this question, a balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one.</p>
</blockquote>
<p>一开始想的是用DFS做，看了提示后觉得可以用递归来实现。但是一直没有完成将结果返回出来的处理。参考书本后写出了传递结果的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = checkHeight(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> i != Integer.MIN_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkHeight</span><span class="params">(TreeNode node, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    k++;</span><br><span class="line">    <span class="keyword">int</span> left = checkHeight(node.left, k);</span><br><span class="line">    <span class="keyword">if</span> (left == Integer.MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> right = checkHeight(node.right, k);</span><br><span class="line">    <span class="keyword">if</span> (right == Integer.MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> highAbs = Math.abs(left - right);</span><br><span class="line">    <span class="keyword">if</span> (highAbs &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left &gt; right ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-04-05-Legal-Binary-Search-Tree"><a href="#LCCI-04-05-Legal-Binary-Search-Tree" class="headerlink" title="LCCI.04.05 Legal Binary Search Tree"></a>LCCI.04.05 Legal Binary Search Tree</h2><p>题目：</p>
<blockquote>
<p>Implement a function to check if a binary tree is a binary search tree.</p>
</blockquote>
<p>这题有两个关键点，第一点是要理解清楚二叉搜索树的定义。二叉搜索树要求：<strong>所有</strong>左边的节点小于或等于当前节点，而当前节点必须小于<strong>所有</strong>右边的节点。</p>
<p>有了这个条件，我们就可以写出满足二叉搜索树的条件：<code>currentNode.left.max&lt;=currentNode&lt;currentNode.right.min</code></p>
<p>我先参考了书本上的题解，是一种自顶而下的方法。我自己写了个自底向上的解法，需要将返回数据都封装在一个类里，进行结果返回给上一层处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//测试用例中根节点为null时返回true</span></span><br><span class="line">       &#125;</span><br><span class="line">       PacValue res = isBST(root, <span class="keyword">null</span>, root.val);</span><br><span class="line">       <span class="keyword">return</span> res.isRes();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于封装返回结果数据的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">PacValue</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> min;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> max;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMax</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.max = max;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> min;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMin</span><span class="params">(<span class="keyword">int</span> min)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.min = min;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRes</span><span class="params">(<span class="keyword">boolean</span> res)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.res = res;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">PacValue <span class="title">isBST</span><span class="params">(TreeNode node, Boolean isMax, Integer preNodeVal)</span> </span>&#123;</span><br><span class="line">       PacValue value = <span class="keyword">new</span> PacValue();</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//递归返回条件</span></span><br><span class="line">       &#125;</span><br><span class="line">       PacValue left = isBST(node.left, <span class="keyword">true</span>, node.val);</span><br><span class="line">       <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; !left.isRes()) &#123;</span><br><span class="line">           value.setRes(<span class="keyword">false</span>);<span class="comment">//左子树已不满足二叉搜索树时，直接向上传递结果</span></span><br><span class="line">           <span class="keyword">return</span> value;</span><br><span class="line">       &#125;</span><br><span class="line">       PacValue right = isBST(node.right, <span class="keyword">false</span>, node.val);</span><br><span class="line">       <span class="keyword">if</span> (right != <span class="keyword">null</span> &amp;&amp; !right.isRes()) &#123;</span><br><span class="line">           value.setRes(<span class="keyword">false</span>);<span class="comment">//右子树已不满足二叉搜索树时，直接向上传递结果</span></span><br><span class="line">           <span class="keyword">return</span> value;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//&lt;editor-fold desc="对于基线条件的处理"&gt;</span></span><br><span class="line">       <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">           value.setMax(node.val);<span class="comment">//左右子树都为空，则最大最小值为当前节点的值</span></span><br><span class="line">           value.setMin(node.val);</span><br><span class="line">           value.setRes(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 左子树为空，右子树不为空，若满足当前node小于右子树的最小值，则仍满足二叉搜索树的属性</span></span><br><span class="line"><span class="comment">            * 此时则最大值为右子树的最大值，最小值为当前节点值</span></span><br><span class="line"><span class="comment">            * 注意：此时若不满足属性，则最大值填了右子树最大值是错的，</span></span><br><span class="line"><span class="comment">            * 但是这样没有关系，因为一旦不满足属性递归不会再做处理直接层层向上传递false的结果</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           value.setMax(right.getMax());</span><br><span class="line">           value.setMin(node.val);</span><br><span class="line">           value.setRes(node.val &lt; right.getMin());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;<span class="comment">//类似上一种情况</span></span><br><span class="line">           value.setMax(node.val);</span><br><span class="line">           value.setMin(left.getMin());</span><br><span class="line">           value.setRes(node.val &gt; left.getMax());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 左右子树都不为空，则按照当前节点小于右子树的最小值，并大于左子树的最大值来进行判断是否</span></span><br><span class="line"><span class="comment">            * 满足二叉搜索树的属性</span></span><br><span class="line"><span class="comment">            * 此时，若满足属性则最小值为左子树的最小值，最大值为右子树的最大值。</span></span><br><span class="line"><span class="comment">            * 若不满足属性，此时的最大最小值设置是错的，但是没有关系，不满足属性的结果会直接向上传递。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           value.setRes(node.val &gt; left.getMax() &amp;&amp; node.val &lt; right.getMin());</span><br><span class="line">           value.setMin(left.getMin());</span><br><span class="line">           value.setMax(right.getMax());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//&lt;/editor-fold&gt;</span></span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-04-06-Successor-LCCI"><a href="#LCCI-04-06-Successor-LCCI" class="headerlink" title="LCCI.04.06 Successor LCCI"></a>LCCI.04.06 Successor LCCI</h2><p>题目：</p>
<blockquote>
<p>Write an algorithm to find the “next” node (i.e., in-order successor) of a given node in a binary search tree.</p>
<p>Return null if there’s no “next” node for the given node.</p>
</blockquote>
<p>这题我第一遍没有做出来，递归写的太复杂。看了书本上的答案也只是给出了伪代码，参考题解后发现有大神给出了很厉害的解法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> searchInorder(root, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode <span class="title">searchInorder</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= p.val) &#123;</span><br><span class="line">        TreeNode right = searchInorder(root.right, p);</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode left = searchInorder(root.left, p);</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? root : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我觉得这题的关键在于依赖了完全搜索二叉树的性质，按照中序遍历完全搜索二叉树得出的是一个有序数组。因此访问中序遍历的下个节点，即可理解为访问大于当前节点值得下一个节点。</p>
<h2 id="LCCI-04-08-First-Common-Ancestor"><a href="#LCCI-04-08-First-Common-Ancestor" class="headerlink" title="LCCI.04.08 First Common Ancestor"></a>LCCI.04.08 First Common Ancestor</h2><p>题目：</p>
<blockquote>
<p>Design an algorithm and write code to find the first common ancestor of two nodes in a binary tree. Avoid storing additional nodes in a data structure. NOTE: This is not necessarily a binary search tree</p>
</blockquote>
<p>这题我看了题解之后有了思路，其实二叉树搜索的解法与遍历递归的思想是一样的，要么自顶而下，要么自底而上。这一题要找公共祖先，则自顶而下的方法相对容易。于是先开始在根节点的左子树查找，找不到的话再从右子树查找，左右子树都没有则只有返回当前节点了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (containpq(root.left, p, q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (containpq(root.right, p, q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containpq</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root != <span class="keyword">null</span> &amp;&amp; forwardFind(root, p, q, <span class="number">0</span>)&gt;=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">forwardFind</span><span class="params">(TreeNode root, TreeNode p, TreeNode q, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    k = forwardFind(root.left, p, q, k);</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val == p.val || root.val == q.val) &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    k = forwardFind(root.right, p, q, k);</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我的实现方法多了一个判断是否存在于子树的递归方法，使得我的解法耗时较长。参考题解，有个大神的解法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == p.val || root.val == q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这题的思想与我的基本类似，只是作者没有用判断是否存在于子树来作为递归的条件。直接当前节点与p或q相等时返回当前节点。这里不用再继续往下遍历的原因是，若q或p在当前节点的子节点，那么当前节点就是第一个公共父节点。因此可以直接返回。若既不在左子树又不在右子树则直接返回null，通过返回结果是否为null来判断是否在子树中，这样就可以把我的containpq方法的逻辑给合并了。</p>
<h2 id="LCCI-04-10-Check-SubTree"><a href="#LCCI-04-10-Check-SubTree" class="headerlink" title="LCCI.04.10 Check SubTree"></a>LCCI.04.10 Check SubTree</h2><p>题目：</p>
<blockquote>
<p>T1 and T2 are two very large binary trees, with T1 much bigger than T2. Create an algorithm to determine if T2 is a subtree of T1.</p>
<p>A tree T2 is a subtree of T1 if there exists a node n in T1 such that the subtree of n is identical to T2. That is, if you cut off the tree at node n, the two trees would be identical.</p>
</blockquote>
<p>这题主要的要点在于如何理解两个树是相等的，可以采用前序遍历后的结果转换为字符串进行对比。要注意一下：中序遍历即使是不同的结构，也有可能产生相同的结果。但是前序遍历时，只要将为null的节点标识出来即可确定只有相同的树结构才能产生相同的结果。因为前序遍历的第一个节点一定是根节点，可以确定根节点，再确定左右节点，即可保证树的结构相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubTree</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    StringBuilder a = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    StringBuilder b = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    forwardTree(t1, a);</span><br><span class="line">    forwardTree(t2, b);</span><br><span class="line">    <span class="keyword">return</span> a.indexOf(b.toString())!=-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forwardTree</span><span class="params">(TreeNode root, StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        stringBuilder.append(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stringBuilder.append(root.val);</span><br><span class="line">    forwardTree(root.left,stringBuilder);</span><br><span class="line">    forwardTree(root.right,stringBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-04-12-Paths-with-Sum"><a href="#LCCI-04-12-Paths-with-Sum" class="headerlink" title="LCCI.04.12 Paths with Sum"></a>LCCI.04.12 Paths with Sum</h2><p>题目：</p>
<blockquote>
<p>You are given a binary tree in which each node contains an integer value (which might be positive or negative). Design an algorithm to count the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p>
</blockquote>
<p>此题可以参考书本上的解法，先从暴力求解的思路来想，需要将每个节点作为根节点，遍历其至底部节点的路径和。在这个过程中，我们不断重复计算了同个路径下的不同子路径的路径和。将其看成数组，即为求解数组中和为targetSum的区间有几个。我们可以采取类似时间轴的方式，累积每个节点路径和。将其放入到Map中，再用类似twosum的思想，遍历数组的每个节点，能得出距其targetsum的节点数。详细的可以看下书本上的解答。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> countPaths(root, <span class="keyword">new</span> HashMap&lt;&gt;(), sum, <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">countPaths</span><span class="params">(TreeNode root, HashMap&lt;Integer, Integer&gt; pathSumValueCount, <span class="keyword">int</span> targetSum, <span class="keyword">int</span> pathSum)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     pathSum = pathSum + root.val;</span><br><span class="line">     <span class="keyword">int</span> totalPath = pathSumValueCount.getOrDefault(pathSum - targetSum, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">if</span> (pathSum == targetSum) &#123;</span><br><span class="line">         totalPath++;</span><br><span class="line">     &#125;</span><br><span class="line">     handlePathSumMap(pathSumValueCount, pathSum, <span class="number">1</span>);</span><br><span class="line">     totalPath += countPaths(root.left, pathSumValueCount, targetSum, pathSum);</span><br><span class="line">     totalPath += countPaths(root.right, pathSumValueCount, targetSum, pathSum);</span><br><span class="line">     handlePathSumMap(pathSumValueCount, pathSum, -<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> totalPath;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">handlePathSumMap</span><span class="params">(HashMap&lt;Integer, Integer&gt; pathSumValueCount, <span class="keyword">int</span> pathSum, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">     Integer paths = pathSumValueCount.computeIfAbsent(pathSum, s -&gt; <span class="number">0</span>);</span><br><span class="line">     pathSumValueCount.put(pathSum, paths + delta);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-05-01-Insert-Into-Bits"><a href="#LCCI-05-01-Insert-Into-Bits" class="headerlink" title="LCCI.05.01 Insert Into Bits"></a>LCCI.05.01 Insert Into Bits</h2><p>题目：</p>
<blockquote>
<p>You are given two 32-bit numbers, N and M, and two bit positions, i and j. Write a method to insert M into N such that M starts at bit j and ends at bit i. You can assume that the bits j through i have enough space to fit all of M. That is, if M = 10011, you can assume that there are at least 5 bits between j and i. You would not, for example, have j = 3 and i = 2, because M could not fully fit between bit 3 and bit 2.</p>
</blockquote>
<p>这题主要考察的是如何通过位运算更新值，取出值。一开始按照书本上的解答做出来发现无法通过一个测试案例，查看评论才发现是当左移位数超过31时，符号位并没有改变。因此需要做一个特殊处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertBits</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= <span class="number">31</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; j - <span class="number">31</span>; b++) &#123;</span><br><span class="line">            left = left | <span class="number">1</span> &lt;&lt; b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = ~<span class="number">0</span> &lt;&lt; (j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> right = (<span class="number">1</span> &lt;&lt; (i)) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mask = left | right;</span><br><span class="line">    N = N &amp; mask;</span><br><span class="line">    <span class="keyword">return</span> N | (M &lt;&lt; i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-05-02-Binary-Number-to-String"><a href="#LCCI-05-02-Binary-Number-to-String" class="headerlink" title="LCCI.05.02 Binary Number to String"></a>LCCI.05.02 Binary Number to String</h2><p>题目：</p>
<blockquote>
<p>Given a real number between O and 1 (e.g., 0.72) that is passed in as a double, print the binary representation. If the number cannot be represented accurately in binary with at most 32 characters, print “ERROR”.</p>
</blockquote>
<p>这题的重点在于怎么理解小数的二进制表达。小数的二进制表达用的是逼近的方式：$$0.625=二进制的0.101=1\times1/2^{1}+0\times1/2^{2}+1\times1/2^{3}=1\times0.5+0\times0.25+1\times0.125$$.因此我们可以使用乘以2的方式来将小数点后的二进制往左移位。因为double类型的数据不支持直接移位运算符<code>&lt;&lt;</code>，所以必须采用乘以2的方式来完成左移。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public String printBin(double num) &#123;</span><br><span class="line">    if (num &gt;= 1 || num &lt;= 0) &#123;</span><br><span class="line">        return &quot;ERROR&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    sb.append(&quot;0.&quot;);</span><br><span class="line">    while (num &gt; 0) &#123;</span><br><span class="line">        if (sb.length() &gt; 32) &#123;</span><br><span class="line">            return &quot;ERROR&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        num = num * 2;</span><br><span class="line">        if (num &gt;= 1) &#123;</span><br><span class="line">            sb.append(&quot;1&quot;);</span><br><span class="line">            num = num - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sb.append(&quot;0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-05-03-Reverse-Bits"><a href="#LCCI-05-03-Reverse-Bits" class="headerlink" title="LCCI.05.03 Reverse Bits"></a>LCCI.05.03 Reverse Bits</h2><p>题目：</p>
<blockquote>
<p>You have an integer and you can flip exactly one bit from a 0 to a 1. Write code to find the length of the longest sequence of 1s you could create.</p>
</blockquote>
<p>此题的关键在于如何找出将一位0翻转为1后，连续的1最长的方法。参考书本答案后，给出如下解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (~num == <span class="number">0</span>) <span class="keyword">return</span> Integer.BYTES * <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> currentCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> prveCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            currentCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                prveCount = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prveCount = currentCount;</span><br><span class="line">            &#125;</span><br><span class="line">            currentCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxCount = Math.max(prveCount + currentCount + <span class="number">1</span>, maxCount);</span><br><span class="line">        num = num &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-05-04-Closed-Number"><a href="#LCCI-05-04-Closed-Number" class="headerlink" title="LCCI.05.04 Closed Number"></a>LCCI.05.04 Closed Number</h2><p>题目:</p>
<blockquote>
<p>Given a positive integer, print the next smallest and the next largest number that have the same number of 1 bits in their binary representation.</p>
</blockquote>
<p>此题的重点是要知道怎么分析问题，题目要求取出最相近的两个数。那么大的那个数应该是最右边非尾部的0变为1（假设为第i位），再在i的右边，从右往左插入n-1个1（n为i右边的1的个数）。</p>
<p>小的那个数应该是最右边非尾部的1变为0（假设为第j位），再在j的右边，从左往右插入m+1个1（m为j右边的1的个数）。</p>
<p>题目分析清楚后就是代码实现，代码实现的时候又很多细节需要注意，都写在注释里了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findClosedNumbers(<span class="keyword">int</span> num) &#123;</span><br><span class="line">      <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">      <span class="keyword">if</span> (num == <span class="number">0</span> || num == (~<span class="number">0</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line">      res[<span class="number">0</span>] = getNext(num);</span><br><span class="line">      res[<span class="number">1</span>] = getPrev(num);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPrev</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">boolean</span> find0 = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.BYTES * <span class="number">8</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((num &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>) &#123;</span><br><span class="line">              find0 = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (((num &amp; (<span class="number">1</span> &lt;&lt; i)) == (<span class="number">1</span> &lt;&lt; i))) &#123;</span><br><span class="line">              count++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (((num &amp; (<span class="number">1</span> &lt;&lt; i)) == (<span class="number">1</span> &lt;&lt; i)) &amp;&amp; find0) &#123;</span><br><span class="line">              <span class="comment">//将i位变为0  将i位右边全置为0 再添加count+1位的1</span></span><br><span class="line">              res = num &amp; (~(<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                  res = res &amp; (~(<span class="number">1</span> &lt;&lt; k));</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;<span class="comment">//由于count计数的时候将当前的1包含进去了，所以往右边添加1时不需要再将count+1了</span></span><br><span class="line">                  res = res | (<span class="number">1</span> &lt;&lt; (i - j));</span><br><span class="line">                  j++;</span><br><span class="line">                  count--;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">boolean</span> find1 = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">boolean</span> findFirstNotTail0 = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.BYTES * <span class="number">8</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((num &amp; (<span class="number">1</span> &lt;&lt; i)) == (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">              count++;</span><br><span class="line">              find1 = <span class="keyword">true</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//出现1之后的第一个0置为1，将该位右边全置为0，再从右往左放入count-1个1</span></span><br><span class="line">              <span class="keyword">if</span> (find1) &#123;</span><br><span class="line">                  res = num | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> k = i-<span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                      res = res &amp; (~(<span class="number">1</span> &lt;&lt; k));</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">                  <span class="keyword">while</span> ((count-<span class="number">1</span> ) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                      res = res | (<span class="number">1</span> &lt;&lt;  j);</span><br><span class="line">                      count--;</span><br><span class="line">                      j++;</span><br><span class="line">                  &#125;</span><br><span class="line">                  findFirstNotTail0 = <span class="keyword">true</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!findFirstNotTail0) &#123;</span><br><span class="line">          res = -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-05-06-Convert-Interger"><a href="#LCCI-05-06-Convert-Interger" class="headerlink" title="LCCI.05.06 Convert Interger"></a>LCCI.05.06 Convert Interger</h2><p>题目：</p>
<blockquote>
<p>Write a function to determine the number of bits you would need to flip to convert integer A to integer B.</p>
</blockquote>
<p>这题很容易就可以想到用异或来做，两个数相异或后，再取出异或后的数字中1的个数作为结果返回即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">convertInteger</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> C = A ^ B;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (C != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((C &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        C &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-05-07-Exchange"><a href="#LCCI-05-07-Exchange" class="headerlink" title="LCCI.05.07 Exchange"></a>LCCI.05.07 Exchange</h2><p>题目：</p>
<blockquote>
<p>Write a program to swap odd and even bits in an integer with as few instructions as possible (e.g., bit 0 and bit 1 are swapped, bit 2 and bit 3 are swapped, and so on).</p>
</blockquote>
<p>这题主要的思想在于需要取出奇数位和偶数位，再将奇数位逻辑右移1位，将偶数位左移1位。然后再二者相或即可得出交换后的值。此处需要注意的是用于取奇数位和偶数位的掩码怎么运算的。二进制的1010代表的是十进制的10，在十六进制中则是0xA。因此用于取奇数位的掩码则是0xAAAAAAAA，则取偶数位的掩码为0x55555555，或者用<code>~0xAAAAAAAA</code>也可以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">exchangeBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oddMask = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line">    <span class="keyword">int</span> oddNumber = num &amp; oddMask;</span><br><span class="line">    <span class="keyword">int</span> evenMask = ~<span class="number">0xAAAAAAAA</span>;</span><br><span class="line">    <span class="keyword">int</span> evenNumber = num &amp; evenMask;</span><br><span class="line">    <span class="keyword">return</span> (oddNumber &gt;&gt;&gt; <span class="number">1</span>) | (evenNumber &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-05-08-Draw-Line"><a href="#LCCI-05-08-Draw-Line" class="headerlink" title="LCCI.05.08 Draw Line"></a>LCCI.05.08 Draw Line</h2><p>题目：</p>
<blockquote>
<p>A monochrome screen is stored as a single array of int, allowing 32 consecutive pixels to be stored in one int. The screen has width w, where w is divisible by 32 (that is, no byte will be split across rows). The height of the screen, of course, can be derived from the length of the array and the width. Implement a function that draws a horizontal line from (x1, y) to (x2, y).</p>
<p>Given the length of the array, the width of the array (in bit), start position x1 (in bit) of the line, end position x2 (in bit) of the line and the row number y of the line, return the array after drawing.</p>
</blockquote>
<p>这题的重点在于需要理解清楚题目的意思。我采用了简单的将x1至x2区间内的0置为1的方法。这种解法实现起来较为简单，但是效率不高。使用掩码将x1和x2之间的整数1的位置整个置为1的效率更高。当然要考虑x1和x2处于同一区间中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] drawLine(<span class="keyword">int</span> length, <span class="keyword">int</span> w, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] screen = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> startIndex = (y * w + x1) / <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">int</span> startBitIndex = (y * w + x1) % <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">int</span> total = x2 - x1 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startBitIndex; i &lt; <span class="number">32</span> &amp;&amp; total &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">            current = current | (<span class="number">1</span> &lt;&lt; (<span class="number">31</span> - i));</span><br><span class="line">            total--;</span><br><span class="line">        &#125;</span><br><span class="line">        screen[startIndex++] = current;</span><br><span class="line">        current = <span class="number">0</span>;</span><br><span class="line">        startBitIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> screen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-08-01-Three-Steps-Problem"><a href="#LCCI-08-01-Three-Steps-Problem" class="headerlink" title="LCCI.08.01 Three Steps Problem"></a>LCCI.08.01 Three Steps Problem</h2><p>题目：</p>
<blockquote>
<p>A child is running up a staircase with n steps and can hop either 1 step, 2 steps, or 3 steps at a time. Implement a method to count how many possible ways the child can run up the stairs. The result may be large, so return it modulo 1000000007.</p>
</blockquote>
<p>做题最重要的果然还是看清楚题目，然后再写出解法。这题我一开始想的过于简单，以为是需要用乘法，实则不然。只需要<code>f(n)=f(n-1)+f(n-2)+f(n-3)</code>这个基线条件即可写出递归。但是由于测试案例中的数据量很大，因此需要处理数据溢出和递归深度的问题。后来改为了动态规划的解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToStep</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        d = ((a + b)%mod + c)%mod;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">        c=d;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-08-02-Robot-in-a-Grid"><a href="#LCCI-08-02-Robot-in-a-Grid" class="headerlink" title="LCCI.08.02  Robot in a Grid"></a>LCCI.08.02  Robot in a Grid</h2><p>题目：</p>
<blockquote>
<p>Imagine a robot sitting on the upper left corner of grid with r rows and c columns. The robot can only move in two directions, right and down, but certain cells are “off limits” such that the robot cannot step on them. Design an algorithm to find a path for the robot from the top left to the bottom right.</p>
</blockquote>
<p>这题的关键在于如何理解基线条件。需要自底向上的思考，找到最后一个需要一步步的往前找到倒数第二个，倒数第三个。然后遇到1的时候则返回失败。再对其失败的路线进行缓存，即是动态规划。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathWithObstacles(<span class="keyword">int</span>[][] obstacleGrid) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid == <span class="keyword">null</span> || obstacleGrid.length == <span class="number">0</span>|| obstacleGrid[<span class="number">0</span>]==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    HashSet&lt;List&lt;Integer&gt;&gt; failed = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (getPath(res, failed, obstacleGrid, obstacleGrid.length - <span class="number">1</span>, obstacleGrid[<span class="number">0</span>].length - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getPath</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, HashSet&lt;List&lt;Integer&gt;&gt; failed, <span class="keyword">int</span>[][] obstacleGrid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || (obstacleGrid[r][c] ==<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    List point = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    point.add(r);</span><br><span class="line">    point.add(c);</span><br><span class="line">    <span class="keyword">if</span> (failed.contains(point)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> isAtSourse = (r == <span class="number">0</span> &amp;&amp; c == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (isAtSourse || getPath(res, failed, obstacleGrid, r - <span class="number">1</span>, c) || getPath(res, failed, obstacleGrid, r, c - <span class="number">1</span>)) &#123;</span><br><span class="line">        res.add(point);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    failed.add(point);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-08-03-Magic-Index"><a href="#LCCI-08-03-Magic-Index" class="headerlink" title="LCCI.08.03 Magic Index"></a>LCCI.08.03 Magic Index</h2><p>题目：</p>
<blockquote>
<p>A magic index in an array A[0…n-1] is defined to be an index such that A[i] = i. Given a sorted array of distinct integers, write a method to find a magic index, if one exists, in array A. If not, return -1. If there are more than one magic index, return the smallest one.</p>
</blockquote>
<p>此题最简单的解法当然是用数组遍历，但是因为题目给出的条件是有序数组，因此可以利用排序来做。此题可以用递归实现二分法来解决。测试用例中存在重复的元素，因此需要处理下重复的元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> binaryFind(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">binaryFind</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span> (nums[mid] == mid) &#123;</span><br><span class="line">         <span class="keyword">return</span> mid;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> leftres = binaryFind(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">if</span> (leftres != -<span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> leftres;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> binaryFind(nums, mid + <span class="number">1</span>, end);;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>注意：当题目中给出了有序的条件时，一般来说这个条件是可以加以利用的。</p>
<h2 id="LCCI-08-04-Power-Set"><a href="#LCCI-08-04-Power-Set" class="headerlink" title="LCCI.08.04 Power Set"></a>LCCI.08.04 Power Set</h2><p>题目：</p>
<blockquote>
<p>Write a method to return all subsets of a set. The elements in a set are pairwise distinct.</p>
<p>Note: The result set should not contain duplicated subsets.</p>
</blockquote>
<p>此题类似与之前的三步问题，关键点在于找到基线条件：数组nums的子集为数组nums[n-1]的子集，将其复制一份然后每个加上nums[n]的元素即可。代码实现较为简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; sets = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        getSubSets(nums, nums.length-<span class="number">1</span>, sets);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(sets);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSubSets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, Set&lt;List&lt;Integer&gt;&gt; sets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sets.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getSubSets(nums, --i, sets);</span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; integerList : sets) &#123;</span><br><span class="line">            List&lt;Integer&gt; inn = <span class="keyword">new</span> ArrayList&lt;&gt;(integerList);</span><br><span class="line">            inn.add(nums[i+<span class="number">1</span>]);</span><br><span class="line">            temp.add(inn);</span><br><span class="line">        &#125;</span><br><span class="line">        sets.addAll(temp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看了题解中还有种解法是通过位来表示数组中的数字，这种思路很巧妙，不需要使用递归，直接将每个组合都打印出来即可。贴出题解：</p>
<blockquote>
<p>例如 [1, 2, 3] 有三位可以从 0 遍历到 7 也就是 2 ^ 3 - 1 用二进制表示就是 000, 001, 010, 011, 100, 101, 110, 111 正好代表了全部子集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">&gt;         List&lt;List&lt;Integer&gt;&gt; subsets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&gt;         <span class="keyword">int</span> bmp = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, nums.length);</span><br><span class="line">&gt;         <span class="comment">// 从 nums.length 个 0 遍历到 nums.length 个 1</span></span><br><span class="line">&gt;         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bmp; i++) &#123;</span><br><span class="line">&gt;             List&lt;Integer&gt; subset = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&gt;             <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)</span><br><span class="line">&gt;                 <span class="comment">// 将每一位右移最低位，检测其是否为1</span></span><br><span class="line">&gt;                 <span class="keyword">if</span> ((i &gt;&gt;&gt; j &amp; <span class="number">1</span>) == <span class="number">1</span>) subset.add(nums[j]);</span><br><span class="line">&gt;             subsets.add(subset);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> subsets;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="LCCI-08-05-Recursive-Multiply"><a href="#LCCI-08-05-Recursive-Multiply" class="headerlink" title="LCCI.08.05 Recursive Multiply"></a>LCCI.08.05 Recursive Multiply</h2><p>题目：</p>
<blockquote>
<p>Write a recursive function to multiply two positive integers without using the * operator. You can use addition, subtraction, and bit shifting, but you should minimize the number of those operations.</p>
</blockquote>
<p>这题有多种解法，我看了提示之后，写出了提示的解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (B == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> C = B &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> multiply(A, C) + multiply(A, B - C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-08-06-Hanota"><a href="#LCCI-08-06-Hanota" class="headerlink" title="LCCI.08.06 Hanota"></a>LCCI.08.06 Hanota</h2><p>题目：</p>
<blockquote>
<p>In the classic problem of the Towers of Hanoi, you have 3 towers and N disks of different sizes which can slide onto any tower. The puzzle starts with disks sorted in ascending order of size from top to bottom (i.e., each disk sits on top of an even larger one). You have the following constraints:</p>
<p>(1) Only one disk can be moved at a time.<br>(2) A disk is slid off the top of one tower onto another tower.<br>(3) A disk cannot be placed on top of a smaller disk.</p>
<p>Write a program to move the disks from the first tower to the last using stacks.</p>
</blockquote>
<p>汉诺塔的问题，思路是将n-1合并到一起，和第n个组成两个盘子的汉诺塔去递归求解。不需要特别仔细的去追究递归的过程。我一开始就陷入了追究递归的过程中去而导致没有找到答案，实际不需要。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        moveDisk(A.size() - <span class="number">1</span>, A, C, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveDisk</span><span class="params">(<span class="keyword">int</span> n, List&lt;Integer&gt; orign, List&lt;Integer&gt; dest, List&lt;Integer&gt; buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        moveDisk(n - <span class="number">1</span>, orign, buffer, dest);</span><br><span class="line">        dest.add(orign.remove(orign.size() - <span class="number">1</span>));</span><br><span class="line">        moveDisk(n - <span class="number">1</span>, buffer, dest, orign);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-08-07-Permutation"><a href="#LCCI-08-07-Permutation" class="headerlink" title="LCCI.08.07 Permutation"></a>LCCI.08.07 Permutation</h2><p>题目：</p>
<blockquote>
<p>Write a method to compute all permutations of a string of unique characters.</p>
</blockquote>
<p>这题与之前的一到题目很相似，先找到n-1个char组成的数组的所有排列组合，再将第n位的字符与之前所有的排列组合相累积在一起。这样即可得到长度为n的字符所有的排列组合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] permutation(String S) &#123;</span><br><span class="line">       List&lt;String&gt; res = permutationRecusive(S);</span><br><span class="line">       String[] ress = <span class="keyword">new</span> String[res.size()];</span><br><span class="line">       <span class="keyword">return</span> res.toArray(ress);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">List&lt;String&gt; <span class="title">permutationRecusive</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (S.length() == <span class="number">1</span>) &#123;</span><br><span class="line">           res.add(S);</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">char</span> c = S.charAt(i);</span><br><span class="line">           StringBuilder sb = <span class="keyword">new</span> StringBuilder(S);</span><br><span class="line">           sb.deleteCharAt(i);</span><br><span class="line">           List&lt;String&gt; te = permutationRecusive(sb.toString());</span><br><span class="line">           <span class="keyword">for</span> (String teString : te) &#123;</span><br><span class="line">               res.add(teString + c);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>看到题解中，大家普遍采用的是回溯算法，用深度优先搜索去实现的。贴出其中一个解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String S) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] array = S.toCharArray();</span><br><span class="line">        dfs(array, <span class="keyword">new</span> StringBuilder());</span><br><span class="line"></span><br><span class="line">        String[] res = <span class="keyword">new</span> String[list.size()];</span><br><span class="line">        <span class="keyword">return</span> list.toArray(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">char</span>[] array, StringBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (builder.length() == array.length) &#123;</span><br><span class="line">            list.add(builder.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (builder.toString().contains(String.valueOf(c))) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            builder.append(c);</span><br><span class="line">            dfs(array, builder);</span><br><span class="line">            builder.deleteCharAt(builder.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-08-09-Bracket"><a href="#LCCI-08-09-Bracket" class="headerlink" title="LCCI.08.09 Bracket"></a>LCCI.08.09 Bracket</h2><p>题目：</p>
<blockquote>
<p>Implement an algorithm to print all valid (e.g., properly opened and closed) combinations of n pairs of parentheses.</p>
<p>Note: The result set should not contain duplicated subsets.</p>
</blockquote>
<p>这题我是参考之前的套路采用的递归方式，先取出n-1的结果，再在n-1的结果上组装n的结果。看了题解有很多人采用的回溯的方法去做。关于回溯算法，我还是没有掌握。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        res.add(<span class="string">"()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(res);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; temp = generateParenthesis(--n);</span><br><span class="line">    <span class="keyword">for</span> (String s : temp) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                res.add(insertParent(s, i));</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="string">"()"</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">insertParent</span><span class="params">(String orign, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    String left = orign.substring(<span class="number">0</span>, offset + <span class="number">1</span>);</span><br><span class="line">    String right = orign.substring(offset + <span class="number">1</span>, orign.length());</span><br><span class="line">    <span class="keyword">return</span> left + <span class="string">"()"</span> + right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-08-10-Color-Fill"><a href="#LCCI-08-10-Color-Fill" class="headerlink" title="LCCI.08.10 Color Fill"></a>LCCI.08.10 Color Fill</h2><p>题目：</p>
<blockquote>
<p>Implement the “paint fill” function that one might see on many image editing programs. That is, given a screen (represented by a two-dimensional array of colors), a point, and a new color, fill in the surrounding area until the color changes from the original color.</p>
</blockquote>
<p>这题与之前的方格类似，我采用的也是类似于深度优先搜索的解法，一开始有用例没过去，其实可以采用特殊的处理方式将其规避。我采用的是动态规划的方式，将每个已经被填充的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">    <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[image.length][image[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">return</span> floodFill(image, sr, sc, newColor, image[sr][sc], memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor, <span class="keyword">int</span> origColor, <span class="keyword">int</span>[][] memo) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sr &lt; <span class="number">0</span> || sc &lt; <span class="number">0</span> || sr &gt; image.length - <span class="number">1</span> || sc &gt; image[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (origColor == image[sr][sc] &amp;&amp; memo[sr][sc] != <span class="number">1</span>) &#123;</span><br><span class="line">        image[sr][sc] = newColor;</span><br><span class="line">        memo[sr][sc] = <span class="number">1</span>;</span><br><span class="line">        image = floodFill(image, sr - <span class="number">1</span>, sc, newColor, origColor, memo);</span><br><span class="line">        image = floodFill(image, sr + <span class="number">1</span>, sc, newColor, origColor, memo);</span><br><span class="line">        image = floodFill(image, sr, sc - <span class="number">1</span>, newColor, origColor, memo);</span><br><span class="line">        image = floodFill(image, sr, sc + <span class="number">1</span>, newColor, origColor, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-08-11-Coin"><a href="#LCCI-08-11-Coin" class="headerlink" title="LCCI.08.11 Coin"></a>LCCI.08.11 Coin</h2><p>按照书本解法的动态规划未能通过，金额总是变化导致动态规划的存储内容失效</p>
<h2 id="LCCI-08-12-Eight-Queens"><a href="#LCCI-08-12-Eight-Queens" class="headerlink" title="LCCI.08.12 Eight Queens"></a>LCCI.08.12 Eight Queens</h2><p>题目：</p>
<blockquote>
<p>Write an algorithm to print all ways of arranging n queens on an n x n chess board so that none of them share the same row, column, or diagonal. In this case, “diagonal” means all diagonals, not just the two that bisect the board.</p>
</blockquote>
<p>这题我是参考的书本上的解法，我一开始么有想到好的递归写法。写递归的时候还是有时候无法组织清楚，还需要加强练习：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">     List&lt;Integer[]&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     List&lt;List&lt;String&gt;&gt; stringRes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     placeQueen(result, <span class="number">0</span>, <span class="keyword">new</span> Integer[n], n);</span><br><span class="line">     <span class="keyword">for</span> (Integer[] integerArray : result) &#123;</span><br><span class="line">         List&lt;String&gt; stringList = transString(integerArray);</span><br><span class="line">         stringRes.add(stringList);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> stringRes;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">transString</span><span class="params">(Integer[] arrays)</span> </span>&#123;</span><br><span class="line">     List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrays.length; i++) &#123;</span><br><span class="line">         Integer columns = arrays[i];</span><br><span class="line">         StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arrays.length; j++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (columns==j) &#123;</span><br><span class="line">                 sb.append(<span class="string">'Q'</span>);</span><br><span class="line">             &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                 sb.append(<span class="string">'.'</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         res.add(sb.toString());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">placeQueen</span><span class="params">(List&lt;Integer[]&gt; result, <span class="keyword">int</span> row, Integer[] columns, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">         result.add(columns.clone());</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (checkValid(row, col, columns)) &#123;</span><br><span class="line">                 columns[row] = col;</span><br><span class="line">                 placeQueen(result, row + <span class="number">1</span>, columns, n);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkValid</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, Integer[] columns)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">         <span class="comment">//检查其他行的col列是否有数据</span></span><br><span class="line">         <span class="keyword">if</span> (columns[i] == col) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">int</span> columnDistance = Math.abs(columns[i] - col);</span><br><span class="line">         <span class="keyword">int</span> rowDistance = row - i;</span><br><span class="line">         <span class="keyword">if</span> (columnDistance == rowDistance) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这题的一个难点在于校验对角线：两个皇后之间的行距和列距相等则认为是在同一对角线上。另一个难点在于处理校验失败的情形。</p>
<h2 id="LCCI-08-13-Pile-Box"><a href="#LCCI-08-13-Pile-Box" class="headerlink" title="LCCI.08.13 Pile Box"></a>LCCI.08.13 Pile Box</h2><p>题目：</p>
<blockquote>
<p>You have a stack of n boxes, with widths wi, depths di, and heights hi. The boxes cannot be rotated and can only be stacked on top of one another if each box in the stack is strictly larger than the box above it in width, height, and depth. Implement a method to compute the height of the tallest possible stack. The height of a stack is the sum of the heights of each box.</p>
<p>The input use [wi, di, hi] to represents each box.</p>
</blockquote>
<p>这题我也是参考书本的解法才写出来的，主要思想就是通过dp来实现子问题的解，先将所有的箱子按照某一维度排序，再将每个箱子作为bottom来计算高度，取出最大的高度即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pileBox</span><span class="params">(<span class="keyword">int</span>[][] box)</span> </span>&#123;</span><br><span class="line">        sort(box);</span><br><span class="line">        <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[box.length];</span><br><span class="line">        <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; box.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> stackHeight = createStack(box, i, memo);</span><br><span class="line">            maxHeight = Math.max(stackHeight, maxHeight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[][] box)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; box.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; box.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (box[j][<span class="number">2</span>] &lt; box[j + <span class="number">1</span>][<span class="number">2</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span>[] temp = box[j];</span><br><span class="line">                    box[j] = box[j + <span class="number">1</span>];</span><br><span class="line">                    box[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">createStack</span><span class="params">(<span class="keyword">int</span>[][] box, <span class="keyword">int</span> bottomIndex, <span class="keyword">int</span>[] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[bottomIndex] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[bottomIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] bottom = box[bottomIndex];</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = bottomIndex + <span class="number">1</span>; i &lt; box.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canAbove(bottom, box[i])) &#123;</span><br><span class="line">                <span class="keyword">int</span> stackHight = createStack(box, i, memo);</span><br><span class="line">                height = Math.max(stackHight, height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        height += bottom[<span class="number">2</span>];</span><br><span class="line">        memo[bottomIndex] = height;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canAbove</span><span class="params">(<span class="keyword">int</span>[] lower, <span class="keyword">int</span>[] upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lower[<span class="number">0</span>] &gt; upper[<span class="number">0</span>] &amp;&amp; lower[<span class="number">1</span>] &gt; upper[<span class="number">1</span>] &amp;&amp; lower[<span class="number">2</span>] &gt; upper[<span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-08-14-Boolean-Evaluation"><a href="#LCCI-08-14-Boolean-Evaluation" class="headerlink" title="LCCI.08.14 Boolean Evaluation"></a>LCCI.08.14 Boolean Evaluation</h2><p>题目：</p>
<blockquote>
<p>Given a boolean expression consisting of the symbols 0 (false), 1 (true), &amp; (AND), | (OR), and ^ (XOR), and a desired boolean result value result, implement a function to count the number of ways of parenthesizing the expression such that it evaluates to result.</p>
</blockquote>
<p>这题参考题解，并对照着花花的1.4类型的动态规划解出来的，对动态规划有了更深的认识了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countEval</span><span class="params">(String s, <span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//区间长度，至少新增2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; len += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + len - <span class="number">1</span> &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][i + len - <span class="number">1</span>][s.charAt(i) == <span class="string">'0'</span> ? <span class="number">0</span> : <span class="number">1</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//遍历子区间的起点和终点，通过操作符分割左右两边。</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; i + len - <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">//第j位是分隔符的位置</span></span><br><span class="line">                    <span class="keyword">char</span> op = s.charAt(j);</span><br><span class="line">                    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'&amp;'</span>:</span><br><span class="line">                            <span class="comment">//分割符为 &amp; 时，左边为0，则右边为0或1均可</span></span><br><span class="line">                            dp[i][i + len - <span class="number">1</span>][<span class="number">0</span>] += dp[i][j - <span class="number">1</span>][<span class="number">0</span>] * (dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">0</span>] + dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">1</span>]) +</span><br><span class="line">                                    <span class="comment">//左边为1，则右边必须为0</span></span><br><span class="line">                                    dp[i][j - <span class="number">1</span>][<span class="number">1</span>] * dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                            dp[i][i + len - <span class="number">1</span>][<span class="number">1</span>] += dp[i][j - <span class="number">1</span>][<span class="number">1</span>] * dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'|'</span>:</span><br><span class="line">                            dp[i][i + len - <span class="number">1</span>][<span class="number">0</span>] += dp[i][j - <span class="number">1</span>][<span class="number">0</span>] * dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                            dp[i][i + len - <span class="number">1</span>][<span class="number">1</span>] += dp[i][j - <span class="number">1</span>][<span class="number">1</span>] * (dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">0</span>] + dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">1</span>]) +</span><br><span class="line">                                    dp[i][j - <span class="number">1</span>][<span class="number">0</span>] * dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'^'</span>:</span><br><span class="line">                            dp[i][i + len - <span class="number">1</span>][<span class="number">0</span>] += dp[i][j - <span class="number">1</span>][<span class="number">0</span>] * dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">0</span>] +</span><br><span class="line">                                    dp[i][j - <span class="number">1</span>][<span class="number">1</span>] * dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                            dp[i][i + len - <span class="number">1</span>][<span class="number">1</span>] += dp[i][j - <span class="number">1</span>][<span class="number">0</span>] * dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">1</span>] +</span><br><span class="line">                                    dp[i][j - <span class="number">1</span>][<span class="number">1</span>] * dp[j + <span class="number">1</span>][i + len - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>][result];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-10-01-Sorted-Merge"><a href="#LCCI-10-01-Sorted-Merge" class="headerlink" title="LCCI.10.01 Sorted Merge"></a>LCCI.10.01 Sorted Merge</h2><p>题目：</p>
<blockquote>
<p>You are given two sorted arrays, A and B, where A has a large enough buffer at the end to hold B. Write a method to merge B into A in sorted order.</p>
<p>Initially the number of elements in A and B are m and n respectively.</p>
</blockquote>
<p>这题我的思路比较粗暴简单，直接把B的数据放到A的后面，然后用快排来做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span>[] B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(B, <span class="number">0</span>, A, m, n);</span><br><span class="line">    quickSort(A, <span class="number">0</span>, m + n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pivot = array[end];</span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; end; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &lt; pivot) &#123;</span><br><span class="line">            swap(array,j,i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(array,i,end);</span><br><span class="line">    quickSort(array,start,i-<span class="number">1</span>);</span><br><span class="line">    quickSort(array,i+<span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> src, <span class="keyword">int</span> dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = A[src];</span><br><span class="line">    A[src] = A[dest];</span><br><span class="line">    A[dest] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-10-02-Group-Anagrams"><a href="#LCCI-10-02-Group-Anagrams" class="headerlink" title="LCCI.10.02 Group Anagrams"></a>LCCI.10.02 Group Anagrams</h2><p>题目：</p>
<blockquote>
<p>Write a method to sort an array of strings so that all the anagrams are in the same group.</p>
</blockquote>
<p>这题的难点有两个，一个是如何识别异位词，另个是处理整个数组中所有相同异位词的不同字符。采取了类似桶排序的思想：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; lengthStr = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        List&lt;String&gt; strings = lengthStr.computeIfAbsent(sortString(str), (k) -&gt; &#123;</span><br><span class="line">            List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            res.add(temp);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;);</span><br><span class="line">        strings.add(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">sortString</span><span class="params">(String orig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = orig.toCharArray();</span><br><span class="line">    Arrays.sort(chars);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-10-03-Search-Rotate-Array"><a href="#LCCI-10-03-Search-Rotate-Array" class="headerlink" title="LCCI.10.03 Search Rotate Array"></a>LCCI.10.03 Search Rotate Array</h2><p>题目：</p>
<blockquote>
<p>Given a sorted array of n integers that has been rotated an unknown number of times, write code to find an element in the array. You may assume that the array was originally sorted in increasing order. If there are more than one target elements in the array, return the smallest index.</p>
</blockquote>
<p>这题因为有一个迷惑，就是数组的翻转次数，其实无论数组翻转了多少次。最终只有一个乱序的区间。因此可以使用二分法，但是需要仔细的区分每种情况，在每个区间内做好判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &lt; arr[right]) &#123;</span><br><span class="line">                <span class="comment">//从mid至right之间是递增的</span></span><br><span class="line">                <span class="keyword">if</span> (arr[mid] &lt; target &amp;&amp; arr[right] &gt;= target &amp;&amp; target != arr[left]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;<span class="comment">//下一次从[mid+1,right]中查找</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid;<span class="comment">//下一次从[left，mid]中查找</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; arr[right]) &#123;</span><br><span class="line">                <span class="comment">//从left到mid之间是递增的</span></span><br><span class="line">                <span class="keyword">if</span> (arr[left] &lt;= target &amp;&amp; arr[mid] &gt;= target) &#123;</span><br><span class="line">                    right = mid;<span class="comment">//下一次从[left,mid]中查找</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;<span class="comment">//下一次从[mid+1,right]中查找</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//arr[mid] == arr[right]</span></span><br><span class="line">                <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right--;<span class="comment">//下一轮从 [left,right-1]</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[left] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-10-05-Sparse-Array-Search"><a href="#LCCI-10-05-Sparse-Array-Search" class="headerlink" title="LCCI.10.05 Sparse Array Search"></a>LCCI.10.05 Sparse Array Search</h2><p>题目：</p>
<blockquote>
<p>Given a sorted array of strings that is interspersed with empty strings, write a method to find the location of a given string.</p>
</blockquote>
<p>这题主要思想在于使用二分查找时，需要过滤空字符串，左右边界点和mid点都可能会遇到空字符串，因此需要把它给滤掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findString</span><span class="params">(String[] words, String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = words.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (words[left].equals(<span class="string">""</span>)) left++;</span><br><span class="line">        <span class="keyword">while</span> (words[right].equals(<span class="string">""</span>)) right--;</span><br><span class="line">        <span class="keyword">while</span> (words[mid].equals(<span class="string">""</span>) &amp;&amp; mid &lt; right) mid++;</span><br><span class="line">        <span class="keyword">if</span> (words[mid].equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            right = ((left + right) &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (words[mid].compareTo(s) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (words[mid].compareTo(s) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-10-09-Sorted-Matrix-Search"><a href="#LCCI-10-09-Sorted-Matrix-Search" class="headerlink" title="LCCI.10.09 Sorted Matrix Search"></a>LCCI.10.09 Sorted Matrix Search</h2><p>题目：</p>
<blockquote>
<p>Given an M x N matrix in which each row and each column is sorted in ascending order, write a method to find an element.</p>
</blockquote>
<p>这题我采用了对矩阵的每一行进行二分查找的方法来实现对整个数组的搜索：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> column = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (row &lt;= matrix.length - <span class="number">1</span> &amp;&amp; column &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (matrix[row][column] &gt; target) &#123;</span><br><span class="line">               column--;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][column] &lt; target) &#123;</span><br><span class="line">               row++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-10-11-Peaks-and-Valleys"><a href="#LCCI-10-11-Peaks-and-Valleys" class="headerlink" title="LCCI.10.11 Peaks and Valleys"></a>LCCI.10.11 Peaks and Valleys</h2><p>题目：</p>
<blockquote>
<p>In an array of integers, a “peak” is an element which is greater than or equal to the adjacent integers and a “valley” is an element which is less than or equal to the adjacent inte­gers. For example, in the array {5, 8, 6, 2, 3, 4, 6}, {8, 6} are peaks and {5, 2} are valleys. Given an array of integers, sort the array into an alternating sequence of peaks and valleys.</p>
</blockquote>
<p>这题的解法我看了提示才做出来，先将数组排序，再将排序好的数组按照峰谷位置进行交换。将前半段的峰位换到后半段的谷位上即可，需要注意的是处理中间位的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> mid = nums.length / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//排好序之后，将前半段的峰位与后半段的谷位进行交换即可得到峰-谷交错的序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mid &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//当中间位是偶数时，那么后半段的谷位从mid+1开始，如[1,2,3,4]的mid是2，下标为2的数字是3，后半段的谷位开始是第2+1位=4</span></span><br><span class="line">            swapab(nums, i, i + mid + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当中间位是奇数时，那么后半段的谷位从mid开始，如[1,2,3,4,5,6]的mid是3，下标为3的数字是4，后半段的谷位开始是第3位=4</span></span><br><span class="line">            swapab(nums, i, i + mid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapab</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[a];</span><br><span class="line">    nums[a] = nums[b];</span><br><span class="line">    nums[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-16-01-Swap-Numbers"><a href="#LCCI-16-01-Swap-Numbers" class="headerlink" title="LCCI.16.01 Swap Numbers"></a>LCCI.16.01 Swap Numbers</h2><p>题目：</p>
<blockquote>
<p>Write a function to swap a number in place (that is, without temporary vari­ ables).</p>
</blockquote>
<p>题目要求不使用额外的变量来实现两个数字的交换，因此我的第一反应是使用异或来完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] swapNumbers(<span class="keyword">int</span>[] numbers) &#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers[<span class="number">0</span>] == numbers[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> numbers;</span><br><span class="line">    &#125;</span><br><span class="line">    numbers[<span class="number">0</span>] = numbers[<span class="number">0</span>] ^ numbers[<span class="number">1</span>];</span><br><span class="line">    numbers[<span class="number">1</span>] = numbers[<span class="number">0</span>] ^ numbers[<span class="number">1</span>];</span><br><span class="line">    numbers[<span class="number">0</span>] = numbers[<span class="number">0</span>] ^ numbers[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> numbers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-16-04-Tic-Tac-Toe"><a href="#LCCI-16-04-Tic-Tac-Toe" class="headerlink" title="LCCI.16.04 Tic-Tac-Toe"></a>LCCI.16.04 Tic-Tac-Toe</h2><p>题目：</p>
<blockquote>
<p>Design an algorithm to figure out if someone has won a game of tic-tac-toe. Input is a string array of size N x N, including characters “ “, “X” and “O”, where “ “ represents a empty grid.</p>
<p>The rules of tic-tac-toe are as follows:</p>
<ul>
<li><p>Players place characters into an empty grid(“ “) in turn.</p>
</li>
<li><p>The first player always place character “O”, and the second one place “X”.</p>
</li>
<li><p>Players are only allowed to place characters in empty grid. Replacing a character is not allowed.</p>
</li>
<li><p>If there is any row, column or diagonal filled with N same characters, the game ends. The player who place the last charater wins.</p>
</li>
<li><p>When there is no empty grid, the game ends.</p>
</li>
<li><p>If the game ends, players cannot place any character further.</p>
</li>
</ul>
<p>If there is any winner, return the character that the winner used. If there’s a draw, return “Draw”. If the game doesn’t end and there is no winner, return “Pending”.</p>
</blockquote>
<p>这题其实比较简单，一开始我想通过动态规划来做，后来发现无法使用动态规划，因为这个不是路径问题。采用简单的分类讨论，注意下循环的细节处理就好了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">tictactoe</span><span class="params">(String[] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有玩家获胜</span></span><br><span class="line">        <span class="keyword">boolean</span> hasEmpty = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> hasWon = <span class="keyword">false</span>;</span><br><span class="line">        String res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> rowCheck = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">char</span> rowChar = board[i].charAt(<span class="number">0</span>);</span><br><span class="line">            res = String.valueOf(rowChar);</span><br><span class="line">            <span class="keyword">if</span> (rowChar == <span class="string">' '</span>) &#123;</span><br><span class="line">                hasEmpty = <span class="keyword">true</span>;</span><br><span class="line">                rowCheck = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i].charAt(j) == <span class="string">' '</span>) &#123;</span><br><span class="line">                    hasEmpty = <span class="keyword">true</span>;</span><br><span class="line">                    rowCheck = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rowChar != board[i].charAt(j)) &#123;</span><br><span class="line">                    rowCheck = <span class="keyword">false</span>;<span class="comment">//横向检查失败</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rowCheck) &#123;</span><br><span class="line">                hasWon = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hasWon) &#123;</span><br><span class="line">            <span class="comment">//纵向检查</span></span><br><span class="line">            String fRow = board[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fRow.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> cloumnCheck = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">char</span> charCon = fRow.charAt(i);</span><br><span class="line">                res = String.valueOf(charCon);</span><br><span class="line">                <span class="keyword">if</span> (charCon == <span class="string">' '</span>) &#123;</span><br><span class="line">                    hasEmpty = <span class="keyword">true</span>;</span><br><span class="line">                    cloumnCheck = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//纵向检查</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; board.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (board[j].charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                        cloumnCheck = <span class="keyword">false</span>;</span><br><span class="line">                        hasEmpty = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (charCon != board[j].charAt(i)) &#123;</span><br><span class="line">                        cloumnCheck = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cloumnCheck) &#123;</span><br><span class="line">                    hasWon = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!hasWon) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> diaglonCheck = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">char</span> charConStart = board[<span class="number">0</span>].charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">char</span> charConEnd = board[<span class="number">0</span>].charAt(board.length - <span class="number">1</span>);</span><br><span class="line">            res = String.valueOf(charConStart);</span><br><span class="line">            <span class="keyword">if</span> (charConStart == <span class="string">' '</span>) &#123;</span><br><span class="line">                hasEmpty = <span class="keyword">true</span>;</span><br><span class="line">                diaglonCheck = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">                <span class="comment">//对角线检查</span></span><br><span class="line">                <span class="keyword">if</span> (board[i].charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                    diaglonCheck = <span class="keyword">false</span>;</span><br><span class="line">                    hasEmpty = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (charConStart != board[i].charAt(i)) &#123;</span><br><span class="line">                    diaglonCheck = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (diaglonCheck) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">boolean</span> rightDiaglonCheck = <span class="keyword">true</span>;</span><br><span class="line">            res = String.valueOf(charConEnd);</span><br><span class="line">            <span class="keyword">if</span> (charConEnd == <span class="string">' '</span>) &#123;</span><br><span class="line">                hasEmpty = <span class="keyword">true</span>;</span><br><span class="line">                rightDiaglonCheck = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">                <span class="comment">//对角线检查</span></span><br><span class="line">                <span class="keyword">if</span> (board[i].charAt(board.length - <span class="number">1</span> - i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                    rightDiaglonCheck = <span class="keyword">false</span>;</span><br><span class="line">                    hasEmpty = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (charConEnd != board[i].charAt(board.length - <span class="number">1</span> - i)) &#123;</span><br><span class="line">                    rightDiaglonCheck = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rightDiaglonCheck) <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasWon) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasEmpty) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Pending"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Draw"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-16-05-Factorial-Zeros"><a href="#LCCI-16-05-Factorial-Zeros" class="headerlink" title="LCCI.16.05 Factorial Zeros"></a>LCCI.16.05 Factorial Zeros</h2><p>题目：</p>
<blockquote>
<p> Write an algorithm which computes the number of trailing zeros in n factorial.</p>
</blockquote>
<p>这题的主要思路是找出阶乘中的5的倍数有几个。如果遍历阶乘中的每个数来找则会超时，题目要求使时间复杂度达到O(logn)。因此，需要使用对5取整的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        count += n / <span class="number">5</span>;</span><br><span class="line">        n = n / <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-16-06-Smallest-Difference"><a href="#LCCI-16-06-Smallest-Difference" class="headerlink" title="LCCI.16.06 Smallest Difference"></a>LCCI.16.06 Smallest Difference</h2><p>题目：</p>
<blockquote>
<p>Given two arrays of integers, compute the pair of values (one value in each array) with the smallest (non-negative) difference. Return the difference.</p>
</blockquote>
<p>这题我只想到了排序，并没有想到双指针的算法，看了题解后才知道可以通过双指针逼近的方法来求解。此题有一点需要注意，就是当int中的数为int的最小值时，通过<code>Math.abs</code>取绝对值会溢出。在jdk中<code>Math.abs</code>方法是这么实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">abs</span><span class="params">(<span class="keyword">long</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &lt; <span class="number">0</span>) ? -a : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此需要使用long型来存储俩数之间的差，在相减之后对int数据进行强转，即可避免数据溢出的问题。同时由于方法的返回值是int，所以只需要在最后方法返回时，将最小值强转会int型即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestDifference</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">     Arrays.sort(a);</span><br><span class="line">     Arrays.sort(b);</span><br><span class="line">     <span class="keyword">long</span> min = Integer.MAX_VALUE;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (i &lt; a.length &amp;&amp; j &lt; b.length) &#123;</span><br><span class="line">         <span class="keyword">if</span> (Math.abs((<span class="keyword">long</span>)a[i] - (<span class="keyword">long</span>) b[j]) &lt; min) &#123;</span><br><span class="line">             min = Math.abs((<span class="keyword">long</span>)a[i] - (<span class="keyword">long</span>) b[j]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (a[i] &gt; b[j]) &#123;</span><br><span class="line">             j++;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             i++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">int</span>)min;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-16-07-Maximum"><a href="#LCCI-16-07-Maximum" class="headerlink" title="LCCI.16.07 Maximum"></a>LCCI.16.07 Maximum</h2><p>题目：</p>
<blockquote>
<p>Write a method that finds the maximum of two numbers. You should not use if-else or any other comparison operator.</p>
</blockquote>
<p>这题的主要思想在于，当不允许使用比较运算符和if-else时，可以通过将大数乘以1+小数乘以0的方式来返回最终的值。如果a和b是相同符好的数，则可以通过判断a-b的符号位来判断两个数的大小。将a乘以符号位，b乘以符号位的相反即可。</p>
<p>但是当符合位不同时，则需要对其进行特殊的处理。可以先取出a的符号位和b的符号位，再将两个数进行异或，为1说明符合位不同，为0说明符合位相同。那么当为0时，之间按照上述处理即可。为1时，则返回a乘以a的符号位加上b乘以b的符号位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> signa = sign(a);</span><br><span class="line">        <span class="keyword">int</span> signb = sign(b);</span><br><span class="line">        <span class="keyword">int</span> signc = sign(a - b);</span><br><span class="line">        <span class="keyword">int</span> same_sign_a = signa ^ signb;<span class="comment">//a,b符合相同为0  符号不同为1</span></span><br><span class="line">        <span class="keyword">int</span> same_sign_c = flip(same_sign_a);<span class="comment">//same_sign_a 的反向数</span></span><br><span class="line">        <span class="keyword">int</span> k = same_sign_a * signa + same_sign_c * signc;<span class="comment">//符合相同为signc，不同为signa</span></span><br><span class="line">        <span class="keyword">int</span> q = flip(k);</span><br><span class="line">        <span class="keyword">return</span> a * k + b * q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//翻转符号位</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">flip</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a ^ <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//负数返回0 正数返回a</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sign</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flip((a &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x01</span>);<span class="comment">//此处使用算术右移必须与0x01做与运算，不能与1做与运算</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-16-09-Operations"><a href="#LCCI-16-09-Operations" class="headerlink" title="LCCI.16.09 Operations"></a>LCCI.16.09 Operations</h2><p>题目：</p>
<blockquote>
<p>write methods to implement the multiply, subtract, and divide operations for integers. The results of all of these are integers. Use only the add operator.</p>
</blockquote>
<p>此题的解法与书本上不同，因为整数的最大和最小值很容易在LeetCode上跑超时，因此可采用二分法来做。减法用的是<code>a+-b</code>来实现。乘法使用二分累加即可。除法比较困难，参考题解后，采用的是32位数组来实现的每一位指数递增，详见解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + (-b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sameSign = ((a &gt;&gt; <span class="number">31</span>) ^ (b &gt;&gt; <span class="number">31</span>)) &amp; <span class="number">1</span>;<span class="comment">//符号位相同为0，相异为1</span></span><br><span class="line">        <span class="keyword">long</span> absA = Math.abs((<span class="keyword">long</span>) a) &lt; Math.abs((<span class="keyword">long</span>) b) ? Math.abs((<span class="keyword">long</span>) a) : Math.abs((<span class="keyword">long</span>) b);</span><br><span class="line">        <span class="keyword">long</span> absB = Math.abs((<span class="keyword">long</span>) a) &lt; Math.abs((<span class="keyword">long</span>) b) ? Math.abs((<span class="keyword">long</span>) b) : Math.abs((<span class="keyword">long</span>) a);</span><br><span class="line">        <span class="keyword">long</span> res = absB;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (absA &gt; temp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (absA &gt; temp + temp) &#123;</span><br><span class="line">                res += res;</span><br><span class="line">                temp += temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += absB;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sameSign == <span class="number">0</span> ? (<span class="keyword">int</span>) res : (<span class="keyword">int</span>) -res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0x80000000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sameSign = ((a &gt;&gt; <span class="number">31</span>) ^ (b &gt;&gt; <span class="number">31</span>)) &amp; <span class="number">1</span>;<span class="comment">//符号位相同为0，相异为1</span></span><br><span class="line">        <span class="keyword">int</span> absA = Math.abs(a);</span><br><span class="line">        <span class="keyword">int</span> absB = Math.abs(b);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">int</span>[] bit = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        temp[<span class="number">0</span>] = absB;</span><br><span class="line">        bit[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp[i - <span class="number">1</span>] + temp[i - <span class="number">1</span>] &gt; absA || temp[i - <span class="number">1</span>] + temp[i - <span class="number">1</span>] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            temp[i] = temp[i - <span class="number">1</span>] + temp[i - <span class="number">1</span>];</span><br><span class="line">            bit[i] = bit[i - <span class="number">1</span>] + bit[i - <span class="number">1</span>];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (absA &gt;= temp[i]) &#123;</span><br><span class="line">                absA = minus(absA, temp[i]);</span><br><span class="line">                res += bit[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sameSign == <span class="number">0</span> ? res : -res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-16-10-Living-People"><a href="#LCCI-16-10-Living-People" class="headerlink" title="LCCI.16.10 Living People"></a>LCCI.16.10 Living People</h2><p>题目：</p>
<blockquote>
<p>Given a list of people with their birth and death years, implement a method to compute the year with the most number of people alive. You may assume that all people were born between 1900 and 2000 (inclusive). If a person was alive during any portion of that year, they should be included in that year’s count. For example, Person (birth= 1908, death= 1909) is included in the counts for both 1908 and 1909.</p>
<p>If there are more than one years that have the most number of people alive, return the smallest one.</p>
</blockquote>
<p>这题我的思路是用双指针解法，但是一开始没有考虑到排序。具体解法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAliveYear</span><span class="params">(<span class="keyword">int</span>[] birth, <span class="keyword">int</span>[] death)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(birth);</span><br><span class="line">        Arrays.sort(death);</span><br><span class="line">        <span class="keyword">int</span> length = birth.length;</span><br><span class="line">        <span class="keyword">int</span> maxLivedYear = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> aliveCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> birthCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> deathCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (birth[i] &lt;= death[j]) &#123;</span><br><span class="line">                birthCount++;</span><br><span class="line">                <span class="keyword">if</span> (birthCount - deathCount &gt; aliveCount) &#123;</span><br><span class="line">                    aliveCount= birthCount-deathCount;</span><br><span class="line">                    maxLivedYear = birth[i];</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (birthCount - deathCount &gt; aliveCount) &#123;</span><br><span class="line">                    aliveCount= birthCount-deathCount;</span><br><span class="line">                    maxLivedYear = death[j];</span><br><span class="line">                &#125;</span><br><span class="line">                deathCount++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLivedYear;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-16-11-Diving-Board"><a href="#LCCI-16-11-Diving-Board" class="headerlink" title="LCCI.16.11 Diving Board"></a>LCCI.16.11 Diving Board</h2><p>题目：</p>
<blockquote>
<p>You are building a diving board by placing a bunch of planks of wood end-to-end. There are two types of planks, one of length shorter and one of length longer. You must use exactly K planks of wood. Write a method to generate all possible lengths for the diving board.</p>
<p>return all lengths in non-decreasing order.</p>
</blockquote>
<p>这题的思路是，因为必须要使用k个木板，所以从k个全是最短的木板，然后逐一新增长的木板开始计算总长度必然是递增的。只是需要注意处理下shoter与longer相等的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] divingBoard(<span class="keyword">int</span> shorter, <span class="keyword">int</span> longer, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shorter == longer) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;shorter * k&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        ans[i] = shorter * (k - i) + longer * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCCI-16-13-Bisect-Squares"><a href="#LCCI-16-13-Bisect-Squares" class="headerlink" title="LCCI.16.13 Bisect Squares"></a>LCCI.16.13 Bisect Squares</h2><p>题目：</p>
<blockquote>
<p>Given two squares on a two-dimensional plane, find a line that would cut these two squares in half. Assume that the top and the bottom sides of the square run parallel to the x-axis.</p>
<p>Each square consists of three values, the coordinate of bottom left corner [X,Y] = [square[0],square[1]], and the side length of the square square[2]. The line will intersect to the two squares in four points. Return the coordinates of two intersection points [X1,Y1] and [X2,Y2] that the forming segment covers the other two intersection points in format of {X1,Y1,X2,Y2}. If X1 != X2, there should be X1 &lt; X2, otherwise there should be Y1 &lt;= Y2.</p>
<p>If there are more than one line that can cut these two squares in half, return the one that has biggest slope (slope of a line parallel to the y-axis is considered as infinity).</p>
</blockquote>
<p>这题的难点有三个，一个是分析清楚，平分两个正方形的直线应该是两个正方形中心点的连线。第二点是需要知道斜率方程式：<code>y=kx+b</code>，计算每个点的值时需要加上截距<code>b</code>。第三点是，在计算最终的结果时，需要区分一些细节，这考验的是编码能力。边界重合的情况。最简单的做法应该是参照题解那样将几个交点列出来，取出最大最小值即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">double</span>[] cutSquares(<span class="keyword">int</span>[] square1, <span class="keyword">int</span>[] square2) &#123;</span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span> x1 = square1[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> x2 = square2[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y1 = square1[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> y2 = square2[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> center1x = (x1 + x1 + square1[<span class="number">2</span>]) / <span class="number">2</span>d;</span><br><span class="line">        <span class="keyword">double</span> center1y = (y1 + y1 + square1[<span class="number">2</span>]) / <span class="number">2</span>d;</span><br><span class="line">        <span class="keyword">double</span> center2x = (x2 + x2 + square2[<span class="number">2</span>]) / <span class="number">2</span>d;</span><br><span class="line">        <span class="keyword">double</span> center2y = (y2 + y2 + square2[<span class="number">2</span>]) / <span class="number">2</span>d;</span><br><span class="line">        <span class="keyword">if</span> (center1x == center2x) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = center1x;</span><br><span class="line">            res[<span class="number">1</span>] = y1 &lt; y2 ? y1 : y2;</span><br><span class="line">            res[<span class="number">2</span>] = center2x;</span><br><span class="line">            res[<span class="number">3</span>] = y1 + square1[<span class="number">2</span>] &lt; y2 + square2[<span class="number">2</span>] ? y2 + square2[<span class="number">2</span>] : y1 + square1[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (center1y == center2y) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = x1 &lt; x2 ? x1 : x2;</span><br><span class="line">            res[<span class="number">1</span>] = center1y;</span><br><span class="line">            res[<span class="number">2</span>] = x1 + square1[<span class="number">2</span>] &lt; x2 + square2[<span class="number">2</span>] ? x2 + square2[<span class="number">2</span>] : x1 + square1[<span class="number">2</span>];</span><br><span class="line">            res[<span class="number">3</span>] = center2y;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//斜率</span></span><br><span class="line">        <span class="keyword">double</span> rate = (center2y - center1y) / (center2x - center1x);</span><br><span class="line">        <span class="comment">//截距</span></span><br><span class="line">        <span class="keyword">double</span> dis = center1y - rate * center1x;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(rate) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//交点在上下边</span></span><br><span class="line">            <span class="keyword">int</span> bottomy = y1 &lt; y2 ? y1 : y2;</span><br><span class="line">            <span class="keyword">int</span> topy = y1 + square1[<span class="number">2</span>] &lt; y2 + square2[<span class="number">2</span>] ? y2 + square2[<span class="number">2</span>] : y1 + square1[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">double</span> bottomx = bottomy / rate;</span><br><span class="line">            <span class="keyword">double</span> topx = topy / rate;</span><br><span class="line">            <span class="comment">//point1：(y1+square[2]-dis)/rate , y1+square1[2]   ponit2:(y1-dis)/rate ,y1</span></span><br><span class="line">            <span class="comment">//point3: (y2+square2[2]-dis)/rate ,y2+square2[2]   point4:(y2-dis)/rate ,y2</span></span><br><span class="line">            res[<span class="number">0</span>] = Math.min(Math.min((y1+square1[<span class="number">2</span>]-dis)/rate,(y1-dis)/rate),Math.min((y2+square2[<span class="number">2</span>]-dis)/rate,(y2-dis)/rate));</span><br><span class="line">            res[<span class="number">1</span>] = res[<span class="number">0</span>] * rate + dis;</span><br><span class="line">            res[<span class="number">2</span>] = Math.max(Math.max((y1+square1[<span class="number">2</span>]-dis)/rate,(y1-dis)/rate),Math.max((y2+square2[<span class="number">2</span>]-dis)/rate,(y2-dis)/rate));</span><br><span class="line">            res[<span class="number">3</span>] = res[<span class="number">2</span>] * rate + dis;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//交点在左右两边</span></span><br><span class="line">            <span class="keyword">int</span> leftx = x1 &lt; x2 ? x1 : x2;</span><br><span class="line">            <span class="keyword">int</span> rightx = x1 + square1[<span class="number">2</span>] &lt; x2 + square2[<span class="number">2</span>] ? x2 + square2[<span class="number">2</span>] : x1 + square1[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">double</span> topy = leftx * rate;</span><br><span class="line">            <span class="keyword">double</span> bottomy = rightx * rate;</span><br><span class="line">            res[<span class="number">0</span>] = leftx;</span><br><span class="line">            res[<span class="number">1</span>] = topy + dis;</span><br><span class="line">            res[<span class="number">2</span>] = rightx;</span><br><span class="line">            res[<span class="number">3</span>] = bottomy + dis;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><ul>
<li>最重要的是要理解清楚题目的意思！！！</li>
<li>当使用异或进行数字交换时需要注意，刚开始的两个引用是否指向的是同个对象，若是同个对象则第一次异或时就会产生错误的结果，导致最终的结果是错误的。</li>
<li>字符串的调换位置、去重、判断奇偶操作这种类型的题目可以考虑将采取哈希映射为数组，或者bit位。用位操作来完成最后的识别判断。注意，当有顺序要求，不能去重统计时则不适用于哈希映射法。</li>
<li>双指针类问题，需要仔细分清不同 代码分支情况，一条条的梳理清楚。</li>
<li>对字符数组遍历，边界问题的测试需要考虑到字符长度为1，为0，遍历到尾部最后一个字符的处理逻辑；可以尝试通过在字符的最后补了一位来规避遍历时处理最后一个字符的特殊情况。</li>
<li>链表的删除可以考虑使用后续节点代替当前节点</li>
<li>在两个引用指向相同对象的，若想对两个对象内的数值进行互换不能采用异或操作。否则会导致结果为0。</li>
<li>遇到栈相关的问题，一般可以考虑使用临时的另一个栈来完成题目对于栈的顺序要求。</li>
<li>ArrayList和LinkedList的toArray方法并不能直接转换为数组，否则会报错。可以新建个数组，在使用<code>toArray(新数组)</code>的方法来实现转换为数组。</li>
<li>递归可以通过返回特定值来向上传递某种结果退出递归。</li>
<li><strong>递归题目，首要条件是要找到基准条件。找到之后可以分为自底向上和自顶而下两种写法，自底向上是将每一层的处理结果返回给上一层处理，每层在调用完递归后处理自己本层逻辑再返回。自顶而下则是先对自己本层的逻辑进行处理，然后再将数据封装到参数中递交给下一层处理。不管是自底向上还是自顶而下，都需要对返回条件进行特殊处理！</strong></li>
<li><strong>树的查找类问题，思考方向与递归遍历类似，应该是自顶而下或者自底而上。做优化时可以考虑如何将重复的递归逻辑给进行合并</strong></li>
<li>中等难度的问题基本都是将题目分析出来，再将思路编码出来。分析可以由暴力逐步优化，编码能力需要不断刷题实践。</li>
<li>当题目给出有序的条件时，这个条件利用好一般会有很好的效果。</li>
<li>在递归时，若发现可以缓存的数据，可以想办法通过数组或hash表来进行缓存，当然在缓存的时候也需要考虑内存是否会过大超出限制，这也是实现动态规划的一种方法。</li>
<li>递归需要全局的思考，不能陷入追究递归的过程中。</li>
<li>需要考虑数据规模，否则有些题目采用递归是无法做出来的，时间会超出限制。</li>
<li>二分查找的难点在于需要处理好左右边界点的移动，这涉及到循环打破的条件设置。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/LEETCODE/" rel="tag"># LEETCODE</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/21/LeetCode/" rel="next" title="LeetCode记录总结">
                <i class="fa fa-chevron-left"></i> LeetCode记录总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/07/25/JDB debug/" rel="prev" title="">
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="小蚂蚁爱吃香蕉" />
            
              <p class="site-author-name" itemprop="name">小蚂蚁爱吃香蕉</p>
              <p class="site-description motion-element" itemprop="description">至诚，至坚，博学，笃行</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Banana1995" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="gaomanyi698@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友链
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.cnblogs.com/chenpi/" title="风一样的码农" target="_blank">风一样的码农</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.hollischuang.com/" title="hollischuang" target="_blank">hollischuang</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#LeetCode记录总结"><span class="nav-number">1.</span> <span class="nav-text">LeetCode记录总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#242-Valid-Anagram"><span class="nav-number">1.1.</span> <span class="nav-text">242.Valid Anagram</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-01-01-Is-Unique"><span class="nav-number">1.2.</span> <span class="nav-text">LCCI.01.01 Is Unique</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-01-02-Check-Permutation"><span class="nav-number">1.3.</span> <span class="nav-text">LCCI.01.02 Check Permutation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-01-03-String-toURL"><span class="nav-number">1.4.</span> <span class="nav-text">LCCI.01.03 String toURL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-01-04-Palindrome-Permutation"><span class="nav-number">1.5.</span> <span class="nav-text">LCCI.01.04 Palindrome Permutation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-01-05-One-Away"><span class="nav-number">1.6.</span> <span class="nav-text">LCCI.01.05 One Away</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-01-06-Compress-String"><span class="nav-number">1.7.</span> <span class="nav-text">LCCI.01.06 Compress String</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-01-07-Rotate-Matrix"><span class="nav-number">1.8.</span> <span class="nav-text">LCCI.01.07 Rotate Matrix</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-01-08-Zero-Matrix"><span class="nav-number">1.9.</span> <span class="nav-text">LCCI.01.08 Zero Matrix</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-01-09-String-Rotation"><span class="nav-number">1.10.</span> <span class="nav-text">LCCI.01.09 String Rotation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-02-01-Remove-Duplicate-Node"><span class="nav-number">1.11.</span> <span class="nav-text">LCCI.02.01 Remove Duplicate Node</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-02-02-Kth-Node-From-End-of-List"><span class="nav-number">1.12.</span> <span class="nav-text">LCCI.02.02 Kth Node From End of List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-02-03-Delete-Middle-Node"><span class="nav-number">1.13.</span> <span class="nav-text">LCCI.02.03 Delete Middle Node</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-02-04-Partition-List"><span class="nav-number">1.14.</span> <span class="nav-text">LCCI.02.04 Partition List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-02-05-Sum-Lists"><span class="nav-number">1.15.</span> <span class="nav-text">LCCI.02.05 Sum Lists</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-02-06-Palindrome-Linked-List"><span class="nav-number">1.16.</span> <span class="nav-text">LCCI.02.06  Palindrome Linked List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-02-07-Intersection-of-Two-Linked-Lists"><span class="nav-number">1.17.</span> <span class="nav-text">LCCI.02.07 Intersection of Two Linked Lists</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-02-08-Linked-List-Cycle"><span class="nav-number">1.18.</span> <span class="nav-text">LCCI.02.08 Linked List Cycle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-03-01-Three-in-One"><span class="nav-number">1.19.</span> <span class="nav-text">LCCI.03.01 Three in One</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-03-02-Min-Stack"><span class="nav-number">1.20.</span> <span class="nav-text">LCCI.03.02 Min Stack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-03-03-Stack-of-Plates"><span class="nav-number">1.21.</span> <span class="nav-text">LCCI.03.03 Stack of Plates</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-03-04-Implement-Queue-using-Stacks"><span class="nav-number">1.22.</span> <span class="nav-text">LCCI.03.04 Implement Queue using Stacks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-03-05-Sort-of-Stacks"><span class="nav-number">1.23.</span> <span class="nav-text">LCCI.03.05 Sort of Stacks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-03-06-Animal-Shelter"><span class="nav-number">1.24.</span> <span class="nav-text">LCCI.03.06 Animal Shelter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-04-01-Route-Between-Nodes"><span class="nav-number">1.25.</span> <span class="nav-text">LCCI.04.01 Route Between Nodes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-04-02-Minimum-Height-Tree"><span class="nav-number">1.26.</span> <span class="nav-text">LCCI.04.02 Minimum Height Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-04-03-List-of-Depth"><span class="nav-number">1.27.</span> <span class="nav-text">LCCI.04.03 List of Depth</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-04-04-Check-Balance"><span class="nav-number">1.28.</span> <span class="nav-text">LCCI.04.04 Check Balance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-04-05-Legal-Binary-Search-Tree"><span class="nav-number">1.29.</span> <span class="nav-text">LCCI.04.05 Legal Binary Search Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-04-06-Successor-LCCI"><span class="nav-number">1.30.</span> <span class="nav-text">LCCI.04.06 Successor LCCI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-04-08-First-Common-Ancestor"><span class="nav-number">1.31.</span> <span class="nav-text">LCCI.04.08 First Common Ancestor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-04-10-Check-SubTree"><span class="nav-number">1.32.</span> <span class="nav-text">LCCI.04.10 Check SubTree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-04-12-Paths-with-Sum"><span class="nav-number">1.33.</span> <span class="nav-text">LCCI.04.12 Paths with Sum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-05-01-Insert-Into-Bits"><span class="nav-number">1.34.</span> <span class="nav-text">LCCI.05.01 Insert Into Bits</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-05-02-Binary-Number-to-String"><span class="nav-number">1.35.</span> <span class="nav-text">LCCI.05.02 Binary Number to String</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-05-03-Reverse-Bits"><span class="nav-number">1.36.</span> <span class="nav-text">LCCI.05.03 Reverse Bits</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-05-04-Closed-Number"><span class="nav-number">1.37.</span> <span class="nav-text">LCCI.05.04 Closed Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-05-06-Convert-Interger"><span class="nav-number">1.38.</span> <span class="nav-text">LCCI.05.06 Convert Interger</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-05-07-Exchange"><span class="nav-number">1.39.</span> <span class="nav-text">LCCI.05.07 Exchange</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-05-08-Draw-Line"><span class="nav-number">1.40.</span> <span class="nav-text">LCCI.05.08 Draw Line</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-08-01-Three-Steps-Problem"><span class="nav-number">1.41.</span> <span class="nav-text">LCCI.08.01 Three Steps Problem</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-08-02-Robot-in-a-Grid"><span class="nav-number">1.42.</span> <span class="nav-text">LCCI.08.02  Robot in a Grid</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-08-03-Magic-Index"><span class="nav-number">1.43.</span> <span class="nav-text">LCCI.08.03 Magic Index</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-08-04-Power-Set"><span class="nav-number">1.44.</span> <span class="nav-text">LCCI.08.04 Power Set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-08-05-Recursive-Multiply"><span class="nav-number">1.45.</span> <span class="nav-text">LCCI.08.05 Recursive Multiply</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-08-06-Hanota"><span class="nav-number">1.46.</span> <span class="nav-text">LCCI.08.06 Hanota</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-08-07-Permutation"><span class="nav-number">1.47.</span> <span class="nav-text">LCCI.08.07 Permutation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-08-09-Bracket"><span class="nav-number">1.48.</span> <span class="nav-text">LCCI.08.09 Bracket</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-08-10-Color-Fill"><span class="nav-number">1.49.</span> <span class="nav-text">LCCI.08.10 Color Fill</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-08-11-Coin"><span class="nav-number">1.50.</span> <span class="nav-text">LCCI.08.11 Coin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-08-12-Eight-Queens"><span class="nav-number">1.51.</span> <span class="nav-text">LCCI.08.12 Eight Queens</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-08-13-Pile-Box"><span class="nav-number">1.52.</span> <span class="nav-text">LCCI.08.13 Pile Box</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-08-14-Boolean-Evaluation"><span class="nav-number">1.53.</span> <span class="nav-text">LCCI.08.14 Boolean Evaluation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-10-01-Sorted-Merge"><span class="nav-number">1.54.</span> <span class="nav-text">LCCI.10.01 Sorted Merge</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-10-02-Group-Anagrams"><span class="nav-number">1.55.</span> <span class="nav-text">LCCI.10.02 Group Anagrams</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-10-03-Search-Rotate-Array"><span class="nav-number">1.56.</span> <span class="nav-text">LCCI.10.03 Search Rotate Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-10-05-Sparse-Array-Search"><span class="nav-number">1.57.</span> <span class="nav-text">LCCI.10.05 Sparse Array Search</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-10-09-Sorted-Matrix-Search"><span class="nav-number">1.58.</span> <span class="nav-text">LCCI.10.09 Sorted Matrix Search</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-10-11-Peaks-and-Valleys"><span class="nav-number">1.59.</span> <span class="nav-text">LCCI.10.11 Peaks and Valleys</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-16-01-Swap-Numbers"><span class="nav-number">1.60.</span> <span class="nav-text">LCCI.16.01 Swap Numbers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-16-04-Tic-Tac-Toe"><span class="nav-number">1.61.</span> <span class="nav-text">LCCI.16.04 Tic-Tac-Toe</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-16-05-Factorial-Zeros"><span class="nav-number">1.62.</span> <span class="nav-text">LCCI.16.05 Factorial Zeros</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-16-06-Smallest-Difference"><span class="nav-number">1.63.</span> <span class="nav-text">LCCI.16.06 Smallest Difference</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-16-07-Maximum"><span class="nav-number">1.64.</span> <span class="nav-text">LCCI.16.07 Maximum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-16-09-Operations"><span class="nav-number">1.65.</span> <span class="nav-text">LCCI.16.09 Operations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-16-10-Living-People"><span class="nav-number">1.66.</span> <span class="nav-text">LCCI.16.10 Living People</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-16-11-Diving-Board"><span class="nav-number">1.67.</span> <span class="nav-text">LCCI.16.11 Diving Board</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCCI-16-13-Bisect-Squares"><span class="nav-number">1.68.</span> <span class="nav-text">LCCI.16.13 Bisect Squares</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#经验总结"><span class="nav-number">1.69.</span> <span class="nav-text">经验总结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小蚂蚁爱吃香蕉</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
