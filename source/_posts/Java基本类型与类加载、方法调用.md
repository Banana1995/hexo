---
title: Java基本类型与类加载、方法调用
date: 2018-08-15 20:02:12
categories: "JVM基础"
tags: "JVM"
---

##  一、 Java代码的运行方式

### 1. Java程序需要运行在虚拟机中

Java虚拟机为java程序的运行提供了一个软件环境，这样做的好处是，可以使Java程序在不同的硬件平台上运行。Java程序被编译成为字节码文件后，只要在不同的平台上安装好Java虚拟机就可以运行了。

同时，Java虚拟机还为Java程序提供了一种托管环境，这个环境可以给Java程序提供一些很便捷的功能，如垃圾回收和自动内存管理等

<!--more-->

### 2. Java虚拟机如何运行字节码

JVM运行Java程序，首先需要将它的class文件加载至内存的方法区中。在运行时，会执行方法区内的代码。Java的对象存在堆内存中，在栈内存中又分为面向本地方法的本地方法栈和面向Java方法的Java方法栈，以及记录每个线程执行位置的PC寄存器，JVM会在当前线程的Java方法栈中生成一个栈帧。每次执行一个方法，相当于栈帧的进栈和出栈。

![](Java基本类型与类加载、方法调用\微信截图_20180811161053.png)



从硬件的角度来讲，机器是不能直接执行java字节码的。因此，jvm需要交java字节码翻译成机器码。在HotSpot里面，翻译成机器码的过程有两种方式，一种是解释执行，即逐条将字节码翻译成机器码。一种是即时编译（JIT），教一个方法中所有的字节码，全部编译成机器码之后再执行。解释执行的优势在于无需等待编译，而即时编译方式的优势在于，实际执行速度更快。

![](Java基本类型与类加载、方法调用\微信截图_20180827220520.png)

在HotSpot中，将需要多次执行的热点代码，使用即时编译的方式执行。将执行次数小于15次定义为非热点代码，这一部分代码是通过解释执行的方式执行。

## 二、基本类型

在JVM中，变量存储的数据是可以超出它定义的范围的。boolean类型的数据在JVM中被翻译为1和0，但是我们可以通过修改字节码的方式，将2存储为boolean数据。

![](Java基本类型与类加载、方法调用\微信截图_20180827221654.png)

- 值域小的数据类型向值域大的类型转换时，是不需要进行数据强转的。
- **基本类型的包装类型之间是无法进行强制转换。** 
- java中的正无穷和负无穷，都是有明确的数值的。在内存中分别等同于十六进制整数 0x7F800000 和 0xFF800000。超出了正无穷和负无穷之间的其他数字对应的浮点数是`NaN`。
- `NaN`和任何一个浮点数（不管是0还是NaN）比较时，除了`!=`返回`true`以外，其他均返回`false`。

### 1.存储

在java的方法栈帧中分为局部变量区和字节码的操作数栈。局部变量就相当于一个数组，除了long和double占两个数组单元以外，其他基本数据类型都只占用一个数组单元（32位是4个字节，64位是8个字节），也就是说，其他数据类型都和int型一样，在栈帧中占4个字节（64位的HotSpot占8个字节）。注意：**这里是指在栈里面，而在堆中的字段或数据里面byte、char、short分别占有一个字节，两个字节，两个字节。 也就是说跟它们的值域是相吻合的。**

一个int型的数据存储进字段或数组中时，是会进行隐式的的掩码操作。举例来说，当我们把 0xFFFFFFFF（-1）存储到一个声明为 char 类型的字段里时，由于该字段仅占两字节，所以高两位字节会被截掉。同样，对于boolean类型来说，在存储时会显示的进行掩码操作，只取最后一位存入字段或数组中。

### 2.加载

我们需要将堆中全部数据加载到栈中计算，也就是说我们需要将boolean、byte、char、short加载到操作数栈中，而后将栈中的数值当成int型来计算。对于char和byte来说，无符号型数据加载伴随着0扩展。char占有两字节，会被复制到栈中的低两字节，高两字节则用0补充。

同理，对于有符号类型的数据加载则进行符号扩展，高两字节用符号位填充。

## 三、类加载

类的加载过程主要是三大步骤。分别为加载、链接和初始化。

### 1. 加载

加载的过程就是查找字节流，并且创建这个类。加载需要借助类加载器。在JVM中，类加载器使用双亲委派模式，收到一个类加载请求之后，需要先转派给父类加载器，父类加载器没有找到所请求的类的情况下，子类加载器才会尝试去加载。

最基础的类加载器是启动类加载器（boot classLoader），它是由C++实现的，没有对应的Java对象，因此只能用null来代表它。除了启动类加载器以外，其他的类加载器都是java.lang.ClassLoader的子类，这些类加载器都需要启动类加载器加载进JVM中才能使用。

除了启动类加载器以外，还有一些较为重要的加载器如扩展类加载器和应用类加载器。**扩展类加载器的父类是启动类加载器，应用类加载器的父类是扩展类加载器。** 默认情况下，应用程序中的类是由应用类加载器加载的。我们可以自己实现类加载器来完成自定义的一些功能，如class文件的加密解密等。

JVM中，类的唯一性是由类加载器实例以及类的全名一同确认的。所以同一段字节码，被两个类加载器加载之后也会得到两个不同的类。

相当于造房子的时候，找到一个老师傅来在一个地址上开始创建过程。

### 2. 链接

链接又分为验证，准备和解析三个阶段。

验证是为了确保被加载的类能够符合JVM的约束条件。相当于上报监管部门审批造房。

准备是为了给被加载类的静态字段分配内存。相当于盖好了毛坯房。

解析是为了将被加载类的类成员、字段等符号引用解析成实际引用。如果符号引用指向的是一个未被加载的类，那么解析会出发那个类的加载，但不一定出发类的链接和初始化。这里的符号引用是指，编译器在编译的时候将被引用的字段、类、方法生成一个符号引用来代替它本身。而将符号引用解析未实际引用就是将在字节码中的符号引用替换位在JVM中的实际内存地址。

如果将这段话放在盖房子的语境下，那么符号引用就好比，“张三的房子”这种说法。不管他存不存在，我们都可以用这种说法来指代张三的房子，实际应用则好比是实际的通讯地址，如果我们想要与张三通信，那么必须要将“张三的房子”变成实际的通讯地址。如果这个实际的通讯地址不存在，则需要启动张三的盖房子过程的第一步，即选择好师傅在一个地址上开始创建。

### 3. 初始化

静态代码块中的代码和直接赋值操作被编译器放置在同一个方法中，叫做<clinit>。

类的初始化便是为常量值字段赋值以及执行<clinit>方法。

## 四、方法调用

### 1. 重载、重写、动态绑定与静态绑定

- **不建议重载可变长参数的方法。**因为这可能会导致java编译器无法确定应该调用哪个目标方法。
- java编译器在编译的时候已经区分了重载，所以我们可以认为在jvm里面不存在重载这个概念。
- jvm中的动态绑定指的是需要在运行过程中，根据**调用者的动态类型**来识别目标方法。而静态绑定指的是在解析时便能够直接识别目标方法的情况。

java字节码中调用相关的指令共有五种:

- `invokestatic`:用于调用静态方法。
- `invokespecial`:用于调用私有实例方法，构造器，以及使用super关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
- `invokevirtual`:用于调用非私有实例方法。
- `invokeinterface`:用于调用接口方法。
- `invokedynamic`:用于调用动态方法。

对于`invokevirtual` 和`invokedynamic` 虚拟机需要在执行过程中，根据调用的动态类型来确定具体的目标方法。也就是说这两个编译指令，需要使用动态绑定。

对于静态绑定而已，符号引用被解析成实际引用时，这个实际引用是一个指向方法的指针。对于动态绑定而言，实际引用则是一个方法表的索引。

### 2. 动态绑定

在JVM中，静态绑定包括用于调用静态方法的`invokestatic`指令和用于调用构造器，私有实例方法以及父类非私有实例方法的`invokespecial` 指令。如果虚方法调用指向一个标记为final的方法，那么JVM也可以静态绑定该虚方法调用的目标方法。

1. 方法表

在类加载的时候，除了为静态字段分配内存以外，还会构造与该类相关的方法表。

方法表的本质是一个数组，每个数组元素指向一个当前类以及其父类中非私有实例方法。对于动态绑定而言，实际引用则是方法表的索引值。

在执行过程中，JVM将获取调用者的实际类型，并在实际类型的虚方法表中，根据索引值获得目标方法，这个过程便是动态绑定。

2. 内联缓存

内联缓存，本质上是一种加快动态绑定的技术。它能够缓存虚方法的调用者动态类型，以及该类型所对应的目标方法。在之后的执行过程中，如果已经到缓存过的类型，内联缓存便会直接调用该类型所对应的目标方法。





